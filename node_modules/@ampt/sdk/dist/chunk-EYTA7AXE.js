import { createRequire as topLevelCreateRequire } from 'module'
const require = topLevelCreateRequire(import.meta.url)

// ../../lib/fs/index.ts
import fs from "fs/promises";

// ../../node_modules/aws4fetch/dist/aws4fetch.esm.mjs
var encoder = new TextEncoder();
var HOST_SERVICES = {
  appstream2: "appstream",
  cloudhsmv2: "cloudhsm",
  email: "ses",
  marketplace: "aws-marketplace",
  mobile: "AWSMobileHubService",
  pinpoint: "mobiletargeting",
  queue: "sqs",
  "git-codecommit": "codecommit",
  "mturk-requester-sandbox": "mturk-requester",
  "personalize-runtime": "personalize"
};
var UNSIGNABLE_HEADERS = /* @__PURE__ */ new Set([
  "authorization",
  "content-type",
  "content-length",
  "user-agent",
  "presigned-expires",
  "expect",
  "x-amzn-trace-id",
  "range",
  "connection"
]);
var AwsClient = class {
  constructor({ accessKeyId, secretAccessKey, sessionToken, service, region, cache, retries, initRetryMs }) {
    if (accessKeyId == null)
      throw new TypeError("accessKeyId is a required option");
    if (secretAccessKey == null)
      throw new TypeError("secretAccessKey is a required option");
    this.accessKeyId = accessKeyId;
    this.secretAccessKey = secretAccessKey;
    this.sessionToken = sessionToken;
    this.service = service;
    this.region = region;
    this.cache = cache || /* @__PURE__ */ new Map();
    this.retries = retries != null ? retries : 10;
    this.initRetryMs = initRetryMs || 50;
  }
  async sign(input, init) {
    if (input instanceof Request) {
      const { method, url, headers, body } = input;
      init = Object.assign({ method, url, headers }, init);
      if (init.body == null && headers.has("Content-Type")) {
        init.body = body != null && headers.has("X-Amz-Content-Sha256") ? body : await input.clone().arrayBuffer();
      }
      input = url;
    }
    const signer = new AwsV4Signer(Object.assign({ url: input }, init, this, init && init.aws));
    const signed = Object.assign({}, init, await signer.sign());
    delete signed.aws;
    try {
      return new Request(signed.url.toString(), signed);
    } catch (e) {
      if (e instanceof TypeError) {
        return new Request(signed.url.toString(), Object.assign({ duplex: "half" }, signed));
      }
      throw e;
    }
  }
  async fetch(input, init) {
    for (let i = 0; i <= this.retries; i++) {
      const fetched = fetch(await this.sign(input, init));
      if (i === this.retries) {
        return fetched;
      }
      const res = await fetched;
      if (res.status < 500 && res.status !== 429) {
        return res;
      }
      await new Promise((resolve) => setTimeout(resolve, Math.random() * this.initRetryMs * Math.pow(2, i)));
    }
    throw new Error("An unknown error occurred, ensure retries is not negative");
  }
};
var AwsV4Signer = class {
  constructor({ method, url, headers, body, accessKeyId, secretAccessKey, sessionToken, service, region, cache, datetime, signQuery, appendSessionToken, allHeaders, singleEncode }) {
    if (url == null)
      throw new TypeError("url is a required option");
    if (accessKeyId == null)
      throw new TypeError("accessKeyId is a required option");
    if (secretAccessKey == null)
      throw new TypeError("secretAccessKey is a required option");
    this.method = method || (body ? "POST" : "GET");
    this.url = new URL(url);
    this.headers = new Headers(headers || {});
    this.body = body;
    this.accessKeyId = accessKeyId;
    this.secretAccessKey = secretAccessKey;
    this.sessionToken = sessionToken;
    let guessedService, guessedRegion;
    if (!service || !region) {
      [guessedService, guessedRegion] = guessServiceRegion(this.url, this.headers);
    }
    this.service = service || guessedService || "";
    this.region = region || guessedRegion || "us-east-1";
    this.cache = cache || /* @__PURE__ */ new Map();
    this.datetime = datetime || (/* @__PURE__ */ new Date()).toISOString().replace(/[:-]|\.\d{3}/g, "");
    this.signQuery = signQuery;
    this.appendSessionToken = appendSessionToken || this.service === "iotdevicegateway";
    this.headers.delete("Host");
    if (this.service === "s3" && !this.signQuery && !this.headers.has("X-Amz-Content-Sha256")) {
      this.headers.set("X-Amz-Content-Sha256", "UNSIGNED-PAYLOAD");
    }
    const params = this.signQuery ? this.url.searchParams : this.headers;
    params.set("X-Amz-Date", this.datetime);
    if (this.sessionToken && !this.appendSessionToken) {
      params.set("X-Amz-Security-Token", this.sessionToken);
    }
    this.signableHeaders = ["host", ...this.headers.keys()].filter((header) => allHeaders || !UNSIGNABLE_HEADERS.has(header)).sort();
    this.signedHeaders = this.signableHeaders.join(";");
    this.canonicalHeaders = this.signableHeaders.map((header) => header + ":" + (header === "host" ? this.url.host : (this.headers.get(header) || "").replace(/\s+/g, " "))).join("\n");
    this.credentialString = [this.datetime.slice(0, 8), this.region, this.service, "aws4_request"].join("/");
    if (this.signQuery) {
      if (this.service === "s3" && !params.has("X-Amz-Expires")) {
        params.set("X-Amz-Expires", "86400");
      }
      params.set("X-Amz-Algorithm", "AWS4-HMAC-SHA256");
      params.set("X-Amz-Credential", this.accessKeyId + "/" + this.credentialString);
      params.set("X-Amz-SignedHeaders", this.signedHeaders);
    }
    if (this.service === "s3") {
      try {
        this.encodedPath = decodeURIComponent(this.url.pathname.replace(/\+/g, " "));
      } catch (e) {
        this.encodedPath = this.url.pathname;
      }
    } else {
      this.encodedPath = this.url.pathname.replace(/\/+/g, "/");
    }
    if (!singleEncode) {
      this.encodedPath = encodeURIComponent(this.encodedPath).replace(/%2F/g, "/");
    }
    this.encodedPath = encodeRfc3986(this.encodedPath);
    const seenKeys = /* @__PURE__ */ new Set();
    this.encodedSearch = [...this.url.searchParams].filter(([k]) => {
      if (!k)
        return false;
      if (this.service === "s3") {
        if (seenKeys.has(k))
          return false;
        seenKeys.add(k);
      }
      return true;
    }).map((pair) => pair.map((p) => encodeRfc3986(encodeURIComponent(p)))).sort(([k1, v1], [k2, v2]) => k1 < k2 ? -1 : k1 > k2 ? 1 : v1 < v2 ? -1 : v1 > v2 ? 1 : 0).map((pair) => pair.join("=")).join("&");
  }
  async sign() {
    if (this.signQuery) {
      this.url.searchParams.set("X-Amz-Signature", await this.signature());
      if (this.sessionToken && this.appendSessionToken) {
        this.url.searchParams.set("X-Amz-Security-Token", this.sessionToken);
      }
    } else {
      this.headers.set("Authorization", await this.authHeader());
    }
    return {
      method: this.method,
      url: this.url,
      headers: this.headers,
      body: this.body
    };
  }
  async authHeader() {
    return [
      "AWS4-HMAC-SHA256 Credential=" + this.accessKeyId + "/" + this.credentialString,
      "SignedHeaders=" + this.signedHeaders,
      "Signature=" + await this.signature()
    ].join(", ");
  }
  async signature() {
    const date = this.datetime.slice(0, 8);
    const cacheKey = [this.secretAccessKey, date, this.region, this.service].join();
    let kCredentials = this.cache.get(cacheKey);
    if (!kCredentials) {
      const kDate = await hmac("AWS4" + this.secretAccessKey, date);
      const kRegion = await hmac(kDate, this.region);
      const kService = await hmac(kRegion, this.service);
      kCredentials = await hmac(kService, "aws4_request");
      this.cache.set(cacheKey, kCredentials);
    }
    return buf2hex(await hmac(kCredentials, await this.stringToSign()));
  }
  async stringToSign() {
    return [
      "AWS4-HMAC-SHA256",
      this.datetime,
      this.credentialString,
      buf2hex(await hash(await this.canonicalString()))
    ].join("\n");
  }
  async canonicalString() {
    return [
      this.method.toUpperCase(),
      this.encodedPath,
      this.encodedSearch,
      this.canonicalHeaders + "\n",
      this.signedHeaders,
      await this.hexBodyHash()
    ].join("\n");
  }
  async hexBodyHash() {
    let hashHeader = this.headers.get("X-Amz-Content-Sha256") || (this.service === "s3" && this.signQuery ? "UNSIGNED-PAYLOAD" : null);
    if (hashHeader == null) {
      if (this.body && typeof this.body !== "string" && !("byteLength" in this.body)) {
        throw new Error("body must be a string, ArrayBuffer or ArrayBufferView, unless you include the X-Amz-Content-Sha256 header");
      }
      hashHeader = buf2hex(await hash(this.body || ""));
    }
    return hashHeader;
  }
};
async function hmac(key, string) {
  const cryptoKey = await crypto.subtle.importKey(
    "raw",
    typeof key === "string" ? encoder.encode(key) : key,
    { name: "HMAC", hash: { name: "SHA-256" } },
    false,
    ["sign"]
  );
  return crypto.subtle.sign("HMAC", cryptoKey, encoder.encode(string));
}
async function hash(content) {
  return crypto.subtle.digest("SHA-256", typeof content === "string" ? encoder.encode(content) : content);
}
function buf2hex(buffer) {
  return Array.prototype.map.call(new Uint8Array(buffer), (x) => ("0" + x.toString(16)).slice(-2)).join("");
}
function encodeRfc3986(urlEncodedStr) {
  return urlEncodedStr.replace(/[!'()*]/g, (c) => "%" + c.charCodeAt(0).toString(16).toUpperCase());
}
function guessServiceRegion(url, headers) {
  const { hostname, pathname } = url;
  if (hostname.endsWith(".r2.cloudflarestorage.com")) {
    return ["s3", "auto"];
  }
  if (hostname.endsWith(".backblazeb2.com")) {
    const match2 = hostname.match(/^(?:[^.]+\.)?s3\.([^.]+)\.backblazeb2\.com$/);
    return match2 != null ? ["s3", match2[1]] : ["", ""];
  }
  const match = hostname.replace("dualstack.", "").match(/([^.]+)\.(?:([^.]*)\.)?amazonaws\.com(?:\.cn)?$/);
  let [service, region] = (match || ["", ""]).slice(1, 3);
  if (region === "us-gov") {
    region = "us-gov-west-1";
  } else if (region === "s3" || region === "s3-accelerate") {
    region = "us-east-1";
    service = "s3";
  } else if (service === "iot") {
    if (hostname.startsWith("iot.")) {
      service = "execute-api";
    } else if (hostname.startsWith("data.jobs.iot.")) {
      service = "iot-jobs-data";
    } else {
      service = pathname === "/mqtt" ? "iotdevicegateway" : "iotdata";
    }
  } else if (service === "autoscaling") {
    const targetPrefix = (headers.get("X-Amz-Target") || "").split(".")[0];
    if (targetPrefix === "AnyScaleFrontendService") {
      service = "application-autoscaling";
    } else if (targetPrefix === "AnyScaleScalingPlannerFrontendService") {
      service = "autoscaling-plans";
    }
  } else if (region == null && service.startsWith("s3-")) {
    region = service.slice(3).replace(/^fips-|^external-1/, "");
    service = "s3";
  } else if (service.endsWith("-fips")) {
    service = service.slice(0, -5);
  } else if (region && /-\d$/.test(service) && !/-\d$/.test(region)) {
    [service, region] = [region, service];
  }
  return [HOST_SERVICES[service] || service, region];
}

// ../../lib/aws/s3.ts
var aws = new AwsClient({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  sessionToken: process.env.AWS_SESSION_TOKEN,
  region: process.env.AWS_REGION
});

// ../../lib/fs/index.ts
var CHUNK_SIZE = 1024;
var StreamingResponse = class extends Response {
  #body;
  constructor(body, init) {
    const isStream = body instanceof ReadableStream;
    super(isStream ? null : body, init);
    this.#body = body;
  }
  get body() {
    return this.#body;
  }
};
function createReadableStream(filename) {
  let fileHandle;
  let position = 0;
  return new ReadableStream({
    async start() {
      fileHandle = await fs.open(filename, "r");
    },
    async pull(controller) {
      const buffer = new Uint8Array(CHUNK_SIZE);
      const { bytesRead } = await fileHandle.read(buffer, 0, CHUNK_SIZE, position);
      if (bytesRead === 0) {
        await fileHandle.close();
        controller.close();
      } else {
        position += bytesRead;
        controller.enqueue(buffer.subarray(0, bytesRead));
      }
    },
    cancel() {
      return fileHandle.close();
    }
  });
}

// http/framework/finish.ts
async function finish(item, ...details) {
  await new Promise((resolve, reject) => {
    if (item.writableEnded || item.complete) {
      resolve();
      return;
    }
    let finished = false;
    function done(err) {
      if (finished) {
        return;
      }
      finished = true;
      item.removeListener("error", done);
      item.removeListener("end", done);
      item.removeListener("finish", done);
      if (err) {
        reject(err);
      } else {
        resolve();
      }
    }
    item.once("error", done);
    item.once("end", done);
    item.once("finish", done);
  });
  return item;
}

// http/framework/get-framework.ts
import http2 from "node:http";

// http/framework/response.ts
import http from "node:http";
var headerEnd = "\r\n\r\n";
var BODY = Symbol();
var HEADERS = Symbol();
function getString(data) {
  if (Buffer.isBuffer(data)) {
    return data.toString("utf8");
  } else if (typeof data === "string") {
    return data;
  } else {
    throw new Error(`response.write() of unexpected type: ${typeof data}`);
  }
}
function addData(stream, data) {
  if (Buffer.isBuffer(data) || typeof data === "string" || data instanceof Uint8Array) {
    stream[BODY].push(Buffer.from(data));
  } else {
    throw new Error(`response.write() of unexpected type: ${typeof data}`);
  }
}
var ServerlessResponse = class extends http.ServerResponse {
  _header = "";
  _wroteHeader = false;
  constructor(request) {
    super(request);
    this[BODY] = [];
    this[HEADERS] = {};
    this.useChunkedEncodingByDefault = false;
    this.chunkedEncoding = false;
    this._header = "";
    this.assignSocket({
      _writableState: {},
      writable: true,
      // @ts-ignore
      on: Function.prototype,
      // @ts-ignore
      removeListener: Function.prototype,
      // @ts-ignore
      destroy: Function.prototype,
      // @ts-ignore
      cork: Function.prototype,
      // @ts-ignore
      uncork: Function.prototype,
      // @ts-ignore
      write: (data, encoding, cb) => {
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = void 0;
        }
        if (this._header === "" || this._wroteHeader) {
          addData(this, data);
        } else {
          const string = getString(data);
          const index = string.indexOf(headerEnd);
          if (index !== -1) {
            const remainder = string.slice(index + headerEnd.length);
            if (remainder) {
              addData(this, remainder);
            }
            this._wroteHeader = true;
          }
        }
        if (typeof cb === "function") {
          cb();
        }
      }
    });
    this.once("finish", () => {
      this.emit("close");
    });
  }
  static from(res) {
    const response = new ServerlessResponse(res);
    response.statusCode = res.statusCode;
    response[HEADERS] = res.headers;
    response[BODY] = [Buffer.from(res.body)];
    response.end();
    return response;
  }
  static body(res) {
    return Buffer.concat(res[BODY]);
  }
  static headers(res) {
    const headers = typeof res.getHeaders === "function" ? res.getHeaders() : res._headers;
    return Object.assign(headers, res[HEADERS]);
  }
  get headers() {
    return this[HEADERS];
  }
  setHeader(key, value) {
    if (this._wroteHeader) {
      this[HEADERS][key] = value;
    } else {
      super.setHeader(key, value);
    }
    return this;
  }
  writeHead(statusCode, reason, obj) {
    if (reason || obj) {
      let headers = {};
      if (typeof reason === "string" && obj) {
        headers = obj;
      } else if (typeof reason === "object") {
        headers = reason;
      }
      for (const name in headers) {
        this.setHeader(name, headers[name]);
        if (!this._wroteHeader) {
          break;
        }
      }
    }
    super.writeHead(statusCode, reason, obj);
    return this;
  }
};

// http/framework/get-framework.ts
function common(cb) {
  return (request) => {
    const response = new ServerlessResponse(request);
    cb(request, response);
    return response;
  };
}
function getFramework(app) {
  if (app instanceof http2.Server) {
    return (request) => {
      const response = new ServerlessResponse(request);
      app.emit("request", request, response);
      return response;
    };
  }
  if (typeof app.callback === "function") {
    return common(app.callback());
  }
  if (typeof app.handle === "function") {
    return common((request, response) => {
      app.handle(request, response);
    });
  }
  if (typeof app.handler === "function") {
    return common((request, response) => {
      app.handler(request, response);
    });
  }
  if (typeof app._onRequest === "function") {
    return common((request, response) => {
      app._onRequest(request, response);
    });
  }
  if (typeof app === "function") {
    return common(app);
  }
  if (app.router && typeof app.router.route == "function") {
    return common((req, res) => {
      const { url, method, headers, body } = req;
      app.router.route({ url, method, headers, body }, res);
    });
  }
  if (app._core && typeof app._core._dispatch === "function") {
    return common(
      app._core._dispatch({
        app
      })
    );
  }
  if (typeof app.inject === "function") {
    return async (request) => {
      const { method, url, headers, body } = request;
      const res = await app.inject({ method, url, headers, payload: body });
      return ServerlessResponse.from(res);
    };
  }
  if (typeof app.main === "function") {
    return common(app.main);
  }
  throw new Error("Unsupported framework");
}

// http/framework/request.ts
import http3 from "node:http";
var ServerlessRequest = class extends http3.IncomingMessage {
  // type dis
  requestContext;
  // type dis
  apiGateway;
  constructor({
    method,
    url,
    headers,
    body,
    remoteAddress
  }) {
    super({
      encrypted: true,
      readable: false,
      remoteAddress,
      address: () => ({ port: 443 }),
      // @ts-ignore
      end: Function.prototype,
      // @ts-ignore
      destroy: Function.prototype
    });
    if (typeof headers["content-length"] === "undefined") {
      headers["content-length"] = body ? Buffer.byteLength(body).toString() : "0";
    }
    Object.assign(this, {
      ip: remoteAddress,
      complete: true,
      httpVersion: "1.1",
      httpVersionMajor: "1",
      httpVersionMinor: "1",
      method,
      headers,
      body,
      url
    });
    this._read = () => {
      this.push(body);
      this.push(null);
    };
  }
};

// http/framework/create-request.ts
var create_request_default = (request, context) => {
  const httpHeaders = {};
  request.headers.forEach((value, key) => {
    httpHeaders[key] = value;
  });
  return new ServerlessRequest({
    method: request.method,
    headers: httpHeaders,
    body: request.body,
    remoteAddress: context.remoteAddress,
    url: context.url
  });
};

// http/framework/is-binary.ts
var BINARY_ENCODINGS = ["gzip", "deflate", "br"];
var BINARY_CONTENT_TYPES = (process.env.BINARY_CONTENT_TYPES || "").split(",");
function isBinaryEncoding(headers) {
  const contentEncoding = headers["content-encoding"];
  if (typeof contentEncoding === "string") {
    return contentEncoding.split(",").some((value) => BINARY_ENCODINGS.some((binaryEncoding) => value.indexOf(binaryEncoding) !== -1));
  }
}
function isBinaryContent(headers, options) {
  const contentTypes = [].concat(options?.binary && Array.isArray(options.binary) ? options.binary : BINARY_CONTENT_TYPES).map((candidate) => new RegExp(`^${candidate.replace(/\*/g, ".*")}$`));
  const contentType = (headers["content-type"] || "").split(";")[0];
  return !!contentType && contentTypes.some((candidate) => candidate.test(contentType));
}
function isBinary(headers, options) {
  if (options.binary === false) {
    return false;
  }
  if (options.binary === true) {
    return true;
  }
  if (typeof options.binary === "function") {
    return options.binary(headers);
  }
  return isBinaryEncoding(headers) || isBinaryContent(headers, options);
}

// http/framework/sanitize-headers.ts
function sanitizeHeaders(headers) {
  return Object.keys(headers).reduce(
    (memo, key) => {
      const value = headers[key];
      if (Array.isArray(value)) {
        memo.multiValueHeaders[key] = value;
        if (key.toLowerCase() !== "set-cookie") {
          memo.headers[key] = value.join(", ");
        }
      } else {
        memo.headers[key] = value == null ? "" : value.toString();
      }
      return memo;
    },
    {
      headers: {},
      multiValueHeaders: {}
    }
  );
}

// http/framework/format-response.ts
var format_response_default = (response, options) => {
  const { statusCode } = response;
  const { headers, multiValueHeaders } = sanitizeHeaders(ServerlessResponse.headers(response));
  let cookies = [];
  if (multiValueHeaders["set-cookie"]) {
    cookies = multiValueHeaders["set-cookie"];
  }
  const isBase64Encoded = isBinary(headers, options);
  const encoding = isBase64Encoded ? "base64" : "utf8";
  let body = ServerlessResponse.body(response).toString(encoding);
  if (headers["transfer-encoding"] === "chunked" || response.chunkedEncoding) {
    const raw = ServerlessResponse.body(response).toString().split("\r\n");
    const parsed = [];
    for (let i = 0; i < raw.length; i += 2) {
      const size = parseInt(raw[i], 16);
      const value = raw[i + 1];
      if (value) {
        parsed.push(value.substring(0, size));
      }
    }
    body = parsed.join("");
  }
  const formattedResponse = { statusCode, headers, isBase64Encoded, body, cookies };
  return formattedResponse;
};

// http/framework/aws.ts
var aws_default = (options = {
  requestId: "",
  basePath: void 0,
  binary: false
}) => {
  return (getResponse) => async (requestEvent, context) => {
    const request = create_request_default(requestEvent, context);
    const response = await getResponse(request, requestEvent, context);
    const formatted = format_response_default(response, options);
    const fetchResponse = new Response(formatted.body, {
      headers: formatted.headers,
      status: formatted.statusCode
    });
    return fetchResponse;
  };
};

// logging.ts
function applicationError(err, msg) {
  console.log(
    JSON.stringify({
      time: Date.now(),
      level: 50,
      msg,
      err: { message: err.message, stack: err.stack, code: err.code }
    }) + "\n"
  );
}

// http/index.ts
var Handler = class {
  prefix;
  handler;
  constructor(prefix, handler) {
    this.prefix = prefix;
    this.handler = handler;
  }
};
function normalize(path) {
  return path.replace(/^\/*([^\/]+)?\/*$/, "$1").replace(/\/+/g, "/");
}
var Http = class {
  loaders = [];
  listenerAdded = false;
  defaultNotFoundResponse = new Response("Not Found", { status: 404 });
  defaultErrorResponse = new Response("Internal Server Error", { status: 500 });
  use(prefixOrHandler, _handler) {
    const handler = _handler ? _handler : prefixOrHandler;
    const eventPrefix = _handler ? normalize(prefixOrHandler) : "";
    const handlerPrefix = `/${eventPrefix}`;
    this.loaders.push(new Handler(handlerPrefix, handler));
    this.addListener();
  }
  addListener() {
    if (this.listenerAdded) {
      return;
    }
    addEventListener("fetch", (event, eventContext) => {
      event.respondWith(this.handleEvent(event, eventContext));
    });
    this.listenerAdded = true;
  }
  useNodeHandler(handler) {
    this.use(this.nodeAdapter(handler));
  }
  async handleEvent(event, context) {
    const notFoundResponses = [];
    const url = new URL(event.request.url);
    try {
      for (const loader of this.loaders) {
        if (!url.pathname.startsWith(loader.prefix)) {
          continue;
        }
        const result = loader.handler(event.request, context);
        if (!result) {
          continue;
        }
        const response = await result;
        if (!response) {
          continue;
        }
        if (response.status !== 404) {
          return response;
        }
        notFoundResponses.push(response);
      }
      return notFoundResponses.shift() || this.defaultNotFoundResponse;
    } catch (err) {
      applicationError(err, "HTTP handler failed");
      return this.defaultErrorResponse;
    }
  }
  nodeAdapter(handler) {
    const options = {
      binary: void 0,
      requestId: "x-request-id",
      basePath: void 0
    };
    const framework = getFramework(handler);
    return aws_default(options)(async (request, ...context) => {
      await finish(request, ...context);
      const response = await framework(request);
      await finish(response, ...context);
      return response;
    });
  }
  on(eventName, relativePath) {
    if (eventName.toString() === "404") {
      this.defaultNotFoundResponse = new StreamingResponse(createReadableStream(relativePath), {
        status: 404,
        headers: {
          "Content-Type": "text/html",
          "Cache-Control": `max-age=0, s-maxage=31449600, must-revalidate`
        }
      });
    } else if (eventName.toString() === "500") {
      this.defaultErrorResponse = new StreamingResponse(createReadableStream(relativePath), {
        status: 500,
        headers: {
          "Content-Type": "text/html",
          "Cache-Control": `max-age=0, s-maxage=31449600, must-revalidate`
        }
      });
    } else {
      throw new Error(`Unsupported event name for http.on(): ${eventName}`);
    }
    this.addListener();
  }
};
var http4 = new Http();

export {
  normalize,
  Http,
  http4 as http
};
/*! Bundled license information:

aws4fetch/dist/aws4fetch.esm.mjs:
  (**
   * @license MIT <https://opensource.org/licenses/MIT>
   * @copyright Michael Hart 2022
   *)
*/
