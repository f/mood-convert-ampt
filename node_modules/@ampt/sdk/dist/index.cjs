"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb2, mod) => function __require() {
  return mod || (0, cb2[__getOwnPropNames(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// ../../node_modules/cron-validate/lib/result.js
var require_result = __commonJS({
  "../../node_modules/cron-validate/lib/result.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Err = exports.Valid = exports.err = exports.valid = void 0;
    var valid = (value) => new Valid(value);
    exports.valid = valid;
    var err = (error) => new Err(error);
    exports.err = err;
    var Valid = class {
      constructor(value) {
        this.value = value;
      }
      isValid() {
        return true;
      }
      isError() {
        return !this.isValid();
      }
      getValue() {
        return this.value;
      }
      getError() {
        throw new Error("Tried to get error from a valid.");
      }
      map(func) {
        return (0, exports.valid)(func(this.value));
      }
      mapErr(func) {
        return (0, exports.valid)(this.value);
      }
    };
    exports.Valid = Valid;
    var Err = class {
      constructor(error) {
        this.error = error;
      }
      isError() {
        return true;
      }
      isValid() {
        return !this.isError();
      }
      getValue() {
        throw new Error("Tried to get success value from an error.");
      }
      getError() {
        return this.error;
      }
      map(func) {
        return (0, exports.err)(this.error);
      }
      mapErr(func) {
        return (0, exports.err)(func(this.error));
      }
    };
    exports.Err = Err;
  }
});

// ../../node_modules/cron-validate/lib/types.js
var require_types = __commonJS({
  "../../node_modules/cron-validate/lib/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/cron-validate/lib/helper.js
var require_helper = __commonJS({
  "../../node_modules/cron-validate/lib/helper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require_lib();
    var result_1 = require_result();
    require_types();
    var monthAliases = [
      "jan",
      "feb",
      "mar",
      "apr",
      "may",
      "jun",
      "jul",
      "aug",
      "sep",
      "oct",
      "nov",
      "dec"
    ];
    var daysOfWeekAliases = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
    var checkWildcardLimit = (cronFieldType, options) => options[cronFieldType].lowerLimit === options.preset[cronFieldType].minValue && options[cronFieldType].upperLimit === options.preset[cronFieldType].maxValue;
    var checkSingleElementWithinLimits = (element, cronFieldType, options) => {
      if (cronFieldType === "months" && options.useAliases && monthAliases.indexOf(element.toLowerCase()) !== -1) {
        return (0, result_1.valid)(true);
      }
      if (cronFieldType === "daysOfWeek" && options.useAliases && daysOfWeekAliases.indexOf(element.toLowerCase()) !== -1) {
        return (0, result_1.valid)(true);
      }
      const number2 = Number(element);
      if (isNaN(number2)) {
        return (0, result_1.err)(`Element '${element} of ${cronFieldType} field is invalid.`);
      }
      const { lowerLimit } = options[cronFieldType];
      const { upperLimit } = options[cronFieldType];
      if (lowerLimit && number2 < lowerLimit) {
        return (0, result_1.err)(`Number ${number2} of ${cronFieldType} field is smaller than lower limit '${lowerLimit}'`);
      }
      if (upperLimit && number2 > upperLimit) {
        return (0, result_1.err)(`Number ${number2} of ${cronFieldType} field is bigger than upper limit '${upperLimit}'`);
      }
      return (0, result_1.valid)(true);
    };
    var checkSingleElement = (element, cronFieldType, options) => {
      if (element === "*") {
        if (!checkWildcardLimit(cronFieldType, options)) {
          return (0, result_1.err)(`Field ${cronFieldType} uses wildcard '*', but is limited to ${options[cronFieldType].lowerLimit}-${options[cronFieldType].upperLimit}`);
        }
        return (0, result_1.valid)(true);
      }
      if (element === "") {
        return (0, result_1.err)(`One of the elements is empty in ${cronFieldType} field.`);
      }
      if (cronFieldType === "daysOfMonth" && options.useLastDayOfMonth && element === "L") {
        return (0, result_1.valid)(true);
      }
      if (cronFieldType === "daysOfWeek" && options.useLastDayOfWeek && element.endsWith("L")) {
        const day = element.slice(0, -1);
        if (day === "") {
          return (0, result_1.valid)(true);
        }
        return checkSingleElementWithinLimits(day, cronFieldType, options);
      }
      if (cronFieldType === "daysOfMonth" && options.useNearestWeekday && element.endsWith("W")) {
        const day = element.slice(0, -1);
        if (day === "") {
          return (0, result_1.err)(`The 'W' must be preceded by a day`);
        }
        if (options.useLastDayOfMonth && day === "L") {
          return (0, result_1.valid)(true);
        }
        return checkSingleElementWithinLimits(day, cronFieldType, options);
      }
      if (cronFieldType === "daysOfWeek" && options.useNthWeekdayOfMonth && element.indexOf("#") !== -1) {
        const [day, occurrence, ...leftOvers] = element.split("#");
        if (leftOvers.length !== 0) {
          return (0, result_1.err)(`Unexpected number of '#' in ${element}, can only be used once.`);
        }
        const occurrenceNum = Number(occurrence);
        if (!occurrence || isNaN(occurrenceNum)) {
          return (0, result_1.err)(`Unexpected value following the '#' symbol, a positive number was expected but found ${occurrence}.`);
        }
        if (occurrenceNum > 5) {
          return (0, result_1.err)(`Number of occurrence of the day of the week cannot be greater than 5.`);
        }
        return checkSingleElementWithinLimits(day, cronFieldType, options);
      }
      return checkSingleElementWithinLimits(element, cronFieldType, options);
    };
    var checkRangeElement = (element, cronFieldType, options, position) => {
      if (element === "*") {
        return (0, result_1.err)(`'*' can't be part of a range in ${cronFieldType} field.`);
      }
      if (element === "") {
        return (0, result_1.err)(`One of the range elements is empty in ${cronFieldType} field.`);
      }
      if (options.useLastDayOfMonth && cronFieldType === "daysOfMonth" && element === "L" && position === 0) {
        return (0, result_1.valid)(true);
      }
      return checkSingleElementWithinLimits(element, cronFieldType, options);
    };
    var checkFirstStepElement = (firstStepElement, cronFieldType, options) => {
      const rangeArray = firstStepElement.split("-");
      if (rangeArray.length > 2) {
        return (0, result_1.err)(`List element '${firstStepElement}' is not valid. (More than one '-')`);
      }
      if (rangeArray.length === 1) {
        return checkSingleElement(rangeArray[0], cronFieldType, options);
      }
      if (rangeArray.length === 2) {
        const firstRangeElementResult = checkRangeElement(rangeArray[0], cronFieldType, options, 0);
        const secondRangeElementResult = checkRangeElement(rangeArray[1], cronFieldType, options, 1);
        if (firstRangeElementResult.isError()) {
          return firstRangeElementResult;
        }
        if (secondRangeElementResult.isError()) {
          return secondRangeElementResult;
        }
        if (Number(rangeArray[0]) > Number(rangeArray[1])) {
          return (0, result_1.err)(`Lower range end '${rangeArray[0]}' is bigger than upper range end '${rangeArray[1]}' of ${cronFieldType} field.`);
        }
        return (0, result_1.valid)(true);
      }
      return (0, result_1.err)("Some other error in checkFirstStepElement (rangeArray less than 1)");
    };
    var checkListElement = (listElement, cronFieldType, options) => {
      const stepArray = listElement.split("/");
      if (stepArray.length > 2) {
        return (0, result_1.err)(`List element '${listElement}' is not valid. (More than one '/')`);
      }
      const firstElementResult = checkFirstStepElement(stepArray[0], cronFieldType, options);
      if (firstElementResult.isError()) {
        return firstElementResult;
      }
      if (stepArray.length === 2) {
        const secondStepElement = stepArray[1];
        if (!secondStepElement) {
          return (0, result_1.err)(`Second step element '${secondStepElement}' of '${listElement}' is not valid (doesnt exist).`);
        }
        if (isNaN(Number(secondStepElement))) {
          return (0, result_1.err)(`Second step element '${secondStepElement}' of '${listElement}' is not valid (not a number).`);
        }
        if (Number(secondStepElement) === 0) {
          return (0, result_1.err)(`Second step element '${secondStepElement}' of '${listElement}' cannot be zero.`);
        }
      }
      return (0, result_1.valid)(true);
    };
    var checkField = (cronField, cronFieldType, options) => {
      if (![
        "seconds",
        "minutes",
        "hours",
        "daysOfMonth",
        "months",
        "daysOfWeek",
        "years"
      ].includes(cronFieldType)) {
        return (0, result_1.err)([`Cron field type '${cronFieldType}' does not exist.`]);
      }
      if (cronField === "?") {
        if (cronFieldType === "daysOfMonth" || cronFieldType === "daysOfWeek") {
          if (options.useBlankDay) {
            return (0, result_1.valid)(true);
          }
          return (0, result_1.err)([
            `useBlankDay is not enabled, but is used in ${cronFieldType} field`
          ]);
        }
        return (0, result_1.err)([`blank notation is not allowed in ${cronFieldType} field`]);
      }
      const listArray = cronField.split(",");
      const checkResults = [];
      listArray.forEach((listElement) => {
        checkResults.push(checkListElement(listElement, cronFieldType, options));
      });
      if (checkResults.every((value) => value.isValid())) {
        return (0, result_1.valid)(true);
      }
      const errorArray = [];
      checkResults.forEach((result) => {
        if (result.isError()) {
          errorArray.push(result.getError());
        }
      });
      return (0, result_1.err)(errorArray);
    };
    exports.default = checkField;
  }
});

// ../../node_modules/cron-validate/lib/fieldCheckers/secondChecker.js
var require_secondChecker = __commonJS({
  "../../node_modules/cron-validate/lib/fieldCheckers/secondChecker.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    require_lib();
    var result_1 = require_result();
    var helper_1 = __importDefault3(require_helper());
    require_types();
    var checkSeconds = (cronData, options) => {
      if (!cronData.seconds) {
        return (0, result_1.err)([
          "seconds field is undefined, but useSeconds options is enabled."
        ]);
      }
      const { seconds } = cronData;
      return (0, helper_1.default)(seconds, "seconds", options);
    };
    exports.default = checkSeconds;
  }
});

// ../../node_modules/cron-validate/lib/fieldCheckers/minuteChecker.js
var require_minuteChecker = __commonJS({
  "../../node_modules/cron-validate/lib/fieldCheckers/minuteChecker.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    require_lib();
    var result_1 = require_result();
    var helper_1 = __importDefault3(require_helper());
    require_types();
    var checkMinutes = (cronData, options) => {
      if (!cronData.minutes) {
        return (0, result_1.err)(["minutes field is undefined."]);
      }
      const { minutes } = cronData;
      return (0, helper_1.default)(minutes, "minutes", options);
    };
    exports.default = checkMinutes;
  }
});

// ../../node_modules/cron-validate/lib/fieldCheckers/hourChecker.js
var require_hourChecker = __commonJS({
  "../../node_modules/cron-validate/lib/fieldCheckers/hourChecker.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    require_lib();
    var result_1 = require_result();
    var helper_1 = __importDefault3(require_helper());
    require_types();
    var checkHours = (cronData, options) => {
      if (!cronData.hours) {
        return (0, result_1.err)(["hours field is undefined."]);
      }
      const { hours } = cronData;
      return (0, helper_1.default)(hours, "hours", options);
    };
    exports.default = checkHours;
  }
});

// ../../node_modules/cron-validate/lib/fieldCheckers/dayOfMonthChecker.js
var require_dayOfMonthChecker = __commonJS({
  "../../node_modules/cron-validate/lib/fieldCheckers/dayOfMonthChecker.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    require_lib();
    var result_1 = require_result();
    var helper_1 = __importDefault3(require_helper());
    require_types();
    var checkDaysOfMonth = (cronData, options) => {
      if (!cronData.daysOfMonth) {
        return (0, result_1.err)(["daysOfMonth field is undefined."]);
      }
      const { daysOfMonth } = cronData;
      if (options.allowOnlyOneBlankDayField && options.useBlankDay && cronData.daysOfMonth === "?" && cronData.daysOfWeek === "?") {
        return (0, result_1.err)([
          `Cannot use blank value in daysOfMonth and daysOfWeek field when allowOnlyOneBlankDayField option is enabled.`
        ]);
      }
      if (options.mustHaveBlankDayField && cronData.daysOfMonth !== "?" && cronData.daysOfWeek !== "?") {
        return (0, result_1.err)([
          `Cannot specify both daysOfMonth and daysOfWeek field when mustHaveBlankDayField option is enabled.`
        ]);
      }
      if (options.useLastDayOfMonth && cronData.daysOfMonth.indexOf("L") !== -1 && cronData.daysOfMonth.match(/[,/]/)) {
        return (0, result_1.err)([
          `Cannot specify last day of month with lists, or ranges (symbols ,/).`
        ]);
      }
      if (options.useNearestWeekday && cronData.daysOfMonth.indexOf("W") !== -1 && cronData.daysOfMonth.match(/[,/-]/)) {
        return (0, result_1.err)([
          `Cannot specify nearest weekday with lists, steps or ranges (symbols ,-/).`
        ]);
      }
      return (0, helper_1.default)(daysOfMonth, "daysOfMonth", options);
    };
    exports.default = checkDaysOfMonth;
  }
});

// ../../node_modules/cron-validate/lib/fieldCheckers/monthChecker.js
var require_monthChecker = __commonJS({
  "../../node_modules/cron-validate/lib/fieldCheckers/monthChecker.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    require_lib();
    var result_1 = require_result();
    var helper_1 = __importDefault3(require_helper());
    require_types();
    var checkMonths = (cronData, options) => {
      if (!cronData.months) {
        return (0, result_1.err)(["months field is undefined."]);
      }
      const { months } = cronData;
      return (0, helper_1.default)(months, "months", options);
    };
    exports.default = checkMonths;
  }
});

// ../../node_modules/cron-validate/lib/fieldCheckers/dayOfWeekChecker.js
var require_dayOfWeekChecker = __commonJS({
  "../../node_modules/cron-validate/lib/fieldCheckers/dayOfWeekChecker.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    require_lib();
    var result_1 = require_result();
    var helper_1 = __importDefault3(require_helper());
    require_types();
    var checkDaysOfWeek = (cronData, options) => {
      if (!cronData.daysOfWeek) {
        return (0, result_1.err)(["daysOfWeek field is undefined."]);
      }
      const { daysOfWeek } = cronData;
      if (options.allowOnlyOneBlankDayField && cronData.daysOfMonth === "?" && cronData.daysOfWeek === "?") {
        return (0, result_1.err)([
          `Cannot use blank value in daysOfMonth and daysOfWeek field when allowOnlyOneBlankDayField option is enabled.`
        ]);
      }
      if (options.mustHaveBlankDayField && cronData.daysOfMonth !== "?" && cronData.daysOfWeek !== "?") {
        return (0, result_1.err)([
          `Cannot specify both daysOfMonth and daysOfWeek field when mustHaveBlankDayField option is enabled.`
        ]);
      }
      if (options.useLastDayOfWeek && cronData.daysOfWeek.indexOf("L") !== -1 && cronData.daysOfWeek.match(/[,/-]/)) {
        return (0, result_1.err)([
          `Cannot specify last day of week with lists, steps or ranges (symbols ,-/).`
        ]);
      }
      if (options.useNthWeekdayOfMonth && cronData.daysOfWeek.indexOf("#") !== -1 && cronData.daysOfWeek.match(/[,/-]/)) {
        return (0, result_1.err)([
          `Cannot specify Nth weekday of month with lists, steps or ranges (symbols ,-/).`
        ]);
      }
      return (0, helper_1.default)(daysOfWeek, "daysOfWeek", options);
    };
    exports.default = checkDaysOfWeek;
  }
});

// ../../node_modules/cron-validate/lib/fieldCheckers/yearChecker.js
var require_yearChecker = __commonJS({
  "../../node_modules/cron-validate/lib/fieldCheckers/yearChecker.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    require_lib();
    var result_1 = require_result();
    var helper_1 = __importDefault3(require_helper());
    require_types();
    var checkYears = (cronData, options) => {
      if (!cronData.years) {
        return (0, result_1.err)(["years field is undefined, but useYears option is enabled."]);
      }
      const { years } = cronData;
      return (0, helper_1.default)(years, "years", options);
    };
    exports.default = checkYears;
  }
});

// ../../node_modules/nanoclone/src/index.js
function baseClone(src, circulars, clones) {
  if (!src || typeof src !== "object" || typeof src === "function") {
    return src;
  }
  if (src.nodeType && "cloneNode" in src) {
    return src.cloneNode(true);
  }
  if (src instanceof Date) {
    return new Date(src.getTime());
  }
  if (src instanceof RegExp) {
    return new RegExp(src);
  }
  if (Array.isArray(src)) {
    return src.map(clone);
  }
  if (map && src instanceof map) {
    return new Map(Array.from(src.entries()));
  }
  if (set && src instanceof set) {
    return new Set(Array.from(src.values()));
  }
  if (src instanceof Object) {
    circulars.push(src);
    var obj = Object.create(src);
    clones.push(obj);
    for (var key in src) {
      var idx = circulars.findIndex(function(i10) {
        return i10 === src[key];
      });
      obj[key] = idx > -1 ? clones[idx] : baseClone(src[key], circulars, clones);
    }
    return obj;
  }
  return src;
}
function clone(src) {
  return baseClone(src, [], []);
}
var map, set;
var init_src = __esm({
  "../../node_modules/nanoclone/src/index.js"() {
    try {
      map = Map;
    } catch (_) {
    }
    try {
      set = Set;
    } catch (_) {
    }
  }
});

// ../../node_modules/yup/es/util/printValue.js
function printNumber(val) {
  if (val != +val)
    return "NaN";
  const isNegativeZero = val === 0 && 1 / val < 0;
  return isNegativeZero ? "-0" : "" + val;
}
function printSimpleValue(val, quoteStrings = false) {
  if (val == null || val === true || val === false)
    return "" + val;
  const typeOf = typeof val;
  if (typeOf === "number")
    return printNumber(val);
  if (typeOf === "string")
    return quoteStrings ? `"${val}"` : val;
  if (typeOf === "function")
    return "[Function " + (val.name || "anonymous") + "]";
  if (typeOf === "symbol")
    return symbolToString.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
  const tag = toString.call(val).slice(8, -1);
  if (tag === "Date")
    return isNaN(val.getTime()) ? "" + val : val.toISOString(val);
  if (tag === "Error" || val instanceof Error)
    return "[" + errorToString.call(val) + "]";
  if (tag === "RegExp")
    return regExpToString.call(val);
  return null;
}
function printValue(value, quoteStrings) {
  let result = printSimpleValue(value, quoteStrings);
  if (result !== null)
    return result;
  return JSON.stringify(value, function(key, value2) {
    let result2 = printSimpleValue(this[key], quoteStrings);
    if (result2 !== null)
      return result2;
    return value2;
  }, 2);
}
var toString, errorToString, regExpToString, symbolToString, SYMBOL_REGEXP;
var init_printValue = __esm({
  "../../node_modules/yup/es/util/printValue.js"() {
    toString = Object.prototype.toString;
    errorToString = Error.prototype.toString;
    regExpToString = RegExp.prototype.toString;
    symbolToString = typeof Symbol !== "undefined" ? Symbol.prototype.toString : () => "";
    SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
  }
});

// ../../node_modules/yup/es/locale.js
var mixed, string, number, date, boolean, object, array, locale_default;
var init_locale = __esm({
  "../../node_modules/yup/es/locale.js"() {
    init_printValue();
    mixed = {
      default: "${path} is invalid",
      required: "${path} is a required field",
      oneOf: "${path} must be one of the following values: ${values}",
      notOneOf: "${path} must not be one of the following values: ${values}",
      notType: ({
        path,
        type,
        value,
        originalValue
      }) => {
        let isCast = originalValue != null && originalValue !== value;
        let msg = `${path} must be a \`${type}\` type, but the final value was: \`${printValue(value, true)}\`` + (isCast ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : ".");
        if (value === null) {
          msg += `
 If "null" is intended as an empty value be sure to mark the schema as \`.nullable()\``;
        }
        return msg;
      },
      defined: "${path} must be defined"
    };
    string = {
      length: "${path} must be exactly ${length} characters",
      min: "${path} must be at least ${min} characters",
      max: "${path} must be at most ${max} characters",
      matches: '${path} must match the following: "${regex}"',
      email: "${path} must be a valid email",
      url: "${path} must be a valid URL",
      uuid: "${path} must be a valid UUID",
      trim: "${path} must be a trimmed string",
      lowercase: "${path} must be a lowercase string",
      uppercase: "${path} must be a upper case string"
    };
    number = {
      min: "${path} must be greater than or equal to ${min}",
      max: "${path} must be less than or equal to ${max}",
      lessThan: "${path} must be less than ${less}",
      moreThan: "${path} must be greater than ${more}",
      positive: "${path} must be a positive number",
      negative: "${path} must be a negative number",
      integer: "${path} must be an integer"
    };
    date = {
      min: "${path} field must be later than ${min}",
      max: "${path} field must be at earlier than ${max}"
    };
    boolean = {
      isValue: "${path} field must be ${value}"
    };
    object = {
      noUnknown: "${path} field has unspecified keys: ${unknown}"
    };
    array = {
      min: "${path} field must have at least ${min} items",
      max: "${path} field must have less than or equal to ${max} items",
      length: "${path} must be have ${length} items"
    };
    locale_default = Object.assign(/* @__PURE__ */ Object.create(null), {
      mixed,
      string,
      number,
      date,
      object,
      array,
      boolean
    });
  }
});

// ../../node_modules/lodash/_baseHas.js
var require_baseHas = __commonJS({
  "../../node_modules/lodash/_baseHas.js"(exports, module2) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseHas(object2, key) {
      return object2 != null && hasOwnProperty.call(object2, key);
    }
    module2.exports = baseHas;
  }
});

// ../../node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "../../node_modules/lodash/isArray.js"(exports, module2) {
    var isArray = Array.isArray;
    module2.exports = isArray;
  }
});

// ../../node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "../../node_modules/lodash/_freeGlobal.js"(exports, module2) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal;
  }
});

// ../../node_modules/lodash/_root.js
var require_root = __commonJS({
  "../../node_modules/lodash/_root.js"(exports, module2) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  }
});

// ../../node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "../../node_modules/lodash/_Symbol.js"(exports, module2) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module2.exports = Symbol2;
  }
});

// ../../node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "../../node_modules/lodash/_getRawTag.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e10) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  }
});

// ../../node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "../../node_modules/lodash/_objectToString.js"(exports, module2) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// ../../node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "../../node_modules/lodash/_baseGetTag.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// ../../node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "../../node_modules/lodash/isObjectLike.js"(exports, module2) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// ../../node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "../../node_modules/lodash/isSymbol.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module2.exports = isSymbol;
  }
});

// ../../node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "../../node_modules/lodash/_isKey.js"(exports, module2) {
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object2) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
    }
    module2.exports = isKey;
  }
});

// ../../node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "../../node_modules/lodash/isObject.js"(exports, module2) {
    function isObject3(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isObject3;
  }
});

// ../../node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "../../node_modules/lodash/isFunction.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var isObject3 = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction2(value) {
      if (!isObject3(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module2.exports = isFunction2;
  }
});

// ../../node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "../../node_modules/lodash/_coreJsData.js"(exports, module2) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module2.exports = coreJsData;
  }
});

// ../../node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "../../node_modules/lodash/_isMasked.js"(exports, module2) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module2.exports = isMasked;
  }
});

// ../../node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "../../node_modules/lodash/_toSource.js"(exports, module2) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e10) {
        }
        try {
          return func + "";
        } catch (e10) {
        }
      }
      return "";
    }
    module2.exports = toSource;
  }
});

// ../../node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "../../node_modules/lodash/_baseIsNative.js"(exports, module2) {
    var isFunction2 = require_isFunction();
    var isMasked = require_isMasked();
    var isObject3 = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject3(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module2.exports = baseIsNative;
  }
});

// ../../node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "../../node_modules/lodash/_getValue.js"(exports, module2) {
    function getValue(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    module2.exports = getValue;
  }
});

// ../../node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "../../node_modules/lodash/_getNative.js"(exports, module2) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object2, key) {
      var value = getValue(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    module2.exports = getNative;
  }
});

// ../../node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "../../node_modules/lodash/_nativeCreate.js"(exports, module2) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module2.exports = nativeCreate;
  }
});

// ../../node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "../../node_modules/lodash/_hashClear.js"(exports, module2) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module2.exports = hashClear;
  }
});

// ../../node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "../../node_modules/lodash/_hashDelete.js"(exports, module2) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = hashDelete;
  }
});

// ../../node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "../../node_modules/lodash/_hashGet.js"(exports, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module2.exports = hashGet;
  }
});

// ../../node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "../../node_modules/lodash/_hashHas.js"(exports, module2) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module2.exports = hashHas;
  }
});

// ../../node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "../../node_modules/lodash/_hashSet.js"(exports, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module2.exports = hashSet;
  }
});

// ../../node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "../../node_modules/lodash/_Hash.js"(exports, module2) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash2(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash2.prototype.clear = hashClear;
    Hash2.prototype["delete"] = hashDelete;
    Hash2.prototype.get = hashGet;
    Hash2.prototype.has = hashHas;
    Hash2.prototype.set = hashSet;
    module2.exports = Hash2;
  }
});

// ../../node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "../../node_modules/lodash/_listCacheClear.js"(exports, module2) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module2.exports = listCacheClear;
  }
});

// ../../node_modules/lodash/eq.js
var require_eq = __commonJS({
  "../../node_modules/lodash/eq.js"(exports, module2) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = eq;
  }
});

// ../../node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "../../node_modules/lodash/_assocIndexOf.js"(exports, module2) {
    var eq = require_eq();
    function assocIndexOf(array2, key) {
      var length = array2.length;
      while (length--) {
        if (eq(array2[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module2.exports = assocIndexOf;
  }
});

// ../../node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "../../node_modules/lodash/_listCacheDelete.js"(exports, module2) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module2.exports = listCacheDelete;
  }
});

// ../../node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "../../node_modules/lodash/_listCacheGet.js"(exports, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module2.exports = listCacheGet;
  }
});

// ../../node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "../../node_modules/lodash/_listCacheHas.js"(exports, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module2.exports = listCacheHas;
  }
});

// ../../node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "../../node_modules/lodash/_listCacheSet.js"(exports, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module2.exports = listCacheSet;
  }
});

// ../../node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "../../node_modules/lodash/_ListCache.js"(exports, module2) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module2.exports = ListCache;
  }
});

// ../../node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "../../node_modules/lodash/_Map.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module2.exports = Map2;
  }
});

// ../../node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "../../node_modules/lodash/_mapCacheClear.js"(exports, module2) {
    var Hash2 = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash2(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash2()
      };
    }
    module2.exports = mapCacheClear;
  }
});

// ../../node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "../../node_modules/lodash/_isKeyable.js"(exports, module2) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module2.exports = isKeyable;
  }
});

// ../../node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "../../node_modules/lodash/_getMapData.js"(exports, module2) {
    var isKeyable = require_isKeyable();
    function getMapData(map9, key) {
      var data = map9.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module2.exports = getMapData;
  }
});

// ../../node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "../../node_modules/lodash/_mapCacheDelete.js"(exports, module2) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = mapCacheDelete;
  }
});

// ../../node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "../../node_modules/lodash/_mapCacheGet.js"(exports, module2) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module2.exports = mapCacheGet;
  }
});

// ../../node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "../../node_modules/lodash/_mapCacheHas.js"(exports, module2) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module2.exports = mapCacheHas;
  }
});

// ../../node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "../../node_modules/lodash/_mapCacheSet.js"(exports, module2) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module2.exports = mapCacheSet;
  }
});

// ../../node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "../../node_modules/lodash/_MapCache.js"(exports, module2) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module2.exports = MapCache;
  }
});

// ../../node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "../../node_modules/lodash/memoize.js"(exports, module2) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize2(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize2.Cache || MapCache)();
      return memoized;
    }
    memoize2.Cache = MapCache;
    module2.exports = memoize2;
  }
});

// ../../node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "../../node_modules/lodash/_memoizeCapped.js"(exports, module2) {
    var memoize2 = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize2(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    module2.exports = memoizeCapped;
  }
});

// ../../node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "../../node_modules/lodash/_stringToPath.js"(exports, module2) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName, function(match, number2, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
      });
      return result;
    });
    module2.exports = stringToPath;
  }
});

// ../../node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "../../node_modules/lodash/_arrayMap.js"(exports, module2) {
    function arrayMap(array2, iteratee) {
      var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array2[index], index, array2);
      }
      return result;
    }
    module2.exports = arrayMap;
  }
});

// ../../node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "../../node_modules/lodash/_baseToString.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString2 = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString2 ? symbolToString2.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = baseToString;
  }
});

// ../../node_modules/lodash/toString.js
var require_toString = __commonJS({
  "../../node_modules/lodash/toString.js"(exports, module2) {
    var baseToString = require_baseToString();
    function toString2(value) {
      return value == null ? "" : baseToString(value);
    }
    module2.exports = toString2;
  }
});

// ../../node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "../../node_modules/lodash/_castPath.js"(exports, module2) {
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString2 = require_toString();
    function castPath(value, object2) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object2) ? [value] : stringToPath(toString2(value));
    }
    module2.exports = castPath;
  }
});

// ../../node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "../../node_modules/lodash/_baseIsArguments.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module2.exports = baseIsArguments;
  }
});

// ../../node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "../../node_modules/lodash/isArguments.js"(exports, module2) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module2.exports = isArguments;
  }
});

// ../../node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "../../node_modules/lodash/_isIndex.js"(exports, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module2.exports = isIndex;
  }
});

// ../../node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "../../node_modules/lodash/isLength.js"(exports, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module2.exports = isLength;
  }
});

// ../../node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "../../node_modules/lodash/_toKey.js"(exports, module2) {
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = toKey;
  }
});

// ../../node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "../../node_modules/lodash/_hasPath.js"(exports, module2) {
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath(object2, path, hasFunc) {
      path = castPath(path, object2);
      var index = -1, length = path.length, result = false;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object2 != null && hasFunc(object2, key))) {
          break;
        }
        object2 = object2[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object2 == null ? 0 : object2.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object2) || isArguments(object2));
    }
    module2.exports = hasPath;
  }
});

// ../../node_modules/lodash/has.js
var require_has = __commonJS({
  "../../node_modules/lodash/has.js"(exports, module2) {
    var baseHas = require_baseHas();
    var hasPath = require_hasPath();
    function has4(object2, path) {
      return object2 != null && hasPath(object2, path, baseHas);
    }
    module2.exports = has4;
  }
});

// ../../node_modules/yup/es/util/isSchema.js
var isSchema_default;
var init_isSchema = __esm({
  "../../node_modules/yup/es/util/isSchema.js"() {
    isSchema_default = (obj) => obj && obj.__isYupSchema__;
  }
});

// ../../node_modules/yup/es/Condition.js
var import_has, Condition, Condition_default;
var init_Condition = __esm({
  "../../node_modules/yup/es/Condition.js"() {
    import_has = __toESM(require_has());
    init_isSchema();
    Condition = class {
      constructor(refs, options) {
        this.refs = refs;
        this.refs = refs;
        if (typeof options === "function") {
          this.fn = options;
          return;
        }
        if (!(0, import_has.default)(options, "is"))
          throw new TypeError("`is:` is required for `when()` conditions");
        if (!options.then && !options.otherwise)
          throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
        let {
          is,
          then,
          otherwise
        } = options;
        let check = typeof is === "function" ? is : (...values) => values.every((value) => value === is);
        this.fn = function(...args) {
          let options2 = args.pop();
          let schema = args.pop();
          let branch = check(...args) ? then : otherwise;
          if (!branch)
            return void 0;
          if (typeof branch === "function")
            return branch(schema);
          return schema.concat(branch.resolve(options2));
        };
      }
      resolve(base, options) {
        let values = this.refs.map((ref) => ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context));
        let schema = this.fn.apply(base, values.concat(base, options));
        if (schema === void 0 || schema === base)
          return base;
        if (!isSchema_default(schema))
          throw new TypeError("conditions must return a schema object");
        return schema.resolve(options);
      }
    };
    Condition_default = Condition;
  }
});

// ../../node_modules/yup/es/util/toArray.js
function toArray(value) {
  return value == null ? [] : [].concat(value);
}
var init_toArray = __esm({
  "../../node_modules/yup/es/util/toArray.js"() {
  }
});

// ../../node_modules/yup/es/ValidationError.js
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i10 = 1; i10 < arguments.length; i10++) {
      var source = arguments[i10];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var strReg, ValidationError;
var init_ValidationError = __esm({
  "../../node_modules/yup/es/ValidationError.js"() {
    init_printValue();
    init_toArray();
    strReg = /\$\{\s*(\w+)\s*\}/g;
    ValidationError = class extends Error {
      static formatError(message, params2) {
        const path = params2.label || params2.path || "this";
        if (path !== params2.path)
          params2 = _extends({}, params2, {
            path
          });
        if (typeof message === "string")
          return message.replace(strReg, (_, key) => printValue(params2[key]));
        if (typeof message === "function")
          return message(params2);
        return message;
      }
      static isError(err) {
        return err && err.name === "ValidationError";
      }
      constructor(errorOrErrors, value, field, type) {
        super();
        this.name = "ValidationError";
        this.value = value;
        this.path = field;
        this.type = type;
        this.errors = [];
        this.inner = [];
        toArray(errorOrErrors).forEach((err) => {
          if (ValidationError.isError(err)) {
            this.errors.push(...err.errors);
            this.inner = this.inner.concat(err.inner.length ? err.inner : err);
          } else {
            this.errors.push(err);
          }
        });
        this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, ValidationError);
      }
    };
  }
});

// ../../node_modules/yup/es/util/runTests.js
function runTests(options, cb2) {
  let {
    endEarly,
    tests,
    args,
    value,
    errors,
    sort,
    path
  } = options;
  let callback = once(cb2);
  let count2 = tests.length;
  const nestedErrors = [];
  errors = errors ? errors : [];
  if (!count2)
    return errors.length ? callback(new ValidationError(errors, value, path)) : callback(null, value);
  for (let i10 = 0; i10 < tests.length; i10++) {
    const test = tests[i10];
    test(args, function finishTestRun(err) {
      if (err) {
        if (!ValidationError.isError(err)) {
          return callback(err, value);
        }
        if (endEarly) {
          err.value = value;
          return callback(err, value);
        }
        nestedErrors.push(err);
      }
      if (--count2 <= 0) {
        if (nestedErrors.length) {
          if (sort)
            nestedErrors.sort(sort);
          if (errors.length)
            nestedErrors.push(...errors);
          errors = nestedErrors;
        }
        if (errors.length) {
          callback(new ValidationError(errors, value, path), value);
          return;
        }
        callback(null, value);
      }
    });
  }
}
var once;
var init_runTests = __esm({
  "../../node_modules/yup/es/util/runTests.js"() {
    init_ValidationError();
    once = (cb2) => {
      let fired = false;
      return (...args) => {
        if (fired)
          return;
        fired = true;
        cb2(...args);
      };
    };
  }
});

// ../../node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "../../node_modules/lodash/_defineProperty.js"(exports, module2) {
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e10) {
      }
    }();
    module2.exports = defineProperty;
  }
});

// ../../node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "../../node_modules/lodash/_baseAssignValue.js"(exports, module2) {
    var defineProperty = require_defineProperty();
    function baseAssignValue(object2, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object2, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object2[key] = value;
      }
    }
    module2.exports = baseAssignValue;
  }
});

// ../../node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "../../node_modules/lodash/_createBaseFor.js"(exports, module2) {
    function createBaseFor(fromRight) {
      return function(object2, iteratee, keysFunc) {
        var index = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object2;
      };
    }
    module2.exports = createBaseFor;
  }
});

// ../../node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "../../node_modules/lodash/_baseFor.js"(exports, module2) {
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module2.exports = baseFor;
  }
});

// ../../node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "../../node_modules/lodash/_baseTimes.js"(exports, module2) {
    function baseTimes(n10, iteratee) {
      var index = -1, result = Array(n10);
      while (++index < n10) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module2.exports = baseTimes;
  }
});

// ../../node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "../../node_modules/lodash/stubFalse.js"(exports, module2) {
    function stubFalse() {
      return false;
    }
    module2.exports = stubFalse;
  }
});

// ../../node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "../../node_modules/lodash/isBuffer.js"(exports, module2) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer5 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer5 ? Buffer5.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer;
  }
});

// ../../node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "../../node_modules/lodash/_baseIsTypedArray.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module2.exports = baseIsTypedArray;
  }
});

// ../../node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "../../node_modules/lodash/_baseUnary.js"(exports, module2) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module2.exports = baseUnary;
  }
});

// ../../node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "../../node_modules/lodash/_nodeUtil.js"(exports, module2) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e10) {
      }
    }();
    module2.exports = nodeUtil;
  }
});

// ../../node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "../../node_modules/lodash/isTypedArray.js"(exports, module2) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module2.exports = isTypedArray;
  }
});

// ../../node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "../../node_modules/lodash/_arrayLikeKeys.js"(exports, module2) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = arrayLikeKeys;
  }
});

// ../../node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "../../node_modules/lodash/_isPrototype.js"(exports, module2) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module2.exports = isPrototype;
  }
});

// ../../node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "../../node_modules/lodash/_overArg.js"(exports, module2) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module2.exports = overArg;
  }
});

// ../../node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "../../node_modules/lodash/_nativeKeys.js"(exports, module2) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module2.exports = nativeKeys;
  }
});

// ../../node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "../../node_modules/lodash/_baseKeys.js"(exports, module2) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeys;
  }
});

// ../../node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "../../node_modules/lodash/isArrayLike.js"(exports, module2) {
    var isFunction2 = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    module2.exports = isArrayLike;
  }
});

// ../../node_modules/lodash/keys.js
var require_keys = __commonJS({
  "../../node_modules/lodash/keys.js"(exports, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    module2.exports = keys;
  }
});

// ../../node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "../../node_modules/lodash/_baseForOwn.js"(exports, module2) {
    var baseFor = require_baseFor();
    var keys = require_keys();
    function baseForOwn(object2, iteratee) {
      return object2 && baseFor(object2, iteratee, keys);
    }
    module2.exports = baseForOwn;
  }
});

// ../../node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "../../node_modules/lodash/_stackClear.js"(exports, module2) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module2.exports = stackClear;
  }
});

// ../../node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "../../node_modules/lodash/_stackDelete.js"(exports, module2) {
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    module2.exports = stackDelete;
  }
});

// ../../node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "../../node_modules/lodash/_stackGet.js"(exports, module2) {
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module2.exports = stackGet;
  }
});

// ../../node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "../../node_modules/lodash/_stackHas.js"(exports, module2) {
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module2.exports = stackHas;
  }
});

// ../../node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "../../node_modules/lodash/_stackSet.js"(exports, module2) {
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    module2.exports = stackSet;
  }
});

// ../../node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "../../node_modules/lodash/_Stack.js"(exports, module2) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module2.exports = Stack;
  }
});

// ../../node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "../../node_modules/lodash/_setCacheAdd.js"(exports, module2) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module2.exports = setCacheAdd;
  }
});

// ../../node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "../../node_modules/lodash/_setCacheHas.js"(exports, module2) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module2.exports = setCacheHas;
  }
});

// ../../node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "../../node_modules/lodash/_SetCache.js"(exports, module2) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module2.exports = SetCache;
  }
});

// ../../node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "../../node_modules/lodash/_arraySome.js"(exports, module2) {
    function arraySome(array2, predicate) {
      var index = -1, length = array2 == null ? 0 : array2.length;
      while (++index < length) {
        if (predicate(array2[index], index, array2)) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arraySome;
  }
});

// ../../node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "../../node_modules/lodash/_cacheHas.js"(exports, module2) {
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    module2.exports = cacheHas;
  }
});

// ../../node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "../../node_modules/lodash/_equalArrays.js"(exports, module2) {
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array2);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array2;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array2, other);
      stack.set(other, array2);
      while (++index < arrLength) {
        var arrValue = array2[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array2);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalArrays;
  }
});

// ../../node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "../../node_modules/lodash/_Uint8Array.js"(exports, module2) {
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module2.exports = Uint8Array2;
  }
});

// ../../node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "../../node_modules/lodash/_mapToArray.js"(exports, module2) {
    function mapToArray(map9) {
      var index = -1, result = Array(map9.size);
      map9.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    module2.exports = mapToArray;
  }
});

// ../../node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "../../node_modules/lodash/_setToArray.js"(exports, module2) {
    function setToArray(set4) {
      var index = -1, result = Array(set4.size);
      set4.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    module2.exports = setToArray;
  }
});

// ../../node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "../../node_modules/lodash/_equalByTag.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var Uint8Array2 = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object2, +other);
        case errorTag:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag:
          return object2 == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object2, other);
          var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object2);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module2.exports = equalByTag;
  }
});

// ../../node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "../../node_modules/lodash/_arrayPush.js"(exports, module2) {
    function arrayPush(array2, values) {
      var index = -1, length = values.length, offset = array2.length;
      while (++index < length) {
        array2[offset + index] = values[index];
      }
      return array2;
    }
    module2.exports = arrayPush;
  }
});

// ../../node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "../../node_modules/lodash/_baseGetAllKeys.js"(exports, module2) {
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray(object2) ? result : arrayPush(result, symbolsFunc(object2));
    }
    module2.exports = baseGetAllKeys;
  }
});

// ../../node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "../../node_modules/lodash/_arrayFilter.js"(exports, module2) {
    function arrayFilter(array2, predicate) {
      var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array2[index];
        if (predicate(value, index, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = arrayFilter;
  }
});

// ../../node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "../../node_modules/lodash/stubArray.js"(exports, module2) {
    function stubArray() {
      return [];
    }
    module2.exports = stubArray;
  }
});

// ../../node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "../../node_modules/lodash/_getSymbols.js"(exports, module2) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    module2.exports = getSymbols;
  }
});

// ../../node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "../../node_modules/lodash/_getAllKeys.js"(exports, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object2) {
      return baseGetAllKeys(object2, keys, getSymbols);
    }
    module2.exports = getAllKeys;
  }
});

// ../../node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "../../node_modules/lodash/_equalObjects.js"(exports, module2) {
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object2);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object2;
      }
      var result = true;
      stack.set(object2, other);
      stack.set(other, object2);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object2);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalObjects;
  }
});

// ../../node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "../../node_modules/lodash/_DataView.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView2 = getNative(root, "DataView");
    module2.exports = DataView2;
  }
});

// ../../node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "../../node_modules/lodash/_Promise.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module2.exports = Promise2;
  }
});

// ../../node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "../../node_modules/lodash/_Set.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module2.exports = Set2;
  }
});

// ../../node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "../../node_modules/lodash/_WeakMap.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap = getNative(root, "WeakMap");
    module2.exports = WeakMap;
  }
});

// ../../node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "../../node_modules/lodash/_getTag.js"(exports, module2) {
    var DataView2 = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module2.exports = getTag;
  }
});

// ../../node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "../../node_modules/lodash/_baseIsEqualDeep.js"(exports, module2) {
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object2)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
    }
    module2.exports = baseIsEqualDeep;
  }
});

// ../../node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "../../node_modules/lodash/_baseIsEqual.js"(exports, module2) {
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    module2.exports = baseIsEqual;
  }
});

// ../../node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "../../node_modules/lodash/_baseIsMatch.js"(exports, module2) {
    var Stack = require_Stack();
    var baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object2, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object2 == null) {
        return !length;
      }
      object2 = Object(object2);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object2[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object2)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object2, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    module2.exports = baseIsMatch;
  }
});

// ../../node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "../../node_modules/lodash/_isStrictComparable.js"(exports, module2) {
    var isObject3 = require_isObject();
    function isStrictComparable(value) {
      return value === value && !isObject3(value);
    }
    module2.exports = isStrictComparable;
  }
});

// ../../node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "../../node_modules/lodash/_getMatchData.js"(exports, module2) {
    var isStrictComparable = require_isStrictComparable();
    var keys = require_keys();
    function getMatchData(object2) {
      var result = keys(object2), length = result.length;
      while (length--) {
        var key = result[length], value = object2[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    module2.exports = getMatchData;
  }
});

// ../../node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "../../node_modules/lodash/_matchesStrictComparable.js"(exports, module2) {
    function matchesStrictComparable(key, srcValue) {
      return function(object2) {
        if (object2 == null) {
          return false;
        }
        return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
      };
    }
    module2.exports = matchesStrictComparable;
  }
});

// ../../node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "../../node_modules/lodash/_baseMatches.js"(exports, module2) {
    var baseIsMatch = require_baseIsMatch();
    var getMatchData = require_getMatchData();
    var matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object2) {
        return object2 === source || baseIsMatch(object2, source, matchData);
      };
    }
    module2.exports = baseMatches;
  }
});

// ../../node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "../../node_modules/lodash/_baseGet.js"(exports, module2) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object2, path) {
      path = castPath(path, object2);
      var index = 0, length = path.length;
      while (object2 != null && index < length) {
        object2 = object2[toKey(path[index++])];
      }
      return index && index == length ? object2 : void 0;
    }
    module2.exports = baseGet;
  }
});

// ../../node_modules/lodash/get.js
var require_get = __commonJS({
  "../../node_modules/lodash/get.js"(exports, module2) {
    var baseGet = require_baseGet();
    function get3(object2, path, defaultValue) {
      var result = object2 == null ? void 0 : baseGet(object2, path);
      return result === void 0 ? defaultValue : result;
    }
    module2.exports = get3;
  }
});

// ../../node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "../../node_modules/lodash/_baseHasIn.js"(exports, module2) {
    function baseHasIn(object2, key) {
      return object2 != null && key in Object(object2);
    }
    module2.exports = baseHasIn;
  }
});

// ../../node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "../../node_modules/lodash/hasIn.js"(exports, module2) {
    var baseHasIn = require_baseHasIn();
    var hasPath = require_hasPath();
    function hasIn(object2, path) {
      return object2 != null && hasPath(object2, path, baseHasIn);
    }
    module2.exports = hasIn;
  }
});

// ../../node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "../../node_modules/lodash/_baseMatchesProperty.js"(exports, module2) {
    var baseIsEqual = require_baseIsEqual();
    var get3 = require_get();
    var hasIn = require_hasIn();
    var isKey = require_isKey();
    var isStrictComparable = require_isStrictComparable();
    var matchesStrictComparable = require_matchesStrictComparable();
    var toKey = require_toKey();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object2) {
        var objValue = get3(object2, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    module2.exports = baseMatchesProperty;
  }
});

// ../../node_modules/lodash/identity.js
var require_identity = __commonJS({
  "../../node_modules/lodash/identity.js"(exports, module2) {
    function identity(value) {
      return value;
    }
    module2.exports = identity;
  }
});

// ../../node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "../../node_modules/lodash/_baseProperty.js"(exports, module2) {
    function baseProperty(key) {
      return function(object2) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    module2.exports = baseProperty;
  }
});

// ../../node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "../../node_modules/lodash/_basePropertyDeep.js"(exports, module2) {
    var baseGet = require_baseGet();
    function basePropertyDeep(path) {
      return function(object2) {
        return baseGet(object2, path);
      };
    }
    module2.exports = basePropertyDeep;
  }
});

// ../../node_modules/lodash/property.js
var require_property = __commonJS({
  "../../node_modules/lodash/property.js"(exports, module2) {
    var baseProperty = require_baseProperty();
    var basePropertyDeep = require_basePropertyDeep();
    var isKey = require_isKey();
    var toKey = require_toKey();
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module2.exports = property;
  }
});

// ../../node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "../../node_modules/lodash/_baseIteratee.js"(exports, module2) {
    var baseMatches = require_baseMatches();
    var baseMatchesProperty = require_baseMatchesProperty();
    var identity = require_identity();
    var isArray = require_isArray();
    var property = require_property();
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    module2.exports = baseIteratee;
  }
});

// ../../node_modules/lodash/mapValues.js
var require_mapValues = __commonJS({
  "../../node_modules/lodash/mapValues.js"(exports, module2) {
    var baseAssignValue = require_baseAssignValue();
    var baseForOwn = require_baseForOwn();
    var baseIteratee = require_baseIteratee();
    function mapValues3(object2, iteratee) {
      var result = {};
      iteratee = baseIteratee(iteratee, 3);
      baseForOwn(object2, function(value, key, object3) {
        baseAssignValue(result, key, iteratee(value, key, object3));
      });
      return result;
    }
    module2.exports = mapValues3;
  }
});

// ../../node_modules/property-expr/index.js
var require_property_expr = __commonJS({
  "../../node_modules/property-expr/index.js"(exports, module2) {
    "use strict";
    function Cache(maxSize) {
      this._maxSize = maxSize;
      this.clear();
    }
    Cache.prototype.clear = function() {
      this._size = 0;
      this._values = /* @__PURE__ */ Object.create(null);
    };
    Cache.prototype.get = function(key) {
      return this._values[key];
    };
    Cache.prototype.set = function(key, value) {
      this._size >= this._maxSize && this.clear();
      if (!(key in this._values))
        this._size++;
      return this._values[key] = value;
    };
    var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g;
    var DIGIT_REGEX = /^\d+$/;
    var LEAD_DIGIT_REGEX = /^\d/;
    var SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g;
    var CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/;
    var MAX_CACHE_SIZE3 = 512;
    var pathCache = new Cache(MAX_CACHE_SIZE3);
    var setCache = new Cache(MAX_CACHE_SIZE3);
    var getCache = new Cache(MAX_CACHE_SIZE3);
    module2.exports = {
      Cache,
      split: split2,
      normalizePath,
      setter: function(path) {
        var parts = normalizePath(path);
        return setCache.get(path) || setCache.set(path, function setter(obj, value) {
          var index = 0;
          var len = parts.length;
          var data = obj;
          while (index < len - 1) {
            var part = parts[index];
            if (part === "__proto__" || part === "constructor" || part === "prototype") {
              return obj;
            }
            data = data[parts[index++]];
          }
          data[parts[index]] = value;
        });
      },
      getter: function(path, safe) {
        var parts = normalizePath(path);
        return getCache.get(path) || getCache.set(path, function getter3(data) {
          var index = 0, len = parts.length;
          while (index < len) {
            if (data != null || !safe)
              data = data[parts[index++]];
            else
              return;
          }
          return data;
        });
      },
      join: function(segments) {
        return segments.reduce(function(path, part) {
          return path + (isQuoted(part) || DIGIT_REGEX.test(part) ? "[" + part + "]" : (path ? "." : "") + part);
        }, "");
      },
      forEach: function(path, cb2, thisArg) {
        forEach2(Array.isArray(path) ? path : split2(path), cb2, thisArg);
      }
    };
    function normalizePath(path) {
      return pathCache.get(path) || pathCache.set(
        path,
        split2(path).map(function(part) {
          return part.replace(CLEAN_QUOTES_REGEX, "$2");
        })
      );
    }
    function split2(path) {
      return path.match(SPLIT_REGEX) || [""];
    }
    function forEach2(parts, iter, thisArg) {
      var len = parts.length, part, idx, isArray, isBracket;
      for (idx = 0; idx < len; idx++) {
        part = parts[idx];
        if (part) {
          if (shouldBeQuoted(part)) {
            part = '"' + part + '"';
          }
          isBracket = isQuoted(part);
          isArray = !isBracket && /^\d+$/.test(part);
          iter.call(thisArg, part, isBracket, isArray, idx, parts);
        }
      }
    }
    function isQuoted(str) {
      return typeof str === "string" && str && ["'", '"'].indexOf(str.charAt(0)) !== -1;
    }
    function hasLeadingNumber(part) {
      return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);
    }
    function hasSpecialChars(part) {
      return SPEC_CHAR_REGEX.test(part);
    }
    function shouldBeQuoted(part) {
      return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));
    }
  }
});

// ../../node_modules/yup/es/Reference.js
function create(key, options) {
  return new Reference(key, options);
}
var import_property_expr, prefixes, Reference;
var init_Reference = __esm({
  "../../node_modules/yup/es/Reference.js"() {
    import_property_expr = __toESM(require_property_expr());
    prefixes = {
      context: "$",
      value: "."
    };
    Reference = class {
      constructor(key, options = {}) {
        if (typeof key !== "string")
          throw new TypeError("ref must be a string, got: " + key);
        this.key = key.trim();
        if (key === "")
          throw new TypeError("ref must be a non-empty string");
        this.isContext = this.key[0] === prefixes.context;
        this.isValue = this.key[0] === prefixes.value;
        this.isSibling = !this.isContext && !this.isValue;
        let prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : "";
        this.path = this.key.slice(prefix.length);
        this.getter = this.path && (0, import_property_expr.getter)(this.path, true);
        this.map = options.map;
      }
      getValue(value, parent, context) {
        let result = this.isContext ? context : this.isValue ? value : parent;
        if (this.getter)
          result = this.getter(result || {});
        if (this.map)
          result = this.map(result);
        return result;
      }
      /**
       *
       * @param {*} value
       * @param {Object} options
       * @param {Object=} options.context
       * @param {Object=} options.parent
       */
      cast(value, options) {
        return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);
      }
      resolve() {
        return this;
      }
      describe() {
        return {
          type: "ref",
          key: this.key
        };
      }
      toString() {
        return `Ref(${this.key})`;
      }
      static isRef(value) {
        return value && value.__isYupRef;
      }
    };
    Reference.prototype.__isYupRef = true;
  }
});

// ../../node_modules/yup/es/util/createValidation.js
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i10 = 1; i10 < arguments.length; i10++) {
      var source = arguments[i10];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i10;
  for (i10 = 0; i10 < sourceKeys.length; i10++) {
    key = sourceKeys[i10];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function createValidation(config) {
  function validate3(_ref, cb2) {
    let {
      value,
      path = "",
      label,
      options,
      originalValue,
      sync
    } = _ref, rest = _objectWithoutPropertiesLoose(_ref, ["value", "path", "label", "options", "originalValue", "sync"]);
    const {
      name,
      test,
      params: params2,
      message
    } = config;
    let {
      parent,
      context
    } = options;
    function resolve(item) {
      return Reference.isRef(item) ? item.getValue(value, parent, context) : item;
    }
    function createError2(overrides = {}) {
      const nextParams = (0, import_mapValues.default)(_extends2({
        value,
        originalValue,
        label,
        path: overrides.path || path
      }, params2, overrides.params), resolve);
      const error = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name);
      error.params = nextParams;
      return error;
    }
    let ctx = _extends2({
      path,
      parent,
      type: name,
      createError: createError2,
      resolve,
      options,
      originalValue
    }, rest);
    if (!sync) {
      try {
        Promise.resolve(test.call(ctx, value, ctx)).then((validOrError) => {
          if (ValidationError.isError(validOrError))
            cb2(validOrError);
          else if (!validOrError)
            cb2(createError2());
          else
            cb2(null, validOrError);
        });
      } catch (err) {
        cb2(err);
      }
      return;
    }
    let result;
    try {
      var _ref2;
      result = test.call(ctx, value, ctx);
      if (typeof ((_ref2 = result) == null ? void 0 : _ref2.then) === "function") {
        throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
      }
    } catch (err) {
      cb2(err);
      return;
    }
    if (ValidationError.isError(result))
      cb2(result);
    else if (!result)
      cb2(createError2());
    else
      cb2(null, result);
  }
  validate3.OPTIONS = config;
  return validate3;
}
var import_mapValues;
var init_createValidation = __esm({
  "../../node_modules/yup/es/util/createValidation.js"() {
    import_mapValues = __toESM(require_mapValues());
    init_ValidationError();
    init_Reference();
  }
});

// ../../node_modules/yup/es/util/reach.js
function getIn(schema, path, value, context = value) {
  let parent, lastPart, lastPartDebug;
  if (!path)
    return {
      parent,
      parentPath: path,
      schema
    };
  (0, import_property_expr2.forEach)(path, (_part, isBracket, isArray) => {
    let part = isBracket ? trim(_part) : _part;
    schema = schema.resolve({
      context,
      parent,
      value
    });
    if (schema.innerType) {
      let idx = isArray ? parseInt(part, 10) : 0;
      if (value && idx >= value.length) {
        throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. because there is no value at that index. `);
      }
      parent = value;
      value = value && value[idx];
      schema = schema.innerType;
    }
    if (!isArray) {
      if (!schema.fields || !schema.fields[part])
        throw new Error(`The schema does not contain the path: ${path}. (failed at: ${lastPartDebug} which is a type: "${schema._type}")`);
      parent = value;
      value = value && value[part];
      schema = schema.fields[part];
    }
    lastPart = part;
    lastPartDebug = isBracket ? "[" + _part + "]" : "." + _part;
  });
  return {
    schema,
    parent,
    parentPath: lastPart
  };
}
var import_property_expr2, trim, reach, reach_default;
var init_reach = __esm({
  "../../node_modules/yup/es/util/reach.js"() {
    import_property_expr2 = __toESM(require_property_expr());
    trim = (part) => part.substr(0, part.length - 1).substr(1);
    reach = (obj, path, value, context) => getIn(obj, path, value, context).schema;
    reach_default = reach;
  }
});

// ../../node_modules/yup/es/util/ReferenceSet.js
var ReferenceSet;
var init_ReferenceSet = __esm({
  "../../node_modules/yup/es/util/ReferenceSet.js"() {
    init_Reference();
    ReferenceSet = class {
      constructor() {
        this.list = /* @__PURE__ */ new Set();
        this.refs = /* @__PURE__ */ new Map();
      }
      get size() {
        return this.list.size + this.refs.size;
      }
      describe() {
        const description = [];
        for (const item of this.list)
          description.push(item);
        for (const [, ref] of this.refs)
          description.push(ref.describe());
        return description;
      }
      toArray() {
        return Array.from(this.list).concat(Array.from(this.refs.values()));
      }
      add(value) {
        Reference.isRef(value) ? this.refs.set(value.key, value) : this.list.add(value);
      }
      delete(value) {
        Reference.isRef(value) ? this.refs.delete(value.key) : this.list.delete(value);
      }
      has(value, resolve) {
        if (this.list.has(value))
          return true;
        let item, values = this.refs.values();
        while (item = values.next(), !item.done)
          if (resolve(item.value) === value)
            return true;
        return false;
      }
      clone() {
        const next = new ReferenceSet();
        next.list = new Set(this.list);
        next.refs = new Map(this.refs);
        return next;
      }
      merge(newItems, removeItems) {
        const next = this.clone();
        newItems.list.forEach((value) => next.add(value));
        newItems.refs.forEach((value) => next.add(value));
        removeItems.list.forEach((value) => next.delete(value));
        removeItems.refs.forEach((value) => next.delete(value));
        return next;
      }
    };
  }
});

// ../../node_modules/yup/es/schema.js
function _extends3() {
  _extends3 = Object.assign || function(target) {
    for (var i10 = 1; i10 < arguments.length; i10++) {
      var source = arguments[i10];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}
var BaseSchema;
var init_schema = __esm({
  "../../node_modules/yup/es/schema.js"() {
    init_src();
    init_locale();
    init_Condition();
    init_runTests();
    init_createValidation();
    init_printValue();
    init_Reference();
    init_reach();
    init_toArray();
    init_ValidationError();
    init_ReferenceSet();
    BaseSchema = class {
      constructor(options) {
        this.deps = [];
        this.conditions = [];
        this._whitelist = new ReferenceSet();
        this._blacklist = new ReferenceSet();
        this.exclusiveTests = /* @__PURE__ */ Object.create(null);
        this.tests = [];
        this.transforms = [];
        this.withMutation(() => {
          this.typeError(mixed.notType);
        });
        this.type = (options == null ? void 0 : options.type) || "mixed";
        this.spec = _extends3({
          strip: false,
          strict: false,
          abortEarly: true,
          recursive: true,
          nullable: false,
          presence: "optional"
        }, options == null ? void 0 : options.spec);
      }
      // TODO: remove
      get _type() {
        return this.type;
      }
      _typeCheck(_value) {
        return true;
      }
      clone(spec) {
        if (this._mutate) {
          if (spec)
            Object.assign(this.spec, spec);
          return this;
        }
        const next = Object.create(Object.getPrototypeOf(this));
        next.type = this.type;
        next._typeError = this._typeError;
        next._whitelistError = this._whitelistError;
        next._blacklistError = this._blacklistError;
        next._whitelist = this._whitelist.clone();
        next._blacklist = this._blacklist.clone();
        next.exclusiveTests = _extends3({}, this.exclusiveTests);
        next.deps = [...this.deps];
        next.conditions = [...this.conditions];
        next.tests = [...this.tests];
        next.transforms = [...this.transforms];
        next.spec = clone(_extends3({}, this.spec, spec));
        return next;
      }
      label(label) {
        var next = this.clone();
        next.spec.label = label;
        return next;
      }
      meta(...args) {
        if (args.length === 0)
          return this.spec.meta;
        let next = this.clone();
        next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
        return next;
      }
      // withContext<TContext extends AnyObject>(): BaseSchema<
      //   TCast,
      //   TContext,
      //   TOutput
      // > {
      //   return this as any;
      // }
      withMutation(fn) {
        let before = this._mutate;
        this._mutate = true;
        let result = fn(this);
        this._mutate = before;
        return result;
      }
      concat(schema) {
        if (!schema || schema === this)
          return this;
        if (schema.type !== this.type && this.type !== "mixed")
          throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema.type}`);
        let base = this;
        let combined = schema.clone();
        const mergedSpec = _extends3({}, base.spec, combined.spec);
        combined.spec = mergedSpec;
        combined._typeError || (combined._typeError = base._typeError);
        combined._whitelistError || (combined._whitelistError = base._whitelistError);
        combined._blacklistError || (combined._blacklistError = base._blacklistError);
        combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);
        combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);
        combined.tests = base.tests;
        combined.exclusiveTests = base.exclusiveTests;
        combined.withMutation((next) => {
          schema.tests.forEach((fn) => {
            next.test(fn.OPTIONS);
          });
        });
        return combined;
      }
      isType(v7) {
        if (this.spec.nullable && v7 === null)
          return true;
        return this._typeCheck(v7);
      }
      resolve(options) {
        let schema = this;
        if (schema.conditions.length) {
          let conditions = schema.conditions;
          schema = schema.clone();
          schema.conditions = [];
          schema = conditions.reduce((schema2, condition) => condition.resolve(schema2, options), schema);
          schema = schema.resolve(options);
        }
        return schema;
      }
      /**
       *
       * @param {*} value
       * @param {Object} options
       * @param {*=} options.parent
       * @param {*=} options.context
       */
      cast(value, options = {}) {
        let resolvedSchema = this.resolve(_extends3({
          value
        }, options));
        let result = resolvedSchema._cast(value, options);
        if (value !== void 0 && options.assert !== false && resolvedSchema.isType(result) !== true) {
          let formattedValue = printValue(value);
          let formattedResult = printValue(result);
          throw new TypeError(`The value of ${options.path || "field"} could not be cast to a value that satisfies the schema type: "${resolvedSchema._type}". 

attempted value: ${formattedValue} 
` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ""));
        }
        return result;
      }
      _cast(rawValue, _options) {
        let value = rawValue === void 0 ? rawValue : this.transforms.reduce((value2, fn) => fn.call(this, value2, rawValue, this), rawValue);
        if (value === void 0) {
          value = this.getDefault();
        }
        return value;
      }
      _validate(_value, options = {}, cb2) {
        let {
          sync,
          path,
          from = [],
          originalValue = _value,
          strict = this.spec.strict,
          abortEarly = this.spec.abortEarly
        } = options;
        let value = _value;
        if (!strict) {
          value = this._cast(value, _extends3({
            assert: false
          }, options));
        }
        let args = {
          value,
          path,
          options,
          originalValue,
          schema: this,
          label: this.spec.label,
          sync,
          from
        };
        let initialTests = [];
        if (this._typeError)
          initialTests.push(this._typeError);
        if (this._whitelistError)
          initialTests.push(this._whitelistError);
        if (this._blacklistError)
          initialTests.push(this._blacklistError);
        runTests({
          args,
          value,
          path,
          sync,
          tests: initialTests,
          endEarly: abortEarly
        }, (err) => {
          if (err)
            return void cb2(err, value);
          runTests({
            tests: this.tests,
            args,
            path,
            sync,
            value,
            endEarly: abortEarly
          }, cb2);
        });
      }
      validate(value, options, maybeCb) {
        let schema = this.resolve(_extends3({}, options, {
          value
        }));
        return typeof maybeCb === "function" ? schema._validate(value, options, maybeCb) : new Promise((resolve, reject) => schema._validate(value, options, (err, value2) => {
          if (err)
            reject(err);
          else
            resolve(value2);
        }));
      }
      validateSync(value, options) {
        let schema = this.resolve(_extends3({}, options, {
          value
        }));
        let result;
        schema._validate(value, _extends3({}, options, {
          sync: true
        }), (err, value2) => {
          if (err)
            throw err;
          result = value2;
        });
        return result;
      }
      isValid(value, options) {
        return this.validate(value, options).then(() => true, (err) => {
          if (ValidationError.isError(err))
            return false;
          throw err;
        });
      }
      isValidSync(value, options) {
        try {
          this.validateSync(value, options);
          return true;
        } catch (err) {
          if (ValidationError.isError(err))
            return false;
          throw err;
        }
      }
      _getDefault() {
        let defaultValue = this.spec.default;
        if (defaultValue == null) {
          return defaultValue;
        }
        return typeof defaultValue === "function" ? defaultValue.call(this) : clone(defaultValue);
      }
      getDefault(options) {
        let schema = this.resolve(options || {});
        return schema._getDefault();
      }
      default(def) {
        if (arguments.length === 0) {
          return this._getDefault();
        }
        let next = this.clone({
          default: def
        });
        return next;
      }
      strict(isStrict = true) {
        var next = this.clone();
        next.spec.strict = isStrict;
        return next;
      }
      _isPresent(value) {
        return value != null;
      }
      defined(message = mixed.defined) {
        return this.test({
          message,
          name: "defined",
          exclusive: true,
          test(value) {
            return value !== void 0;
          }
        });
      }
      required(message = mixed.required) {
        return this.clone({
          presence: "required"
        }).withMutation((s10) => s10.test({
          message,
          name: "required",
          exclusive: true,
          test(value) {
            return this.schema._isPresent(value);
          }
        }));
      }
      notRequired() {
        var next = this.clone({
          presence: "optional"
        });
        next.tests = next.tests.filter((test) => test.OPTIONS.name !== "required");
        return next;
      }
      nullable(isNullable = true) {
        var next = this.clone({
          nullable: isNullable !== false
        });
        return next;
      }
      transform(fn) {
        var next = this.clone();
        next.transforms.push(fn);
        return next;
      }
      /**
       * Adds a test function to the schema's queue of tests.
       * tests can be exclusive or non-exclusive.
       *
       * - exclusive tests, will replace any existing tests of the same name.
       * - non-exclusive: can be stacked
       *
       * If a non-exclusive test is added to a schema with an exclusive test of the same name
       * the exclusive test is removed and further tests of the same name will be stacked.
       *
       * If an exclusive test is added to a schema with non-exclusive tests of the same name
       * the previous tests are removed and further tests of the same name will replace each other.
       */
      test(...args) {
        let opts;
        if (args.length === 1) {
          if (typeof args[0] === "function") {
            opts = {
              test: args[0]
            };
          } else {
            opts = args[0];
          }
        } else if (args.length === 2) {
          opts = {
            name: args[0],
            test: args[1]
          };
        } else {
          opts = {
            name: args[0],
            message: args[1],
            test: args[2]
          };
        }
        if (opts.message === void 0)
          opts.message = mixed.default;
        if (typeof opts.test !== "function")
          throw new TypeError("`test` is a required parameters");
        let next = this.clone();
        let validate3 = createValidation(opts);
        let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;
        if (opts.exclusive) {
          if (!opts.name)
            throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
        }
        if (opts.name)
          next.exclusiveTests[opts.name] = !!opts.exclusive;
        next.tests = next.tests.filter((fn) => {
          if (fn.OPTIONS.name === opts.name) {
            if (isExclusive)
              return false;
            if (fn.OPTIONS.test === validate3.OPTIONS.test)
              return false;
          }
          return true;
        });
        next.tests.push(validate3);
        return next;
      }
      when(keys, options) {
        if (!Array.isArray(keys) && typeof keys !== "string") {
          options = keys;
          keys = ".";
        }
        let next = this.clone();
        let deps = toArray(keys).map((key) => new Reference(key));
        deps.forEach((dep) => {
          if (dep.isSibling)
            next.deps.push(dep.key);
        });
        next.conditions.push(new Condition_default(deps, options));
        return next;
      }
      typeError(message) {
        var next = this.clone();
        next._typeError = createValidation({
          message,
          name: "typeError",
          test(value) {
            if (value !== void 0 && !this.schema.isType(value))
              return this.createError({
                params: {
                  type: this.schema._type
                }
              });
            return true;
          }
        });
        return next;
      }
      oneOf(enums, message = mixed.oneOf) {
        var next = this.clone();
        enums.forEach((val) => {
          next._whitelist.add(val);
          next._blacklist.delete(val);
        });
        next._whitelistError = createValidation({
          message,
          name: "oneOf",
          test(value) {
            if (value === void 0)
              return true;
            let valids = this.schema._whitelist;
            return valids.has(value, this.resolve) ? true : this.createError({
              params: {
                values: valids.toArray().join(", ")
              }
            });
          }
        });
        return next;
      }
      notOneOf(enums, message = mixed.notOneOf) {
        var next = this.clone();
        enums.forEach((val) => {
          next._blacklist.add(val);
          next._whitelist.delete(val);
        });
        next._blacklistError = createValidation({
          message,
          name: "notOneOf",
          test(value) {
            let invalids = this.schema._blacklist;
            if (invalids.has(value, this.resolve))
              return this.createError({
                params: {
                  values: invalids.toArray().join(", ")
                }
              });
            return true;
          }
        });
        return next;
      }
      strip(strip = true) {
        let next = this.clone();
        next.spec.strip = strip;
        return next;
      }
      describe() {
        const next = this.clone();
        const {
          label,
          meta
        } = next.spec;
        const description = {
          meta,
          label,
          type: next.type,
          oneOf: next._whitelist.describe(),
          notOneOf: next._blacklist.describe(),
          tests: next.tests.map((fn) => ({
            name: fn.OPTIONS.name,
            params: fn.OPTIONS.params
          })).filter((n10, idx, list2) => list2.findIndex((c10) => c10.name === n10.name) === idx)
        };
        return description;
      }
    };
    BaseSchema.prototype.__isYupSchema__ = true;
    for (const method of ["validate", "validateSync"])
      BaseSchema.prototype[`${method}At`] = function(path, value, options = {}) {
        const {
          parent,
          parentPath,
          schema
        } = getIn(this, path, value, options.context);
        return schema[method](parent && parent[parentPath], _extends3({}, options, {
          parent,
          path
        }));
      };
    for (const alias of ["equals", "is"])
      BaseSchema.prototype[alias] = BaseSchema.prototype.oneOf;
    for (const alias of ["not", "nope"])
      BaseSchema.prototype[alias] = BaseSchema.prototype.notOneOf;
    BaseSchema.prototype.optional = BaseSchema.prototype.notRequired;
  }
});

// ../../node_modules/yup/es/mixed.js
function create2() {
  return new Mixed();
}
var Mixed, mixed_default;
var init_mixed = __esm({
  "../../node_modules/yup/es/mixed.js"() {
    init_schema();
    Mixed = BaseSchema;
    mixed_default = Mixed;
    create2.prototype = Mixed.prototype;
  }
});

// ../../node_modules/yup/es/util/isAbsent.js
var isAbsent_default;
var init_isAbsent = __esm({
  "../../node_modules/yup/es/util/isAbsent.js"() {
    isAbsent_default = (value) => value == null;
  }
});

// ../../node_modules/yup/es/boolean.js
function create3() {
  return new BooleanSchema();
}
var BooleanSchema;
var init_boolean = __esm({
  "../../node_modules/yup/es/boolean.js"() {
    init_schema();
    init_locale();
    init_isAbsent();
    BooleanSchema = class extends BaseSchema {
      constructor() {
        super({
          type: "boolean"
        });
        this.withMutation(() => {
          this.transform(function(value) {
            if (!this.isType(value)) {
              if (/^(true|1)$/i.test(String(value)))
                return true;
              if (/^(false|0)$/i.test(String(value)))
                return false;
            }
            return value;
          });
        });
      }
      _typeCheck(v7) {
        if (v7 instanceof Boolean)
          v7 = v7.valueOf();
        return typeof v7 === "boolean";
      }
      isTrue(message = boolean.isValue) {
        return this.test({
          message,
          name: "is-value",
          exclusive: true,
          params: {
            value: "true"
          },
          test(value) {
            return isAbsent_default(value) || value === true;
          }
        });
      }
      isFalse(message = boolean.isValue) {
        return this.test({
          message,
          name: "is-value",
          exclusive: true,
          params: {
            value: "false"
          },
          test(value) {
            return isAbsent_default(value) || value === false;
          }
        });
      }
    };
    create3.prototype = BooleanSchema.prototype;
  }
});

// ../../node_modules/yup/es/string.js
function create4() {
  return new StringSchema();
}
var rEmail, rUrl, rUUID, isTrimmed, objStringTag, StringSchema;
var init_string = __esm({
  "../../node_modules/yup/es/string.js"() {
    init_locale();
    init_isAbsent();
    init_schema();
    rEmail = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
    rUrl = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;
    rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    isTrimmed = (value) => isAbsent_default(value) || value === value.trim();
    objStringTag = {}.toString();
    StringSchema = class extends BaseSchema {
      constructor() {
        super({
          type: "string"
        });
        this.withMutation(() => {
          this.transform(function(value) {
            if (this.isType(value))
              return value;
            if (Array.isArray(value))
              return value;
            const strValue = value != null && value.toString ? value.toString() : value;
            if (strValue === objStringTag)
              return value;
            return strValue;
          });
        });
      }
      _typeCheck(value) {
        if (value instanceof String)
          value = value.valueOf();
        return typeof value === "string";
      }
      _isPresent(value) {
        return super._isPresent(value) && !!value.length;
      }
      length(length, message = string.length) {
        return this.test({
          message,
          name: "length",
          exclusive: true,
          params: {
            length
          },
          test(value) {
            return isAbsent_default(value) || value.length === this.resolve(length);
          }
        });
      }
      min(min, message = string.min) {
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            min
          },
          test(value) {
            return isAbsent_default(value) || value.length >= this.resolve(min);
          }
        });
      }
      max(max, message = string.max) {
        return this.test({
          name: "max",
          exclusive: true,
          message,
          params: {
            max
          },
          test(value) {
            return isAbsent_default(value) || value.length <= this.resolve(max);
          }
        });
      }
      matches(regex, options) {
        let excludeEmptyString = false;
        let message;
        let name;
        if (options) {
          if (typeof options === "object") {
            ({
              excludeEmptyString = false,
              message,
              name
            } = options);
          } else {
            message = options;
          }
        }
        return this.test({
          name: name || "matches",
          message: message || string.matches,
          params: {
            regex
          },
          test: (value) => isAbsent_default(value) || value === "" && excludeEmptyString || value.search(regex) !== -1
        });
      }
      email(message = string.email) {
        return this.matches(rEmail, {
          name: "email",
          message,
          excludeEmptyString: true
        });
      }
      url(message = string.url) {
        return this.matches(rUrl, {
          name: "url",
          message,
          excludeEmptyString: true
        });
      }
      uuid(message = string.uuid) {
        return this.matches(rUUID, {
          name: "uuid",
          message,
          excludeEmptyString: false
        });
      }
      //-- transforms --
      ensure() {
        return this.default("").transform((val) => val === null ? "" : val);
      }
      trim(message = string.trim) {
        return this.transform((val) => val != null ? val.trim() : val).test({
          message,
          name: "trim",
          test: isTrimmed
        });
      }
      lowercase(message = string.lowercase) {
        return this.transform((value) => !isAbsent_default(value) ? value.toLowerCase() : value).test({
          message,
          name: "string_case",
          exclusive: true,
          test: (value) => isAbsent_default(value) || value === value.toLowerCase()
        });
      }
      uppercase(message = string.uppercase) {
        return this.transform((value) => !isAbsent_default(value) ? value.toUpperCase() : value).test({
          message,
          name: "string_case",
          exclusive: true,
          test: (value) => isAbsent_default(value) || value === value.toUpperCase()
        });
      }
    };
    create4.prototype = StringSchema.prototype;
  }
});

// ../../node_modules/yup/es/number.js
function create5() {
  return new NumberSchema();
}
var isNaN2, NumberSchema;
var init_number = __esm({
  "../../node_modules/yup/es/number.js"() {
    init_locale();
    init_isAbsent();
    init_schema();
    isNaN2 = (value) => value != +value;
    NumberSchema = class extends BaseSchema {
      constructor() {
        super({
          type: "number"
        });
        this.withMutation(() => {
          this.transform(function(value) {
            let parsed = value;
            if (typeof parsed === "string") {
              parsed = parsed.replace(/\s/g, "");
              if (parsed === "")
                return NaN;
              parsed = +parsed;
            }
            if (this.isType(parsed))
              return parsed;
            return parseFloat(parsed);
          });
        });
      }
      _typeCheck(value) {
        if (value instanceof Number)
          value = value.valueOf();
        return typeof value === "number" && !isNaN2(value);
      }
      min(min, message = number.min) {
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            min
          },
          test(value) {
            return isAbsent_default(value) || value >= this.resolve(min);
          }
        });
      }
      max(max, message = number.max) {
        return this.test({
          message,
          name: "max",
          exclusive: true,
          params: {
            max
          },
          test(value) {
            return isAbsent_default(value) || value <= this.resolve(max);
          }
        });
      }
      lessThan(less, message = number.lessThan) {
        return this.test({
          message,
          name: "max",
          exclusive: true,
          params: {
            less
          },
          test(value) {
            return isAbsent_default(value) || value < this.resolve(less);
          }
        });
      }
      moreThan(more, message = number.moreThan) {
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            more
          },
          test(value) {
            return isAbsent_default(value) || value > this.resolve(more);
          }
        });
      }
      positive(msg = number.positive) {
        return this.moreThan(0, msg);
      }
      negative(msg = number.negative) {
        return this.lessThan(0, msg);
      }
      integer(message = number.integer) {
        return this.test({
          name: "integer",
          message,
          test: (val) => isAbsent_default(val) || Number.isInteger(val)
        });
      }
      truncate() {
        return this.transform((value) => !isAbsent_default(value) ? value | 0 : value);
      }
      round(method) {
        var _method;
        var avail = ["ceil", "floor", "round", "trunc"];
        method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || "round";
        if (method === "trunc")
          return this.truncate();
        if (avail.indexOf(method.toLowerCase()) === -1)
          throw new TypeError("Only valid options for round() are: " + avail.join(", "));
        return this.transform((value) => !isAbsent_default(value) ? Math[method](value) : value);
      }
    };
    create5.prototype = NumberSchema.prototype;
  }
});

// ../../node_modules/yup/es/util/isodate.js
function parseIsoDate(date2) {
  var numericKeys = [1, 4, 5, 6, 7, 10, 11], minutesOffset = 0, timestamp, struct;
  if (struct = isoReg.exec(date2)) {
    for (var i10 = 0, k10; k10 = numericKeys[i10]; ++i10)
      struct[k10] = +struct[k10] || 0;
    struct[2] = (+struct[2] || 1) - 1;
    struct[3] = +struct[3] || 1;
    struct[7] = struct[7] ? String(struct[7]).substr(0, 3) : 0;
    if ((struct[8] === void 0 || struct[8] === "") && (struct[9] === void 0 || struct[9] === ""))
      timestamp = +new Date(struct[1], struct[2], struct[3], struct[4], struct[5], struct[6], struct[7]);
    else {
      if (struct[8] !== "Z" && struct[9] !== void 0) {
        minutesOffset = struct[10] * 60 + struct[11];
        if (struct[9] === "+")
          minutesOffset = 0 - minutesOffset;
      }
      timestamp = Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]);
    }
  } else
    timestamp = Date.parse ? Date.parse(date2) : NaN;
  return timestamp;
}
var isoReg;
var init_isodate = __esm({
  "../../node_modules/yup/es/util/isodate.js"() {
    isoReg = /^(\d{4}|[+\-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,\.](\d{1,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?)?)?$/;
  }
});

// ../../node_modules/yup/es/date.js
function create6() {
  return new DateSchema();
}
var invalidDate, isDate, DateSchema;
var init_date = __esm({
  "../../node_modules/yup/es/date.js"() {
    init_isodate();
    init_locale();
    init_isAbsent();
    init_Reference();
    init_schema();
    invalidDate = /* @__PURE__ */ new Date("");
    isDate = (obj) => Object.prototype.toString.call(obj) === "[object Date]";
    DateSchema = class extends BaseSchema {
      constructor() {
        super({
          type: "date"
        });
        this.withMutation(() => {
          this.transform(function(value) {
            if (this.isType(value))
              return value;
            value = parseIsoDate(value);
            return !isNaN(value) ? new Date(value) : invalidDate;
          });
        });
      }
      _typeCheck(v7) {
        return isDate(v7) && !isNaN(v7.getTime());
      }
      prepareParam(ref, name) {
        let param;
        if (!Reference.isRef(ref)) {
          let cast = this.cast(ref);
          if (!this._typeCheck(cast))
            throw new TypeError(`\`${name}\` must be a Date or a value that can be \`cast()\` to a Date`);
          param = cast;
        } else {
          param = ref;
        }
        return param;
      }
      min(min, message = date.min) {
        let limit = this.prepareParam(min, "min");
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            min
          },
          test(value) {
            return isAbsent_default(value) || value >= this.resolve(limit);
          }
        });
      }
      max(max, message = date.max) {
        var limit = this.prepareParam(max, "max");
        return this.test({
          message,
          name: "max",
          exclusive: true,
          params: {
            max
          },
          test(value) {
            return isAbsent_default(value) || value <= this.resolve(limit);
          }
        });
      }
    };
    DateSchema.INVALID_DATE = invalidDate;
    create6.prototype = DateSchema.prototype;
    create6.INVALID_DATE = invalidDate;
  }
});

// ../../node_modules/lodash/_arrayReduce.js
var require_arrayReduce = __commonJS({
  "../../node_modules/lodash/_arrayReduce.js"(exports, module2) {
    function arrayReduce(array2, iteratee, accumulator, initAccum) {
      var index = -1, length = array2 == null ? 0 : array2.length;
      if (initAccum && length) {
        accumulator = array2[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array2[index], index, array2);
      }
      return accumulator;
    }
    module2.exports = arrayReduce;
  }
});

// ../../node_modules/lodash/_basePropertyOf.js
var require_basePropertyOf = __commonJS({
  "../../node_modules/lodash/_basePropertyOf.js"(exports, module2) {
    function basePropertyOf(object2) {
      return function(key) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    module2.exports = basePropertyOf;
  }
});

// ../../node_modules/lodash/_deburrLetter.js
var require_deburrLetter = __commonJS({
  "../../node_modules/lodash/_deburrLetter.js"(exports, module2) {
    var basePropertyOf = require_basePropertyOf();
    var deburredLetters = {
      // Latin-1 Supplement block.
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      // Latin Extended-A block.
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    var deburrLetter = basePropertyOf(deburredLetters);
    module2.exports = deburrLetter;
  }
});

// ../../node_modules/lodash/deburr.js
var require_deburr = __commonJS({
  "../../node_modules/lodash/deburr.js"(exports, module2) {
    var deburrLetter = require_deburrLetter();
    var toString2 = require_toString();
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsCombo = "[" + rsComboRange + "]";
    var reComboMark = RegExp(rsCombo, "g");
    function deburr(string2) {
      string2 = toString2(string2);
      return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    module2.exports = deburr;
  }
});

// ../../node_modules/lodash/_asciiWords.js
var require_asciiWords = __commonJS({
  "../../node_modules/lodash/_asciiWords.js"(exports, module2) {
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    function asciiWords(string2) {
      return string2.match(reAsciiWord) || [];
    }
    module2.exports = asciiWords;
  }
});

// ../../node_modules/lodash/_hasUnicodeWord.js
var require_hasUnicodeWord = __commonJS({
  "../../node_modules/lodash/_hasUnicodeWord.js"(exports, module2) {
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    function hasUnicodeWord(string2) {
      return reHasUnicodeWord.test(string2);
    }
    module2.exports = hasUnicodeWord;
  }
});

// ../../node_modules/lodash/_unicodeWords.js
var require_unicodeWords = __commonJS({
  "../../node_modules/lodash/_unicodeWords.js"(exports, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
    var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    function unicodeWords(string2) {
      return string2.match(reUnicodeWord) || [];
    }
    module2.exports = unicodeWords;
  }
});

// ../../node_modules/lodash/words.js
var require_words = __commonJS({
  "../../node_modules/lodash/words.js"(exports, module2) {
    var asciiWords = require_asciiWords();
    var hasUnicodeWord = require_hasUnicodeWord();
    var toString2 = require_toString();
    var unicodeWords = require_unicodeWords();
    function words(string2, pattern, guard) {
      string2 = toString2(string2);
      pattern = guard ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
      }
      return string2.match(pattern) || [];
    }
    module2.exports = words;
  }
});

// ../../node_modules/lodash/_createCompounder.js
var require_createCompounder = __commonJS({
  "../../node_modules/lodash/_createCompounder.js"(exports, module2) {
    var arrayReduce = require_arrayReduce();
    var deburr = require_deburr();
    var words = require_words();
    var rsApos = "['\u2019]";
    var reApos = RegExp(rsApos, "g");
    function createCompounder(callback) {
      return function(string2) {
        return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
      };
    }
    module2.exports = createCompounder;
  }
});

// ../../node_modules/lodash/snakeCase.js
var require_snakeCase = __commonJS({
  "../../node_modules/lodash/snakeCase.js"(exports, module2) {
    var createCompounder = require_createCompounder();
    var snakeCase2 = createCompounder(function(result, word, index) {
      return result + (index ? "_" : "") + word.toLowerCase();
    });
    module2.exports = snakeCase2;
  }
});

// ../../node_modules/lodash/_baseSlice.js
var require_baseSlice = __commonJS({
  "../../node_modules/lodash/_baseSlice.js"(exports, module2) {
    function baseSlice(array2, start, end) {
      var index = -1, length = array2.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array2[index + start];
      }
      return result;
    }
    module2.exports = baseSlice;
  }
});

// ../../node_modules/lodash/_castSlice.js
var require_castSlice = __commonJS({
  "../../node_modules/lodash/_castSlice.js"(exports, module2) {
    var baseSlice = require_baseSlice();
    function castSlice(array2, start, end) {
      var length = array2.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array2 : baseSlice(array2, start, end);
    }
    module2.exports = castSlice;
  }
});

// ../../node_modules/lodash/_hasUnicode.js
var require_hasUnicode = __commonJS({
  "../../node_modules/lodash/_hasUnicode.js"(exports, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string2) {
      return reHasUnicode.test(string2);
    }
    module2.exports = hasUnicode;
  }
});

// ../../node_modules/lodash/_asciiToArray.js
var require_asciiToArray = __commonJS({
  "../../node_modules/lodash/_asciiToArray.js"(exports, module2) {
    function asciiToArray(string2) {
      return string2.split("");
    }
    module2.exports = asciiToArray;
  }
});

// ../../node_modules/lodash/_unicodeToArray.js
var require_unicodeToArray = __commonJS({
  "../../node_modules/lodash/_unicodeToArray.js"(exports, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string2) {
      return string2.match(reUnicode) || [];
    }
    module2.exports = unicodeToArray;
  }
});

// ../../node_modules/lodash/_stringToArray.js
var require_stringToArray = __commonJS({
  "../../node_modules/lodash/_stringToArray.js"(exports, module2) {
    var asciiToArray = require_asciiToArray();
    var hasUnicode = require_hasUnicode();
    var unicodeToArray = require_unicodeToArray();
    function stringToArray(string2) {
      return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
    }
    module2.exports = stringToArray;
  }
});

// ../../node_modules/lodash/_createCaseFirst.js
var require_createCaseFirst = __commonJS({
  "../../node_modules/lodash/_createCaseFirst.js"(exports, module2) {
    var castSlice = require_castSlice();
    var hasUnicode = require_hasUnicode();
    var stringToArray = require_stringToArray();
    var toString2 = require_toString();
    function createCaseFirst(methodName) {
      return function(string2) {
        string2 = toString2(string2);
        var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
        var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    module2.exports = createCaseFirst;
  }
});

// ../../node_modules/lodash/upperFirst.js
var require_upperFirst = __commonJS({
  "../../node_modules/lodash/upperFirst.js"(exports, module2) {
    var createCaseFirst = require_createCaseFirst();
    var upperFirst = createCaseFirst("toUpperCase");
    module2.exports = upperFirst;
  }
});

// ../../node_modules/lodash/capitalize.js
var require_capitalize = __commonJS({
  "../../node_modules/lodash/capitalize.js"(exports, module2) {
    var toString2 = require_toString();
    var upperFirst = require_upperFirst();
    function capitalize(string2) {
      return upperFirst(toString2(string2).toLowerCase());
    }
    module2.exports = capitalize;
  }
});

// ../../node_modules/lodash/camelCase.js
var require_camelCase = __commonJS({
  "../../node_modules/lodash/camelCase.js"(exports, module2) {
    var capitalize = require_capitalize();
    var createCompounder = require_createCompounder();
    var camelCase2 = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });
    module2.exports = camelCase2;
  }
});

// ../../node_modules/lodash/mapKeys.js
var require_mapKeys = __commonJS({
  "../../node_modules/lodash/mapKeys.js"(exports, module2) {
    var baseAssignValue = require_baseAssignValue();
    var baseForOwn = require_baseForOwn();
    var baseIteratee = require_baseIteratee();
    function mapKeys2(object2, iteratee) {
      var result = {};
      iteratee = baseIteratee(iteratee, 3);
      baseForOwn(object2, function(value, key, object3) {
        baseAssignValue(result, iteratee(value, key, object3), value);
      });
      return result;
    }
    module2.exports = mapKeys2;
  }
});

// ../../node_modules/toposort/index.js
var require_toposort = __commonJS({
  "../../node_modules/toposort/index.js"(exports, module2) {
    module2.exports = function(edges) {
      return toposort2(uniqueNodes(edges), edges);
    };
    module2.exports.array = toposort2;
    function toposort2(nodes, edges) {
      var cursor = nodes.length, sorted = new Array(cursor), visited = {}, i10 = cursor, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
      edges.forEach(function(edge) {
        if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
          throw new Error("Unknown node. There is an unknown node in the supplied edges.");
        }
      });
      while (i10--) {
        if (!visited[i10])
          visit(nodes[i10], i10, /* @__PURE__ */ new Set());
      }
      return sorted;
      function visit(node, i11, predecessors) {
        if (predecessors.has(node)) {
          var nodeRep;
          try {
            nodeRep = ", node was:" + JSON.stringify(node);
          } catch (e10) {
            nodeRep = "";
          }
          throw new Error("Cyclic dependency" + nodeRep);
        }
        if (!nodesHash.has(node)) {
          throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node));
        }
        if (visited[i11])
          return;
        visited[i11] = true;
        var outgoing = outgoingEdges.get(node) || /* @__PURE__ */ new Set();
        outgoing = Array.from(outgoing);
        if (i11 = outgoing.length) {
          predecessors.add(node);
          do {
            var child = outgoing[--i11];
            visit(child, nodesHash.get(child), predecessors);
          } while (i11);
          predecessors.delete(node);
        }
        sorted[--cursor] = node;
      }
    }
    function uniqueNodes(arr) {
      var res = /* @__PURE__ */ new Set();
      for (var i10 = 0, len = arr.length; i10 < len; i10++) {
        var edge = arr[i10];
        res.add(edge[0]);
        res.add(edge[1]);
      }
      return Array.from(res);
    }
    function makeOutgoingEdges(arr) {
      var edges = /* @__PURE__ */ new Map();
      for (var i10 = 0, len = arr.length; i10 < len; i10++) {
        var edge = arr[i10];
        if (!edges.has(edge[0]))
          edges.set(edge[0], /* @__PURE__ */ new Set());
        if (!edges.has(edge[1]))
          edges.set(edge[1], /* @__PURE__ */ new Set());
        edges.get(edge[0]).add(edge[1]);
      }
      return edges;
    }
    function makeNodesHash(arr) {
      var res = /* @__PURE__ */ new Map();
      for (var i10 = 0, len = arr.length; i10 < len; i10++) {
        res.set(arr[i10], i10);
      }
      return res;
    }
  }
});

// ../../node_modules/yup/es/util/sortFields.js
function sortFields(fields, excludes = []) {
  let edges = [];
  let nodes = [];
  function addNode(depPath, key) {
    var node = (0, import_property_expr3.split)(depPath)[0];
    if (!~nodes.indexOf(node))
      nodes.push(node);
    if (!~excludes.indexOf(`${key}-${node}`))
      edges.push([key, node]);
  }
  for (const key in fields)
    if ((0, import_has2.default)(fields, key)) {
      let value = fields[key];
      if (!~nodes.indexOf(key))
        nodes.push(key);
      if (Reference.isRef(value) && value.isSibling)
        addNode(value.path, key);
      else if (isSchema_default(value) && "deps" in value)
        value.deps.forEach((path) => addNode(path, key));
    }
  return import_toposort.default.array(nodes, edges).reverse();
}
var import_has2, import_toposort, import_property_expr3;
var init_sortFields = __esm({
  "../../node_modules/yup/es/util/sortFields.js"() {
    import_has2 = __toESM(require_has());
    import_toposort = __toESM(require_toposort());
    import_property_expr3 = __toESM(require_property_expr());
    init_Reference();
    init_isSchema();
  }
});

// ../../node_modules/yup/es/util/sortByKeyOrder.js
function findIndex(arr, err) {
  let idx = Infinity;
  arr.some((key, ii) => {
    var _err$path;
    if (((_err$path = err.path) == null ? void 0 : _err$path.indexOf(key)) !== -1) {
      idx = ii;
      return true;
    }
  });
  return idx;
}
function sortByKeyOrder(keys) {
  return (a10, b10) => {
    return findIndex(keys, a10) - findIndex(keys, b10);
  };
}
var init_sortByKeyOrder = __esm({
  "../../node_modules/yup/es/util/sortByKeyOrder.js"() {
  }
});

// ../../node_modules/yup/es/object.js
function _extends4() {
  _extends4 = Object.assign || function(target) {
    for (var i10 = 1; i10 < arguments.length; i10++) {
      var source = arguments[i10];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends4.apply(this, arguments);
}
function unknown(ctx, value) {
  let known = Object.keys(ctx.fields);
  return Object.keys(value).filter((key) => known.indexOf(key) === -1);
}
function create7(spec) {
  return new ObjectSchema(spec);
}
var import_has3, import_snakeCase, import_camelCase, import_mapKeys, import_mapValues2, import_property_expr4, isObject, defaultSort, ObjectSchema;
var init_object = __esm({
  "../../node_modules/yup/es/object.js"() {
    import_has3 = __toESM(require_has());
    import_snakeCase = __toESM(require_snakeCase());
    import_camelCase = __toESM(require_camelCase());
    import_mapKeys = __toESM(require_mapKeys());
    import_mapValues2 = __toESM(require_mapValues());
    import_property_expr4 = __toESM(require_property_expr());
    init_locale();
    init_sortFields();
    init_sortByKeyOrder();
    init_runTests();
    init_ValidationError();
    init_schema();
    isObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]";
    defaultSort = sortByKeyOrder([]);
    ObjectSchema = class extends BaseSchema {
      constructor(spec) {
        super({
          type: "object"
        });
        this.fields = /* @__PURE__ */ Object.create(null);
        this._sortErrors = defaultSort;
        this._nodes = [];
        this._excludedEdges = [];
        this.withMutation(() => {
          this.transform(function coerce(value) {
            if (typeof value === "string") {
              try {
                value = JSON.parse(value);
              } catch (err) {
                value = null;
              }
            }
            if (this.isType(value))
              return value;
            return null;
          });
          if (spec) {
            this.shape(spec);
          }
        });
      }
      _typeCheck(value) {
        return isObject(value) || typeof value === "function";
      }
      _cast(_value, options = {}) {
        var _options$stripUnknown;
        let value = super._cast(_value, options);
        if (value === void 0)
          return this.getDefault();
        if (!this._typeCheck(value))
          return value;
        let fields = this.fields;
        let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
        let props = this._nodes.concat(Object.keys(value).filter((v7) => this._nodes.indexOf(v7) === -1));
        let intermediateValue = {};
        let innerOptions = _extends4({}, options, {
          parent: intermediateValue,
          __validating: options.__validating || false
        });
        let isChanged = false;
        for (const prop of props) {
          let field = fields[prop];
          let exists = (0, import_has3.default)(value, prop);
          if (field) {
            let fieldValue;
            let inputValue = value[prop];
            innerOptions.path = (options.path ? `${options.path}.` : "") + prop;
            field = field.resolve({
              value: inputValue,
              context: options.context,
              parent: intermediateValue
            });
            let fieldSpec = "spec" in field ? field.spec : void 0;
            let strict = fieldSpec == null ? void 0 : fieldSpec.strict;
            if (fieldSpec == null ? void 0 : fieldSpec.strip) {
              isChanged = isChanged || prop in value;
              continue;
            }
            fieldValue = !options.__validating || !strict ? (
              // TODO: use _cast, this is double resolving
              field.cast(value[prop], innerOptions)
            ) : value[prop];
            if (fieldValue !== void 0) {
              intermediateValue[prop] = fieldValue;
            }
          } else if (exists && !strip) {
            intermediateValue[prop] = value[prop];
          }
          if (intermediateValue[prop] !== value[prop]) {
            isChanged = true;
          }
        }
        return isChanged ? intermediateValue : value;
      }
      _validate(_value, opts = {}, callback) {
        let errors = [];
        let {
          sync,
          from = [],
          originalValue = _value,
          abortEarly = this.spec.abortEarly,
          recursive = this.spec.recursive
        } = opts;
        from = [{
          schema: this,
          value: originalValue
        }, ...from];
        opts.__validating = true;
        opts.originalValue = originalValue;
        opts.from = from;
        super._validate(_value, opts, (err, value) => {
          if (err) {
            if (!ValidationError.isError(err) || abortEarly) {
              return void callback(err, value);
            }
            errors.push(err);
          }
          if (!recursive || !isObject(value)) {
            callback(errors[0] || null, value);
            return;
          }
          originalValue = originalValue || value;
          let tests = this._nodes.map((key) => (_, cb2) => {
            let path = key.indexOf(".") === -1 ? (opts.path ? `${opts.path}.` : "") + key : `${opts.path || ""}["${key}"]`;
            let field = this.fields[key];
            if (field && "validate" in field) {
              field.validate(value[key], _extends4({}, opts, {
                // @ts-ignore
                path,
                from,
                // inner fields are always strict:
                // 1. this isn't strict so the casting will also have cast inner values
                // 2. this is strict in which case the nested values weren't cast either
                strict: true,
                parent: value,
                originalValue: originalValue[key]
              }), cb2);
              return;
            }
            cb2(null);
          });
          runTests({
            sync,
            tests,
            value,
            errors,
            endEarly: abortEarly,
            sort: this._sortErrors,
            path: opts.path
          }, callback);
        });
      }
      clone(spec) {
        const next = super.clone(spec);
        next.fields = _extends4({}, this.fields);
        next._nodes = this._nodes;
        next._excludedEdges = this._excludedEdges;
        next._sortErrors = this._sortErrors;
        return next;
      }
      concat(schema) {
        let next = super.concat(schema);
        let nextFields = next.fields;
        for (let [field, schemaOrRef] of Object.entries(this.fields)) {
          const target = nextFields[field];
          if (target === void 0) {
            nextFields[field] = schemaOrRef;
          } else if (target instanceof BaseSchema && schemaOrRef instanceof BaseSchema) {
            nextFields[field] = schemaOrRef.concat(target);
          }
        }
        return next.withMutation(() => next.shape(nextFields));
      }
      getDefaultFromShape() {
        let dft = {};
        this._nodes.forEach((key) => {
          const field = this.fields[key];
          dft[key] = "default" in field ? field.getDefault() : void 0;
        });
        return dft;
      }
      _getDefault() {
        if ("default" in this.spec) {
          return super._getDefault();
        }
        if (!this._nodes.length) {
          return void 0;
        }
        return this.getDefaultFromShape();
      }
      shape(additions, excludes = []) {
        let next = this.clone();
        let fields = Object.assign(next.fields, additions);
        next.fields = fields;
        next._sortErrors = sortByKeyOrder(Object.keys(fields));
        if (excludes.length) {
          if (!Array.isArray(excludes[0]))
            excludes = [excludes];
          let keys = excludes.map(([first, second]) => `${first}-${second}`);
          next._excludedEdges = next._excludedEdges.concat(keys);
        }
        next._nodes = sortFields(fields, next._excludedEdges);
        return next;
      }
      pick(keys) {
        const picked = {};
        for (const key of keys) {
          if (this.fields[key])
            picked[key] = this.fields[key];
        }
        return this.clone().withMutation((next) => {
          next.fields = {};
          return next.shape(picked);
        });
      }
      omit(keys) {
        const next = this.clone();
        const fields = next.fields;
        next.fields = {};
        for (const key of keys) {
          delete fields[key];
        }
        return next.withMutation(() => next.shape(fields));
      }
      from(from, to, alias) {
        let fromGetter = (0, import_property_expr4.getter)(from, true);
        return this.transform((obj) => {
          if (obj == null)
            return obj;
          let newObj = obj;
          if ((0, import_has3.default)(obj, from)) {
            newObj = _extends4({}, obj);
            if (!alias)
              delete newObj[from];
            newObj[to] = fromGetter(obj);
          }
          return newObj;
        });
      }
      noUnknown(noAllow = true, message = object.noUnknown) {
        if (typeof noAllow === "string") {
          message = noAllow;
          noAllow = true;
        }
        let next = this.test({
          name: "noUnknown",
          exclusive: true,
          message,
          test(value) {
            if (value == null)
              return true;
            const unknownKeys = unknown(this.schema, value);
            return !noAllow || unknownKeys.length === 0 || this.createError({
              params: {
                unknown: unknownKeys.join(", ")
              }
            });
          }
        });
        next.spec.noUnknown = noAllow;
        return next;
      }
      unknown(allow = true, message = object.noUnknown) {
        return this.noUnknown(!allow, message);
      }
      transformKeys(fn) {
        return this.transform((obj) => obj && (0, import_mapKeys.default)(obj, (_, key) => fn(key)));
      }
      camelCase() {
        return this.transformKeys(import_camelCase.default);
      }
      snakeCase() {
        return this.transformKeys(import_snakeCase.default);
      }
      constantCase() {
        return this.transformKeys((key) => (0, import_snakeCase.default)(key).toUpperCase());
      }
      describe() {
        let base = super.describe();
        base.fields = (0, import_mapValues2.default)(this.fields, (value) => value.describe());
        return base;
      }
    };
    create7.prototype = ObjectSchema.prototype;
  }
});

// ../../node_modules/yup/es/array.js
function _extends5() {
  _extends5 = Object.assign || function(target) {
    for (var i10 = 1; i10 < arguments.length; i10++) {
      var source = arguments[i10];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends5.apply(this, arguments);
}
function create8(type) {
  return new ArraySchema(type);
}
var ArraySchema;
var init_array = __esm({
  "../../node_modules/yup/es/array.js"() {
    init_isAbsent();
    init_isSchema();
    init_printValue();
    init_locale();
    init_runTests();
    init_ValidationError();
    init_schema();
    ArraySchema = class extends BaseSchema {
      constructor(type) {
        super({
          type: "array"
        });
        this.innerType = type;
        this.withMutation(() => {
          this.transform(function(values) {
            if (typeof values === "string")
              try {
                values = JSON.parse(values);
              } catch (err) {
                values = null;
              }
            return this.isType(values) ? values : null;
          });
        });
      }
      _typeCheck(v7) {
        return Array.isArray(v7);
      }
      get _subType() {
        return this.innerType;
      }
      _cast(_value, _opts) {
        const value = super._cast(_value, _opts);
        if (!this._typeCheck(value) || !this.innerType)
          return value;
        let isChanged = false;
        const castArray = value.map((v7, idx) => {
          const castElement = this.innerType.cast(v7, _extends5({}, _opts, {
            path: `${_opts.path || ""}[${idx}]`
          }));
          if (castElement !== v7) {
            isChanged = true;
          }
          return castElement;
        });
        return isChanged ? castArray : value;
      }
      _validate(_value, options = {}, callback) {
        var _options$abortEarly, _options$recursive;
        let errors = [];
        let sync = options.sync;
        let path = options.path;
        let innerType = this.innerType;
        let endEarly = (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly;
        let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;
        let originalValue = options.originalValue != null ? options.originalValue : _value;
        super._validate(_value, options, (err, value) => {
          if (err) {
            if (!ValidationError.isError(err) || endEarly) {
              return void callback(err, value);
            }
            errors.push(err);
          }
          if (!recursive || !innerType || !this._typeCheck(value)) {
            callback(errors[0] || null, value);
            return;
          }
          originalValue = originalValue || value;
          let tests = new Array(value.length);
          for (let idx = 0; idx < value.length; idx++) {
            let item = value[idx];
            let path2 = `${options.path || ""}[${idx}]`;
            let innerOptions = _extends5({}, options, {
              path: path2,
              strict: true,
              parent: value,
              index: idx,
              originalValue: originalValue[idx]
            });
            tests[idx] = (_, cb2) => innerType.validate(item, innerOptions, cb2);
          }
          runTests({
            sync,
            path,
            value,
            errors,
            endEarly,
            tests
          }, callback);
        });
      }
      clone(spec) {
        const next = super.clone(spec);
        next.innerType = this.innerType;
        return next;
      }
      concat(schema) {
        let next = super.concat(schema);
        next.innerType = this.innerType;
        if (schema.innerType)
          next.innerType = next.innerType ? (
            // @ts-expect-error Lazy doesn't have concat()
            next.innerType.concat(schema.innerType)
          ) : schema.innerType;
        return next;
      }
      of(schema) {
        let next = this.clone();
        if (!isSchema_default(schema))
          throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + printValue(schema));
        next.innerType = schema;
        return next;
      }
      length(length, message = array.length) {
        return this.test({
          message,
          name: "length",
          exclusive: true,
          params: {
            length
          },
          test(value) {
            return isAbsent_default(value) || value.length === this.resolve(length);
          }
        });
      }
      min(min, message) {
        message = message || array.min;
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            min
          },
          // FIXME(ts): Array<typeof T>
          test(value) {
            return isAbsent_default(value) || value.length >= this.resolve(min);
          }
        });
      }
      max(max, message) {
        message = message || array.max;
        return this.test({
          message,
          name: "max",
          exclusive: true,
          params: {
            max
          },
          test(value) {
            return isAbsent_default(value) || value.length <= this.resolve(max);
          }
        });
      }
      ensure() {
        return this.default(() => []).transform((val, original) => {
          if (this._typeCheck(val))
            return val;
          return original == null ? [] : [].concat(original);
        });
      }
      compact(rejector) {
        let reject = !rejector ? (v7) => !!v7 : (v7, i10, a10) => !rejector(v7, i10, a10);
        return this.transform((values) => values != null ? values.filter(reject) : values);
      }
      describe() {
        let base = super.describe();
        if (this.innerType)
          base.innerType = this.innerType.describe();
        return base;
      }
      nullable(isNullable = true) {
        return super.nullable(isNullable);
      }
      defined() {
        return super.defined();
      }
      required(msg) {
        return super.required(msg);
      }
    };
    create8.prototype = ArraySchema.prototype;
  }
});

// ../../node_modules/yup/es/Lazy.js
function create9(builder) {
  return new Lazy(builder);
}
var Lazy;
var init_Lazy = __esm({
  "../../node_modules/yup/es/Lazy.js"() {
    init_isSchema();
    Lazy = class {
      constructor(builder) {
        this.type = "lazy";
        this.__isYupSchema__ = true;
        this._resolve = (value, options = {}) => {
          let schema = this.builder(value, options);
          if (!isSchema_default(schema))
            throw new TypeError("lazy() functions must return a valid schema");
          return schema.resolve(options);
        };
        this.builder = builder;
      }
      resolve(options) {
        return this._resolve(options.value, options);
      }
      cast(value, options) {
        return this._resolve(value, options).cast(value, options);
      }
      validate(value, options, maybeCb) {
        return this._resolve(value, options).validate(value, options, maybeCb);
      }
      validateSync(value, options) {
        return this._resolve(value, options).validateSync(value, options);
      }
      validateAt(path, value, options) {
        return this._resolve(value, options).validateAt(path, value, options);
      }
      validateSyncAt(path, value, options) {
        return this._resolve(value, options).validateSyncAt(path, value, options);
      }
      describe() {
        return null;
      }
      isValid(value, options) {
        return this._resolve(value, options).isValid(value, options);
      }
      isValidSync(value, options) {
        return this._resolve(value, options).isValidSync(value, options);
      }
    };
  }
});

// ../../node_modules/yup/es/setLocale.js
function setLocale(custom) {
  Object.keys(custom).forEach((type) => {
    Object.keys(custom[type]).forEach((method) => {
      locale_default[type][method] = custom[type][method];
    });
  });
}
var init_setLocale = __esm({
  "../../node_modules/yup/es/setLocale.js"() {
    init_locale();
  }
});

// ../../node_modules/yup/es/index.js
var es_exports = {};
__export(es_exports, {
  ArraySchema: () => ArraySchema,
  BaseSchema: () => BaseSchema,
  BooleanSchema: () => BooleanSchema,
  DateSchema: () => DateSchema,
  MixedSchema: () => mixed_default,
  NumberSchema: () => NumberSchema,
  ObjectSchema: () => ObjectSchema,
  StringSchema: () => StringSchema,
  ValidationError: () => ValidationError,
  addMethod: () => addMethod,
  array: () => create8,
  bool: () => create3,
  boolean: () => create3,
  date: () => create6,
  isSchema: () => isSchema_default,
  lazy: () => create9,
  mixed: () => create2,
  number: () => create5,
  object: () => create7,
  reach: () => reach_default,
  ref: () => create,
  setLocale: () => setLocale,
  string: () => create4
});
function addMethod(schemaType, name, fn) {
  if (!schemaType || !isSchema_default(schemaType.prototype))
    throw new TypeError("You must provide a yup schema constructor function");
  if (typeof name !== "string")
    throw new TypeError("A Method name must be provided");
  if (typeof fn !== "function")
    throw new TypeError("Method function must be provided");
  schemaType.prototype[name] = fn;
}
var init_es = __esm({
  "../../node_modules/yup/es/index.js"() {
    init_mixed();
    init_boolean();
    init_string();
    init_number();
    init_date();
    init_object();
    init_array();
    init_Reference();
    init_Lazy();
    init_ValidationError();
    init_reach();
    init_isSchema();
    init_setLocale();
    init_schema();
  }
});

// ../../node_modules/cron-validate/lib/presets.js
var require_presets = __commonJS({
  "../../node_modules/cron-validate/lib/presets.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var option_1 = require_option();
    exports.default = () => {
      (0, option_1.registerOptionPreset)("npm-node-cron", {
        // https://github.com/kelektiv/node-cron
        presetId: "npm-node-cron",
        useSeconds: true,
        useYears: false,
        useAliases: true,
        useBlankDay: false,
        allowOnlyOneBlankDayField: false,
        mustHaveBlankDayField: false,
        useLastDayOfMonth: false,
        useLastDayOfWeek: false,
        useNearestWeekday: false,
        useNthWeekdayOfMonth: false,
        seconds: {
          minValue: 0,
          maxValue: 59
        },
        minutes: {
          minValue: 0,
          maxValue: 59
        },
        hours: {
          minValue: 0,
          maxValue: 23
        },
        daysOfMonth: {
          minValue: 1,
          maxValue: 31
        },
        months: {
          minValue: 0,
          maxValue: 11
        },
        daysOfWeek: {
          minValue: 0,
          maxValue: 6
        },
        years: {
          minValue: 1970,
          maxValue: 2099
        }
      });
      (0, option_1.registerOptionPreset)("aws-cloud-watch", {
        // https://docs.aws.amazon.com/de_de/AmazonCloudWatch/latest/events/ScheduledEvents.html
        presetId: "aws-cloud-watch",
        useSeconds: false,
        useYears: true,
        useAliases: true,
        useBlankDay: true,
        allowOnlyOneBlankDayField: true,
        mustHaveBlankDayField: true,
        useLastDayOfMonth: true,
        useLastDayOfWeek: true,
        useNearestWeekday: true,
        useNthWeekdayOfMonth: true,
        seconds: {
          minValue: 0,
          maxValue: 59
        },
        minutes: {
          minValue: 0,
          maxValue: 59
        },
        hours: {
          minValue: 0,
          maxValue: 23
        },
        daysOfMonth: {
          minValue: 1,
          maxValue: 31
        },
        months: {
          minValue: 1,
          maxValue: 12
        },
        daysOfWeek: {
          minValue: 1,
          maxValue: 7
        },
        years: {
          minValue: 1970,
          maxValue: 2199
        }
      });
      (0, option_1.registerOptionPreset)("npm-cron-schedule", {
        // https://github.com/P4sca1/cron-schedule
        presetId: "npm-cron-schedule",
        useSeconds: true,
        useYears: false,
        useAliases: true,
        useBlankDay: false,
        allowOnlyOneBlankDayField: false,
        mustHaveBlankDayField: false,
        useLastDayOfMonth: false,
        useLastDayOfWeek: false,
        useNearestWeekday: false,
        useNthWeekdayOfMonth: false,
        seconds: {
          minValue: 0,
          maxValue: 59
        },
        minutes: {
          minValue: 0,
          maxValue: 59
        },
        hours: {
          minValue: 0,
          maxValue: 23
        },
        daysOfMonth: {
          minValue: 1,
          maxValue: 31
        },
        months: {
          minValue: 1,
          maxValue: 12
        },
        daysOfWeek: {
          minValue: 0,
          maxValue: 7
        },
        years: {
          minValue: 1970,
          maxValue: 2099
        }
      });
    };
  }
});

// ../../node_modules/cron-validate/lib/option.js
var require_option = __commonJS({
  "../../node_modules/cron-validate/lib/option.js"(exports) {
    "use strict";
    var __createBinding3 = exports && exports.__createBinding || (Object.create ? function(o10, m10, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      var desc = Object.getOwnPropertyDescriptor(m10, k10);
      if (!desc || ("get" in desc ? !m10.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m10[k10];
        } };
      }
      Object.defineProperty(o10, k22, desc);
    } : function(o10, m10, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      o10[k22] = m10[k10];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o10, v7) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v7 });
    } : function(o10, v7) {
      o10["default"] = v7;
    });
    var __importStar3 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k10 in mod)
          if (k10 !== "default" && Object.prototype.hasOwnProperty.call(mod, k10))
            __createBinding3(result, mod, k10);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateOptions = exports.registerOptionPreset = exports.getOptionPresets = exports.getOptionPreset = void 0;
    var yup = __importStar3((init_es(), __toCommonJS(es_exports)));
    init_es();
    var result_1 = require_result();
    var presets_1 = __importDefault3(require_presets());
    require_types();
    var optionPresets = {
      // http://crontab.org/
      default: {
        presetId: "default",
        useSeconds: false,
        useYears: false,
        useAliases: false,
        useBlankDay: false,
        allowOnlyOneBlankDayField: false,
        mustHaveBlankDayField: false,
        useLastDayOfMonth: false,
        useLastDayOfWeek: false,
        useNearestWeekday: false,
        useNthWeekdayOfMonth: false,
        seconds: {
          minValue: 0,
          maxValue: 59
        },
        minutes: {
          minValue: 0,
          maxValue: 59
        },
        hours: {
          minValue: 0,
          maxValue: 23
        },
        daysOfMonth: {
          minValue: 0,
          maxValue: 31
        },
        months: {
          minValue: 0,
          maxValue: 12
        },
        daysOfWeek: {
          minValue: 0,
          maxValue: 7
        },
        years: {
          minValue: 1970,
          maxValue: 2099
        }
      }
    };
    var optionPresetSchema = yup.object({
      presetId: yup.string().required(),
      useSeconds: yup.boolean().required(),
      useYears: yup.boolean().required(),
      useAliases: yup.boolean(),
      useBlankDay: yup.boolean().required(),
      allowOnlyOneBlankDayField: yup.boolean().required(),
      mustHaveBlankDayField: yup.boolean(),
      useLastDayOfMonth: yup.boolean(),
      useLastDayOfWeek: yup.boolean(),
      useNearestWeekday: yup.boolean(),
      useNthWeekdayOfMonth: yup.boolean(),
      seconds: yup.object({
        minValue: yup.number().min(0).required(),
        maxValue: yup.number().min(0).required(),
        lowerLimit: yup.number().min(0),
        upperLimit: yup.number().min(0)
      }).required(),
      minutes: yup.object({
        minValue: yup.number().min(0).required(),
        maxValue: yup.number().min(0).required(),
        lowerLimit: yup.number().min(0),
        upperLimit: yup.number().min(0)
      }).required(),
      hours: yup.object({
        minValue: yup.number().min(0).required(),
        maxValue: yup.number().min(0).required(),
        lowerLimit: yup.number().min(0),
        upperLimit: yup.number().min(0)
      }).required(),
      daysOfMonth: yup.object({
        minValue: yup.number().min(0).required(),
        maxValue: yup.number().min(0).required(),
        lowerLimit: yup.number().min(0),
        upperLimit: yup.number().min(0)
      }).required(),
      months: yup.object({
        minValue: yup.number().min(0).required(),
        maxValue: yup.number().min(0).required(),
        lowerLimit: yup.number().min(0),
        upperLimit: yup.number().min(0)
      }).required(),
      daysOfWeek: yup.object({
        minValue: yup.number().min(0).required(),
        maxValue: yup.number().min(0).required(),
        lowerLimit: yup.number().min(0),
        upperLimit: yup.number().min(0)
      }).required(),
      years: yup.object({
        minValue: yup.number().min(0).required(),
        maxValue: yup.number().min(0).required(),
        lowerLimit: yup.number().min(0),
        upperLimit: yup.number().min(0)
      }).required()
    }).required();
    var getOptionPreset = (presetId) => {
      if (optionPresets[presetId]) {
        return (0, result_1.valid)(optionPresets[presetId]);
      }
      return (0, result_1.err)(`Option preset '${presetId}' not found.`);
    };
    exports.getOptionPreset = getOptionPreset;
    var getOptionPresets = () => optionPresets;
    exports.getOptionPresets = getOptionPresets;
    var registerOptionPreset = (presetName, preset) => {
      optionPresets[presetName] = optionPresetSchema.validateSync(preset, {
        strict: false,
        abortEarly: false,
        stripUnknown: true,
        recursive: true
      });
    };
    exports.registerOptionPreset = registerOptionPreset;
    var validateOptions = (inputOptions) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
      try {
        (0, presets_1.default)();
        let preset;
        if (inputOptions.preset) {
          if (typeof inputOptions.preset === "string") {
            if (!optionPresets[inputOptions.preset]) {
              return (0, result_1.err)([`Option preset ${inputOptions.preset} does not exist.`]);
            }
            preset = optionPresets[inputOptions.preset];
          } else {
            preset = inputOptions.preset;
          }
        } else {
          preset = optionPresets.default;
        }
        const unvalidatedConfig = Object.assign(Object.assign({ presetId: preset.presetId, preset }, {
          useSeconds: preset.useSeconds,
          useYears: preset.useYears,
          useAliases: (_a = preset.useAliases) !== null && _a !== void 0 ? _a : false,
          useBlankDay: preset.useBlankDay,
          allowOnlyOneBlankDayField: preset.allowOnlyOneBlankDayField,
          mustHaveBlankDayField: (_b = preset.mustHaveBlankDayField) !== null && _b !== void 0 ? _b : false,
          useLastDayOfMonth: (_c = preset.useLastDayOfMonth) !== null && _c !== void 0 ? _c : false,
          useLastDayOfWeek: (_d = preset.useLastDayOfWeek) !== null && _d !== void 0 ? _d : false,
          useNearestWeekday: (_e = preset.useNearestWeekday) !== null && _e !== void 0 ? _e : false,
          useNthWeekdayOfMonth: (_f = preset.useNthWeekdayOfMonth) !== null && _f !== void 0 ? _f : false,
          seconds: {
            lowerLimit: (_g = preset.seconds.lowerLimit) !== null && _g !== void 0 ? _g : preset.seconds.minValue,
            upperLimit: (_h = preset.seconds.upperLimit) !== null && _h !== void 0 ? _h : preset.seconds.maxValue
          },
          minutes: {
            lowerLimit: (_j = preset.minutes.lowerLimit) !== null && _j !== void 0 ? _j : preset.minutes.minValue,
            upperLimit: (_k = preset.minutes.upperLimit) !== null && _k !== void 0 ? _k : preset.minutes.maxValue
          },
          hours: {
            lowerLimit: (_l = preset.hours.lowerLimit) !== null && _l !== void 0 ? _l : preset.hours.minValue,
            upperLimit: (_m = preset.hours.upperLimit) !== null && _m !== void 0 ? _m : preset.hours.maxValue
          },
          daysOfMonth: {
            lowerLimit: (_o = preset.daysOfMonth.lowerLimit) !== null && _o !== void 0 ? _o : preset.daysOfMonth.minValue,
            upperLimit: (_p = preset.daysOfMonth.upperLimit) !== null && _p !== void 0 ? _p : preset.daysOfMonth.maxValue
          },
          months: {
            lowerLimit: (_q = preset.months.lowerLimit) !== null && _q !== void 0 ? _q : preset.months.minValue,
            upperLimit: (_r = preset.months.upperLimit) !== null && _r !== void 0 ? _r : preset.months.maxValue
          },
          daysOfWeek: {
            lowerLimit: (_s = preset.daysOfWeek.lowerLimit) !== null && _s !== void 0 ? _s : preset.daysOfWeek.minValue,
            upperLimit: (_t = preset.daysOfWeek.upperLimit) !== null && _t !== void 0 ? _t : preset.daysOfWeek.maxValue
          },
          years: {
            lowerLimit: (_u = preset.years.lowerLimit) !== null && _u !== void 0 ? _u : preset.years.minValue,
            upperLimit: (_v = preset.years.upperLimit) !== null && _v !== void 0 ? _v : preset.years.maxValue
          }
        }), inputOptions.override);
        const optionsSchema = yup.object({
          presetId: yup.string().required(),
          preset: optionPresetSchema.required(),
          useSeconds: yup.boolean().required(),
          useYears: yup.boolean().required(),
          useAliases: yup.boolean(),
          useBlankDay: yup.boolean().required(),
          allowOnlyOneBlankDayField: yup.boolean().required(),
          mustHaveBlankDayField: yup.boolean(),
          useLastDayOfMonth: yup.boolean(),
          useLastDayOfWeek: yup.boolean(),
          useNearestWeekday: yup.boolean(),
          useNthWeekdayOfMonth: yup.boolean(),
          seconds: yup.object({
            lowerLimit: yup.number().min(preset.seconds.minValue).max(preset.seconds.maxValue),
            upperLimit: yup.number().min(preset.seconds.minValue).max(preset.seconds.maxValue)
          }).required(),
          minutes: yup.object({
            lowerLimit: yup.number().min(preset.minutes.minValue).max(preset.minutes.maxValue),
            upperLimit: yup.number().min(preset.minutes.minValue).max(preset.minutes.maxValue)
          }).required(),
          hours: yup.object({
            lowerLimit: yup.number().min(preset.hours.minValue).max(preset.hours.maxValue),
            upperLimit: yup.number().min(preset.hours.minValue).max(preset.hours.maxValue)
          }).required(),
          daysOfMonth: yup.object({
            lowerLimit: yup.number().min(preset.daysOfMonth.minValue).max(preset.daysOfMonth.maxValue),
            upperLimit: yup.number().min(preset.daysOfMonth.minValue).max(preset.daysOfMonth.maxValue)
          }).required(),
          months: yup.object({
            lowerLimit: yup.number().min(preset.months.minValue).max(preset.months.maxValue),
            upperLimit: yup.number().min(preset.months.minValue).max(preset.months.maxValue)
          }).required(),
          daysOfWeek: yup.object({
            lowerLimit: yup.number().min(preset.daysOfWeek.minValue).max(preset.daysOfWeek.maxValue),
            upperLimit: yup.number().min(preset.daysOfWeek.minValue).max(preset.daysOfWeek.maxValue)
          }).required(),
          years: yup.object({
            lowerLimit: yup.number().min(preset.years.minValue).max(preset.years.maxValue),
            upperLimit: yup.number().min(preset.years.minValue).max(preset.years.maxValue)
          }).required()
        }).required();
        const validatedConfig = optionsSchema.validateSync(unvalidatedConfig, {
          strict: false,
          abortEarly: false,
          stripUnknown: true,
          recursive: true
        });
        return (0, result_1.valid)(validatedConfig);
      } catch (validationError) {
        return (0, result_1.err)(validationError.errors);
      }
    };
    exports.validateOptions = validateOptions;
  }
});

// ../../node_modules/cron-validate/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/cron-validate/lib/index.js"(exports, module2) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var result_1 = require_result();
    var secondChecker_1 = __importDefault3(require_secondChecker());
    var minuteChecker_1 = __importDefault3(require_minuteChecker());
    var hourChecker_1 = __importDefault3(require_hourChecker());
    var dayOfMonthChecker_1 = __importDefault3(require_dayOfMonthChecker());
    var monthChecker_1 = __importDefault3(require_monthChecker());
    var dayOfWeekChecker_1 = __importDefault3(require_dayOfWeekChecker());
    var yearChecker_1 = __importDefault3(require_yearChecker());
    var option_1 = require_option();
    require_types();
    var splitCronString = (cronString, options) => {
      const splittedCronString = cronString.trim().split(" ");
      if (options.useSeconds && options.useYears && splittedCronString.length !== 7) {
        return (0, result_1.err)(`Expected 7 values, but got ${splittedCronString.length}.`);
      }
      if ((options.useSeconds && !options.useYears || options.useYears && !options.useSeconds) && splittedCronString.length !== 6) {
        return (0, result_1.err)(`Expected 6 values, but got ${splittedCronString.length}.`);
      }
      if (!options.useSeconds && !options.useYears && splittedCronString.length !== 5) {
        return (0, result_1.err)(`Expected 5 values, but got ${splittedCronString.length}.`);
      }
      const cronData = {
        seconds: options.useSeconds ? splittedCronString[0] : void 0,
        minutes: splittedCronString[options.useSeconds ? 1 : 0],
        hours: splittedCronString[options.useSeconds ? 2 : 1],
        daysOfMonth: splittedCronString[options.useSeconds ? 3 : 2],
        months: splittedCronString[options.useSeconds ? 4 : 3],
        daysOfWeek: splittedCronString[options.useSeconds ? 5 : 4],
        years: options.useYears ? splittedCronString[options.useSeconds ? 6 : 5] : void 0
      };
      return (0, result_1.valid)(cronData);
    };
    var cron2 = (cronString, inputOptions = {}) => {
      const optionsResult = (0, option_1.validateOptions)(inputOptions);
      if (optionsResult.isError()) {
        return optionsResult;
      }
      const options = optionsResult.getValue();
      const cronDataResult = splitCronString(cronString, options);
      if (cronDataResult.isError()) {
        return (0, result_1.err)([`${cronDataResult.getError()} (Input cron: '${cronString}')`]);
      }
      const cronData = cronDataResult.getValue();
      const checkResults = [];
      if (options.useSeconds) {
        checkResults.push((0, secondChecker_1.default)(cronData, options));
      }
      checkResults.push((0, minuteChecker_1.default)(cronData, options));
      checkResults.push((0, hourChecker_1.default)(cronData, options));
      checkResults.push((0, dayOfMonthChecker_1.default)(cronData, options));
      checkResults.push((0, monthChecker_1.default)(cronData, options));
      checkResults.push((0, dayOfWeekChecker_1.default)(cronData, options));
      if (options.useYears) {
        checkResults.push((0, yearChecker_1.default)(cronData, options));
      }
      if (checkResults.every((value) => value.isValid())) {
        return (0, result_1.valid)(cronData);
      }
      const errorArray = [];
      checkResults.forEach((result) => {
        if (result.isError()) {
          result.getError().forEach((error) => {
            errorArray.push(error);
          });
        }
      });
      errorArray.forEach((error, index) => {
        errorArray[index] = `${error} (Input cron: '${cronString}')`;
      });
      return (0, result_1.err)(errorArray);
    };
    exports.default = cron2;
    module2.exports = cron2;
    module2.exports.default = cron2;
  }
});

// ../../node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "../../node_modules/dayjs/dayjs.min.js"(exports, module2) {
    !function(t6, e10) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = e10() : "function" == typeof define && define.amd ? define(e10) : (t6 = "undefined" != typeof globalThis ? globalThis : t6 || self).dayjs = e10();
    }(exports, function() {
      "use strict";
      var t6 = 1e3, e10 = 6e4, n10 = 36e5, r10 = "millisecond", i10 = "second", s10 = "minute", u6 = "hour", a10 = "day", o10 = "week", f10 = "month", h10 = "quarter", c10 = "year", d10 = "date", l10 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y4 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M4 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t7) {
        var e11 = ["th", "st", "nd", "rd"], n11 = t7 % 100;
        return "[" + t7 + (e11[(n11 - 20) % 10] || e11[n11] || e11[0]) + "]";
      } }, m10 = function(t7, e11, n11) {
        var r11 = String(t7);
        return !r11 || r11.length >= e11 ? t7 : "" + Array(e11 + 1 - r11.length).join(n11) + t7;
      }, v7 = { s: m10, z: function(t7) {
        var e11 = -t7.utcOffset(), n11 = Math.abs(e11), r11 = Math.floor(n11 / 60), i11 = n11 % 60;
        return (e11 <= 0 ? "+" : "-") + m10(r11, 2, "0") + ":" + m10(i11, 2, "0");
      }, m: function t7(e11, n11) {
        if (e11.date() < n11.date())
          return -t7(n11, e11);
        var r11 = 12 * (n11.year() - e11.year()) + (n11.month() - e11.month()), i11 = e11.clone().add(r11, f10), s11 = n11 - i11 < 0, u7 = e11.clone().add(r11 + (s11 ? -1 : 1), f10);
        return +(-(r11 + (n11 - i11) / (s11 ? i11 - u7 : u7 - i11)) || 0);
      }, a: function(t7) {
        return t7 < 0 ? Math.ceil(t7) || 0 : Math.floor(t7);
      }, p: function(t7) {
        return { M: f10, y: c10, w: o10, d: a10, D: d10, h: u6, m: s10, s: i10, ms: r10, Q: h10 }[t7] || String(t7 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t7) {
        return void 0 === t7;
      } }, g10 = "en", D4 = {};
      D4[g10] = M4;
      var p10 = function(t7) {
        return t7 instanceof _;
      }, S2 = function t7(e11, n11, r11) {
        var i11;
        if (!e11)
          return g10;
        if ("string" == typeof e11) {
          var s11 = e11.toLowerCase();
          D4[s11] && (i11 = s11), n11 && (D4[s11] = n11, i11 = s11);
          var u7 = e11.split("-");
          if (!i11 && u7.length > 1)
            return t7(u7[0]);
        } else {
          var a11 = e11.name;
          D4[a11] = e11, i11 = a11;
        }
        return !r11 && i11 && (g10 = i11), i11 || !r11 && g10;
      }, w5 = function(t7, e11) {
        if (p10(t7))
          return t7.clone();
        var n11 = "object" == typeof e11 ? e11 : {};
        return n11.date = t7, n11.args = arguments, new _(n11);
      }, O2 = v7;
      O2.l = S2, O2.i = p10, O2.w = function(t7, e11) {
        return w5(t7, { locale: e11.$L, utc: e11.$u, x: e11.$x, $offset: e11.$offset });
      };
      var _ = function() {
        function M5(t7) {
          this.$L = S2(t7.locale, null, true), this.parse(t7);
        }
        var m11 = M5.prototype;
        return m11.parse = function(t7) {
          this.$d = function(t8) {
            var e11 = t8.date, n11 = t8.utc;
            if (null === e11)
              return /* @__PURE__ */ new Date(NaN);
            if (O2.u(e11))
              return /* @__PURE__ */ new Date();
            if (e11 instanceof Date)
              return new Date(e11);
            if ("string" == typeof e11 && !/Z$/i.test(e11)) {
              var r11 = e11.match($);
              if (r11) {
                var i11 = r11[2] - 1 || 0, s11 = (r11[7] || "0").substring(0, 3);
                return n11 ? new Date(Date.UTC(r11[1], i11, r11[3] || 1, r11[4] || 0, r11[5] || 0, r11[6] || 0, s11)) : new Date(r11[1], i11, r11[3] || 1, r11[4] || 0, r11[5] || 0, r11[6] || 0, s11);
              }
            }
            return new Date(e11);
          }(t7), this.$x = t7.x || {}, this.init();
        }, m11.init = function() {
          var t7 = this.$d;
          this.$y = t7.getFullYear(), this.$M = t7.getMonth(), this.$D = t7.getDate(), this.$W = t7.getDay(), this.$H = t7.getHours(), this.$m = t7.getMinutes(), this.$s = t7.getSeconds(), this.$ms = t7.getMilliseconds();
        }, m11.$utils = function() {
          return O2;
        }, m11.isValid = function() {
          return !(this.$d.toString() === l10);
        }, m11.isSame = function(t7, e11) {
          var n11 = w5(t7);
          return this.startOf(e11) <= n11 && n11 <= this.endOf(e11);
        }, m11.isAfter = function(t7, e11) {
          return w5(t7) < this.startOf(e11);
        }, m11.isBefore = function(t7, e11) {
          return this.endOf(e11) < w5(t7);
        }, m11.$g = function(t7, e11, n11) {
          return O2.u(t7) ? this[e11] : this.set(n11, t7);
        }, m11.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m11.valueOf = function() {
          return this.$d.getTime();
        }, m11.startOf = function(t7, e11) {
          var n11 = this, r11 = !!O2.u(e11) || e11, h11 = O2.p(t7), l11 = function(t8, e12) {
            var i11 = O2.w(n11.$u ? Date.UTC(n11.$y, e12, t8) : new Date(n11.$y, e12, t8), n11);
            return r11 ? i11 : i11.endOf(a10);
          }, $2 = function(t8, e12) {
            return O2.w(n11.toDate()[t8].apply(n11.toDate("s"), (r11 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e12)), n11);
          }, y5 = this.$W, M6 = this.$M, m12 = this.$D, v8 = "set" + (this.$u ? "UTC" : "");
          switch (h11) {
            case c10:
              return r11 ? l11(1, 0) : l11(31, 11);
            case f10:
              return r11 ? l11(1, M6) : l11(0, M6 + 1);
            case o10:
              var g11 = this.$locale().weekStart || 0, D5 = (y5 < g11 ? y5 + 7 : y5) - g11;
              return l11(r11 ? m12 - D5 : m12 + (6 - D5), M6);
            case a10:
            case d10:
              return $2(v8 + "Hours", 0);
            case u6:
              return $2(v8 + "Minutes", 1);
            case s10:
              return $2(v8 + "Seconds", 2);
            case i10:
              return $2(v8 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m11.endOf = function(t7) {
          return this.startOf(t7, false);
        }, m11.$set = function(t7, e11) {
          var n11, o11 = O2.p(t7), h11 = "set" + (this.$u ? "UTC" : ""), l11 = (n11 = {}, n11[a10] = h11 + "Date", n11[d10] = h11 + "Date", n11[f10] = h11 + "Month", n11[c10] = h11 + "FullYear", n11[u6] = h11 + "Hours", n11[s10] = h11 + "Minutes", n11[i10] = h11 + "Seconds", n11[r10] = h11 + "Milliseconds", n11)[o11], $2 = o11 === a10 ? this.$D + (e11 - this.$W) : e11;
          if (o11 === f10 || o11 === c10) {
            var y5 = this.clone().set(d10, 1);
            y5.$d[l11]($2), y5.init(), this.$d = y5.set(d10, Math.min(this.$D, y5.daysInMonth())).$d;
          } else
            l11 && this.$d[l11]($2);
          return this.init(), this;
        }, m11.set = function(t7, e11) {
          return this.clone().$set(t7, e11);
        }, m11.get = function(t7) {
          return this[O2.p(t7)]();
        }, m11.add = function(r11, h11) {
          var d11, l11 = this;
          r11 = Number(r11);
          var $2 = O2.p(h11), y5 = function(t7) {
            var e11 = w5(l11);
            return O2.w(e11.date(e11.date() + Math.round(t7 * r11)), l11);
          };
          if ($2 === f10)
            return this.set(f10, this.$M + r11);
          if ($2 === c10)
            return this.set(c10, this.$y + r11);
          if ($2 === a10)
            return y5(1);
          if ($2 === o10)
            return y5(7);
          var M6 = (d11 = {}, d11[s10] = e10, d11[u6] = n10, d11[i10] = t6, d11)[$2] || 1, m12 = this.$d.getTime() + r11 * M6;
          return O2.w(m12, this);
        }, m11.subtract = function(t7, e11) {
          return this.add(-1 * t7, e11);
        }, m11.format = function(t7) {
          var e11 = this, n11 = this.$locale();
          if (!this.isValid())
            return n11.invalidDate || l10;
          var r11 = t7 || "YYYY-MM-DDTHH:mm:ssZ", i11 = O2.z(this), s11 = this.$H, u7 = this.$m, a11 = this.$M, o11 = n11.weekdays, f11 = n11.months, h11 = function(t8, n12, i12, s12) {
            return t8 && (t8[n12] || t8(e11, r11)) || i12[n12].slice(0, s12);
          }, c11 = function(t8) {
            return O2.s(s11 % 12 || 12, t8, "0");
          }, d11 = n11.meridiem || function(t8, e12, n12) {
            var r12 = t8 < 12 ? "AM" : "PM";
            return n12 ? r12.toLowerCase() : r12;
          }, $2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a11 + 1, MM: O2.s(a11 + 1, 2, "0"), MMM: h11(n11.monthsShort, a11, f11, 3), MMMM: h11(f11, a11), D: this.$D, DD: O2.s(this.$D, 2, "0"), d: String(this.$W), dd: h11(n11.weekdaysMin, this.$W, o11, 2), ddd: h11(n11.weekdaysShort, this.$W, o11, 3), dddd: o11[this.$W], H: String(s11), HH: O2.s(s11, 2, "0"), h: c11(1), hh: c11(2), a: d11(s11, u7, true), A: d11(s11, u7, false), m: String(u7), mm: O2.s(u7, 2, "0"), s: String(this.$s), ss: O2.s(this.$s, 2, "0"), SSS: O2.s(this.$ms, 3, "0"), Z: i11 };
          return r11.replace(y4, function(t8, e12) {
            return e12 || $2[t8] || i11.replace(":", "");
          });
        }, m11.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m11.diff = function(r11, d11, l11) {
          var $2, y5 = O2.p(d11), M6 = w5(r11), m12 = (M6.utcOffset() - this.utcOffset()) * e10, v8 = this - M6, g11 = O2.m(this, M6);
          return g11 = ($2 = {}, $2[c10] = g11 / 12, $2[f10] = g11, $2[h10] = g11 / 3, $2[o10] = (v8 - m12) / 6048e5, $2[a10] = (v8 - m12) / 864e5, $2[u6] = v8 / n10, $2[s10] = v8 / e10, $2[i10] = v8 / t6, $2)[y5] || v8, l11 ? g11 : O2.a(g11);
        }, m11.daysInMonth = function() {
          return this.endOf(f10).$D;
        }, m11.$locale = function() {
          return D4[this.$L];
        }, m11.locale = function(t7, e11) {
          if (!t7)
            return this.$L;
          var n11 = this.clone(), r11 = S2(t7, e11, true);
          return r11 && (n11.$L = r11), n11;
        }, m11.clone = function() {
          return O2.w(this.$d, this);
        }, m11.toDate = function() {
          return new Date(this.valueOf());
        }, m11.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m11.toISOString = function() {
          return this.$d.toISOString();
        }, m11.toString = function() {
          return this.$d.toUTCString();
        }, M5;
      }(), T2 = _.prototype;
      return w5.prototype = T2, [["$ms", r10], ["$s", i10], ["$m", s10], ["$H", u6], ["$W", a10], ["$M", f10], ["$y", c10], ["$D", d10]].forEach(function(t7) {
        T2[t7[1]] = function(e11) {
          return this.$g(e11, t7[0], t7[1]);
        };
      }), w5.extend = function(t7, e11) {
        return t7.$i || (t7(e11, _, w5), t7.$i = true), w5;
      }, w5.locale = S2, w5.isDayjs = p10, w5.unix = function(t7) {
        return w5(1e3 * t7);
      }, w5.en = D4[g10], w5.Ls = D4, w5.p = {}, w5;
    });
  }
});

// ../../node_modules/dayjs/plugin/utc.js
var require_utc = __commonJS({
  "../../node_modules/dayjs/plugin/utc.js"(exports, module2) {
    !function(t6, i10) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = i10() : "function" == typeof define && define.amd ? define(i10) : (t6 = "undefined" != typeof globalThis ? globalThis : t6 || self).dayjs_plugin_utc = i10();
    }(exports, function() {
      "use strict";
      var t6 = "minute", i10 = /[+-]\d\d(?::?\d\d)?/g, e10 = /([+-]|\d\d)/g;
      return function(s10, f10, n10) {
        var u6 = f10.prototype;
        n10.utc = function(t7) {
          var i11 = { date: t7, utc: true, args: arguments };
          return new f10(i11);
        }, u6.utc = function(i11) {
          var e11 = n10(this.toDate(), { locale: this.$L, utc: true });
          return i11 ? e11.add(this.utcOffset(), t6) : e11;
        }, u6.local = function() {
          return n10(this.toDate(), { locale: this.$L, utc: false });
        };
        var o10 = u6.parse;
        u6.parse = function(t7) {
          t7.utc && (this.$u = true), this.$utils().u(t7.$offset) || (this.$offset = t7.$offset), o10.call(this, t7);
        };
        var r10 = u6.init;
        u6.init = function() {
          if (this.$u) {
            var t7 = this.$d;
            this.$y = t7.getUTCFullYear(), this.$M = t7.getUTCMonth(), this.$D = t7.getUTCDate(), this.$W = t7.getUTCDay(), this.$H = t7.getUTCHours(), this.$m = t7.getUTCMinutes(), this.$s = t7.getUTCSeconds(), this.$ms = t7.getUTCMilliseconds();
          } else
            r10.call(this);
        };
        var a10 = u6.utcOffset;
        u6.utcOffset = function(s11, f11) {
          var n11 = this.$utils().u;
          if (n11(s11))
            return this.$u ? 0 : n11(this.$offset) ? a10.call(this) : this.$offset;
          if ("string" == typeof s11 && (s11 = function(t7) {
            void 0 === t7 && (t7 = "");
            var s12 = t7.match(i10);
            if (!s12)
              return null;
            var f12 = ("" + s12[0]).match(e10) || ["-", 0, 0], n12 = f12[0], u8 = 60 * +f12[1] + +f12[2];
            return 0 === u8 ? 0 : "+" === n12 ? u8 : -u8;
          }(s11), null === s11))
            return this;
          var u7 = Math.abs(s11) <= 16 ? 60 * s11 : s11, o11 = this;
          if (f11)
            return o11.$offset = u7, o11.$u = 0 === s11, o11;
          if (0 !== s11) {
            var r11 = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
            (o11 = this.local().add(u7 + r11, t6)).$offset = u7, o11.$x.$localOffset = r11;
          } else
            o11 = this.utc();
          return o11;
        };
        var h10 = u6.format;
        u6.format = function(t7) {
          var i11 = t7 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
          return h10.call(this, i11);
        }, u6.valueOf = function() {
          var t7 = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
          return this.$d.valueOf() - 6e4 * t7;
        }, u6.isUTC = function() {
          return !!this.$u;
        }, u6.toISOString = function() {
          return this.toDate().toISOString();
        }, u6.toString = function() {
          return this.toDate().toUTCString();
        };
        var l10 = u6.toDate;
        u6.toDate = function(t7) {
          return "s" === t7 && this.$offset ? n10(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l10.call(this);
        };
        var c10 = u6.diff;
        u6.diff = function(t7, i11, e11) {
          if (t7 && this.$u === t7.$u)
            return c10.call(this, t7, i11, e11);
          var s11 = this.local(), f11 = n10(t7).local();
          return c10.call(s11, f11, i11, e11);
        };
      };
    });
  }
});

// ../../node_modules/fast-xml-parser/src/util.js
var require_util = __commonJS({
  "../../node_modules/fast-xml-parser/src/util.js"(exports) {
    "use strict";
    var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
    var regexName = new RegExp("^" + nameRegexp + "$");
    var getAllMatches = function(string2, regex) {
      const matches = [];
      let match = regex.exec(string2);
      while (match) {
        const allmatches = [];
        allmatches.startIndex = regex.lastIndex - match[0].length;
        const len = match.length;
        for (let index = 0; index < len; index++) {
          allmatches.push(match[index]);
        }
        matches.push(allmatches);
        match = regex.exec(string2);
      }
      return matches;
    };
    var isName = function(string2) {
      const match = regexName.exec(string2);
      return !(match === null || typeof match === "undefined");
    };
    exports.isExist = function(v7) {
      return typeof v7 !== "undefined";
    };
    exports.isEmptyObject = function(obj) {
      return Object.keys(obj).length === 0;
    };
    exports.merge = function(target, a10, arrayMode) {
      if (a10) {
        const keys = Object.keys(a10);
        const len = keys.length;
        for (let i10 = 0; i10 < len; i10++) {
          if (arrayMode === "strict") {
            target[keys[i10]] = [a10[keys[i10]]];
          } else {
            target[keys[i10]] = a10[keys[i10]];
          }
        }
      }
    };
    exports.getValue = function(v7) {
      if (exports.isExist(v7)) {
        return v7;
      } else {
        return "";
      }
    };
    exports.isName = isName;
    exports.getAllMatches = getAllMatches;
    exports.nameRegexp = nameRegexp;
  }
});

// ../../node_modules/fast-xml-parser/src/validator.js
var require_validator = __commonJS({
  "../../node_modules/fast-xml-parser/src/validator.js"(exports) {
    "use strict";
    var util = require_util();
    var defaultOptions = {
      allowBooleanAttributes: false,
      //A tag can have attributes without any value
      unpairedTags: []
    };
    exports.validate = function(xmlData, options) {
      options = Object.assign({}, defaultOptions, options);
      const tags = [];
      let tagFound = false;
      let reachedRoot = false;
      if (xmlData[0] === "\uFEFF") {
        xmlData = xmlData.substr(1);
      }
      for (let i10 = 0; i10 < xmlData.length; i10++) {
        if (xmlData[i10] === "<" && xmlData[i10 + 1] === "?") {
          i10 += 2;
          i10 = readPI(xmlData, i10);
          if (i10.err)
            return i10;
        } else if (xmlData[i10] === "<") {
          let tagStartPos = i10;
          i10++;
          if (xmlData[i10] === "!") {
            i10 = readCommentAndCDATA(xmlData, i10);
            continue;
          } else {
            let closingTag = false;
            if (xmlData[i10] === "/") {
              closingTag = true;
              i10++;
            }
            let tagName = "";
            for (; i10 < xmlData.length && xmlData[i10] !== ">" && xmlData[i10] !== " " && xmlData[i10] !== "	" && xmlData[i10] !== "\n" && xmlData[i10] !== "\r"; i10++) {
              tagName += xmlData[i10];
            }
            tagName = tagName.trim();
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substring(0, tagName.length - 1);
              i10--;
            }
            if (!validateTagName(tagName)) {
              let msg;
              if (tagName.trim().length === 0) {
                msg = "Invalid space after '<'.";
              } else {
                msg = "Tag '" + tagName + "' is an invalid name.";
              }
              return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i10));
            }
            const result = readAttributeStr(xmlData, i10);
            if (result === false) {
              return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i10));
            }
            let attrStr = result.value;
            i10 = result.index;
            if (attrStr[attrStr.length - 1] === "/") {
              const attrStrStart = i10 - attrStr.length;
              attrStr = attrStr.substring(0, attrStr.length - 1);
              const isValid = validateAttributeString(attrStr, options);
              if (isValid === true) {
                tagFound = true;
              } else {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
              }
            } else if (closingTag) {
              if (!result.tagClosed) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i10));
              } else if (attrStr.trim().length > 0) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
              } else {
                const otg = tags.pop();
                if (tagName !== otg.tagName) {
                  let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                  return getErrorObject(
                    "InvalidTag",
                    "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                    getLineNumberForPosition(xmlData, tagStartPos)
                  );
                }
                if (tags.length == 0) {
                  reachedRoot = true;
                }
              }
            } else {
              const isValid = validateAttributeString(attrStr, options);
              if (isValid !== true) {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i10 - attrStr.length + isValid.err.line));
              }
              if (reachedRoot === true) {
                return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i10));
              } else if (options.unpairedTags.indexOf(tagName) !== -1) {
              } else {
                tags.push({ tagName, tagStartPos });
              }
              tagFound = true;
            }
            for (i10++; i10 < xmlData.length; i10++) {
              if (xmlData[i10] === "<") {
                if (xmlData[i10 + 1] === "!") {
                  i10++;
                  i10 = readCommentAndCDATA(xmlData, i10);
                  continue;
                } else if (xmlData[i10 + 1] === "?") {
                  i10 = readPI(xmlData, ++i10);
                  if (i10.err)
                    return i10;
                } else {
                  break;
                }
              } else if (xmlData[i10] === "&") {
                const afterAmp = validateAmpersand(xmlData, i10);
                if (afterAmp == -1)
                  return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i10));
                i10 = afterAmp;
              } else {
                if (reachedRoot === true && !isWhiteSpace(xmlData[i10])) {
                  return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i10));
                }
              }
            }
            if (xmlData[i10] === "<") {
              i10--;
            }
          }
        } else {
          if (isWhiteSpace(xmlData[i10])) {
            continue;
          }
          return getErrorObject("InvalidChar", "char '" + xmlData[i10] + "' is not expected.", getLineNumberForPosition(xmlData, i10));
        }
      }
      if (!tagFound) {
        return getErrorObject("InvalidXml", "Start tag expected.", 1);
      } else if (tags.length == 1) {
        return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
      } else if (tags.length > 0) {
        return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t6) => t6.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
      }
      return true;
    };
    function isWhiteSpace(char) {
      return char === " " || char === "	" || char === "\n" || char === "\r";
    }
    function readPI(xmlData, i10) {
      const start = i10;
      for (; i10 < xmlData.length; i10++) {
        if (xmlData[i10] == "?" || xmlData[i10] == " ") {
          const tagname = xmlData.substr(start, i10 - start);
          if (i10 > 5 && tagname === "xml") {
            return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i10));
          } else if (xmlData[i10] == "?" && xmlData[i10 + 1] == ">") {
            i10++;
            break;
          } else {
            continue;
          }
        }
      }
      return i10;
    }
    function readCommentAndCDATA(xmlData, i10) {
      if (xmlData.length > i10 + 5 && xmlData[i10 + 1] === "-" && xmlData[i10 + 2] === "-") {
        for (i10 += 3; i10 < xmlData.length; i10++) {
          if (xmlData[i10] === "-" && xmlData[i10 + 1] === "-" && xmlData[i10 + 2] === ">") {
            i10 += 2;
            break;
          }
        }
      } else if (xmlData.length > i10 + 8 && xmlData[i10 + 1] === "D" && xmlData[i10 + 2] === "O" && xmlData[i10 + 3] === "C" && xmlData[i10 + 4] === "T" && xmlData[i10 + 5] === "Y" && xmlData[i10 + 6] === "P" && xmlData[i10 + 7] === "E") {
        let angleBracketsCount = 1;
        for (i10 += 8; i10 < xmlData.length; i10++) {
          if (xmlData[i10] === "<") {
            angleBracketsCount++;
          } else if (xmlData[i10] === ">") {
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          }
        }
      } else if (xmlData.length > i10 + 9 && xmlData[i10 + 1] === "[" && xmlData[i10 + 2] === "C" && xmlData[i10 + 3] === "D" && xmlData[i10 + 4] === "A" && xmlData[i10 + 5] === "T" && xmlData[i10 + 6] === "A" && xmlData[i10 + 7] === "[") {
        for (i10 += 8; i10 < xmlData.length; i10++) {
          if (xmlData[i10] === "]" && xmlData[i10 + 1] === "]" && xmlData[i10 + 2] === ">") {
            i10 += 2;
            break;
          }
        }
      }
      return i10;
    }
    var doubleQuote = '"';
    var singleQuote = "'";
    function readAttributeStr(xmlData, i10) {
      let attrStr = "";
      let startChar = "";
      let tagClosed = false;
      for (; i10 < xmlData.length; i10++) {
        if (xmlData[i10] === doubleQuote || xmlData[i10] === singleQuote) {
          if (startChar === "") {
            startChar = xmlData[i10];
          } else if (startChar !== xmlData[i10]) {
          } else {
            startChar = "";
          }
        } else if (xmlData[i10] === ">") {
          if (startChar === "") {
            tagClosed = true;
            break;
          }
        }
        attrStr += xmlData[i10];
      }
      if (startChar !== "") {
        return false;
      }
      return {
        value: attrStr,
        index: i10,
        tagClosed
      };
    }
    var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function validateAttributeString(attrStr, options) {
      const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
      const attrNames = {};
      for (let i10 = 0; i10 < matches.length; i10++) {
        if (matches[i10][1].length === 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i10][2] + "' has no space in starting.", getPositionFromMatch(matches[i10]));
        } else if (matches[i10][3] !== void 0 && matches[i10][4] === void 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i10][2] + "' is without value.", getPositionFromMatch(matches[i10]));
        } else if (matches[i10][3] === void 0 && !options.allowBooleanAttributes) {
          return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i10][2] + "' is not allowed.", getPositionFromMatch(matches[i10]));
        }
        const attrName = matches[i10][2];
        if (!validateAttrName(attrName)) {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i10]));
        }
        if (!attrNames.hasOwnProperty(attrName)) {
          attrNames[attrName] = 1;
        } else {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i10]));
        }
      }
      return true;
    }
    function validateNumberAmpersand(xmlData, i10) {
      let re = /\d/;
      if (xmlData[i10] === "x") {
        i10++;
        re = /[\da-fA-F]/;
      }
      for (; i10 < xmlData.length; i10++) {
        if (xmlData[i10] === ";")
          return i10;
        if (!xmlData[i10].match(re))
          break;
      }
      return -1;
    }
    function validateAmpersand(xmlData, i10) {
      i10++;
      if (xmlData[i10] === ";")
        return -1;
      if (xmlData[i10] === "#") {
        i10++;
        return validateNumberAmpersand(xmlData, i10);
      }
      let count2 = 0;
      for (; i10 < xmlData.length; i10++, count2++) {
        if (xmlData[i10].match(/\w/) && count2 < 20)
          continue;
        if (xmlData[i10] === ";")
          break;
        return -1;
      }
      return i10;
    }
    function getErrorObject(code, message, lineNumber) {
      return {
        err: {
          code,
          msg: message,
          line: lineNumber.line || lineNumber,
          col: lineNumber.col
        }
      };
    }
    function validateAttrName(attrName) {
      return util.isName(attrName);
    }
    function validateTagName(tagname) {
      return util.isName(tagname);
    }
    function getLineNumberForPosition(xmlData, index) {
      const lines = xmlData.substring(0, index).split(/\r?\n/);
      return {
        line: lines.length,
        // column number is last line's length + 1, because column numbering starts at 1:
        col: lines[lines.length - 1].length + 1
      };
    }
    function getPositionFromMatch(match) {
      return match.startIndex + match[1].length;
    }
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
    var defaultOptions = {
      preserveOrder: false,
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      removeNSPrefix: false,
      // remove NS from tag name or attribute name if true
      allowBooleanAttributes: false,
      //a tag can have attributes without any value
      //ignoreRootElement : false,
      parseTagValue: true,
      parseAttributeValue: false,
      trimValues: true,
      //Trim string values of tag and attributes
      cdataPropName: false,
      numberParseOptions: {
        hex: true,
        leadingZeros: true
      },
      tagValueProcessor: function(tagName, val) {
        return val;
      },
      attributeValueProcessor: function(attrName, val) {
        return val;
      },
      stopNodes: [],
      //nested tags will not be parsed even for errors
      alwaysCreateTextNode: false,
      isArray: () => false,
      commentPropName: false,
      unpairedTags: [],
      processEntities: true,
      htmlEntities: false,
      ignoreDeclaration: false,
      ignorePiTags: false,
      transformTagName: false
    };
    var buildOptions = function(options) {
      return Object.assign({}, defaultOptions, options);
    };
    exports.buildOptions = buildOptions;
    exports.defaultOptions = defaultOptions;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module2) {
    "use strict";
    var XmlNode2 = class {
      constructor(tagname) {
        this.tagname = tagname;
        this.child = [];
        this[":@"] = {};
      }
      add(key, val) {
        this.child.push({ [key]: val });
      }
      addChild(node) {
        if (node[":@"] && Object.keys(node[":@"]).length > 0) {
          this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
        } else {
          this.child.push({ [node.tagname]: node.child });
        }
      }
    };
    module2.exports = XmlNode2;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module2) {
    function readDocType(xmlData, i10) {
      const entities = {};
      if (xmlData[i10 + 3] === "O" && xmlData[i10 + 4] === "C" && xmlData[i10 + 5] === "T" && xmlData[i10 + 6] === "Y" && xmlData[i10 + 7] === "P" && xmlData[i10 + 8] === "E") {
        i10 = i10 + 9;
        let angleBracketsCount = 1;
        let hasBody = false, entity = false, comment = false;
        let exp = "";
        for (; i10 < xmlData.length; i10++) {
          if (xmlData[i10] === "<") {
            if (hasBody && xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "E" && xmlData[i10 + 3] === "N" && xmlData[i10 + 4] === "T" && xmlData[i10 + 5] === "I" && xmlData[i10 + 6] === "T" && xmlData[i10 + 7] === "Y") {
              i10 += 7;
              entity = true;
            } else if (hasBody && xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "E" && xmlData[i10 + 3] === "L" && xmlData[i10 + 4] === "E" && xmlData[i10 + 5] === "M" && xmlData[i10 + 6] === "E" && xmlData[i10 + 7] === "N" && xmlData[i10 + 8] === "T") {
              i10 += 8;
            } else if (hasBody && xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "A" && xmlData[i10 + 3] === "T" && xmlData[i10 + 4] === "T" && xmlData[i10 + 5] === "L" && xmlData[i10 + 6] === "I" && xmlData[i10 + 7] === "S" && xmlData[i10 + 8] === "T") {
              i10 += 8;
            } else if (hasBody && xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "N" && xmlData[i10 + 3] === "O" && xmlData[i10 + 4] === "T" && xmlData[i10 + 5] === "A" && xmlData[i10 + 6] === "T" && xmlData[i10 + 7] === "I" && xmlData[i10 + 8] === "O" && xmlData[i10 + 9] === "N") {
              i10 += 9;
            } else if (
              //comment
              xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "-" && xmlData[i10 + 3] === "-"
            ) {
              comment = true;
            } else {
              throw new Error("Invalid DOCTYPE");
            }
            angleBracketsCount++;
            exp = "";
          } else if (xmlData[i10] === ">") {
            if (comment) {
              if (xmlData[i10 - 1] === "-" && xmlData[i10 - 2] === "-") {
                comment = false;
              } else {
                throw new Error(`Invalid XML comment in DOCTYPE`);
              }
            } else if (entity) {
              parseEntityExp(exp, entities);
              entity = false;
            }
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          } else if (xmlData[i10] === "[") {
            hasBody = true;
          } else {
            exp += xmlData[i10];
          }
        }
        if (angleBracketsCount !== 0) {
          throw new Error(`Unclosed DOCTYPE`);
        }
      } else {
        throw new Error(`Invalid Tag instead of DOCTYPE`);
      }
      return { entities, i: i10 };
    }
    var entityRegex = RegExp(`^\\s([a-zA-z0-0]+)[ 	](['"])([^&]+)\\2`);
    function parseEntityExp(exp, entities) {
      const match = entityRegex.exec(exp);
      if (match) {
        entities[match[1]] = {
          regx: RegExp(`&${match[1]};`, "g"),
          val: match[3]
        };
      }
    }
    module2.exports = readDocType;
  }
});

// ../../node_modules/strnum/strnum.js
var require_strnum = __commonJS({
  "../../node_modules/strnum/strnum.js"(exports, module2) {
    var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
    var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
    if (!Number.parseInt && window.parseInt) {
      Number.parseInt = window.parseInt;
    }
    if (!Number.parseFloat && window.parseFloat) {
      Number.parseFloat = window.parseFloat;
    }
    var consider = {
      hex: true,
      leadingZeros: true,
      decimalPoint: ".",
      eNotation: true
      //skipLike: /regex/
    };
    function toNumber(str, options = {}) {
      options = Object.assign({}, consider, options);
      if (!str || typeof str !== "string")
        return str;
      let trimmedStr = str.trim();
      if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
        return str;
      else if (options.hex && hexRegex.test(trimmedStr)) {
        return Number.parseInt(trimmedStr, 16);
      } else {
        const match = numRegex.exec(trimmedStr);
        if (match) {
          const sign = match[1];
          const leadingZeros = match[2];
          let numTrimmedByZeros = trimZeros(match[3]);
          const eNotation = match[4] || match[6];
          if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".")
            return str;
          else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".")
            return str;
          else {
            const num = Number(trimmedStr);
            const numStr = "" + num;
            if (numStr.search(/[eE]/) !== -1) {
              if (options.eNotation)
                return num;
              else
                return str;
            } else if (eNotation) {
              if (options.eNotation)
                return num;
              else
                return str;
            } else if (trimmedStr.indexOf(".") !== -1) {
              if (numStr === "0" && numTrimmedByZeros === "")
                return num;
              else if (numStr === numTrimmedByZeros)
                return num;
              else if (sign && numStr === "-" + numTrimmedByZeros)
                return num;
              else
                return str;
            }
            if (leadingZeros) {
              if (numTrimmedByZeros === numStr)
                return num;
              else if (sign + numTrimmedByZeros === numStr)
                return num;
              else
                return str;
            }
            if (trimmedStr === numStr)
              return num;
            else if (trimmedStr === sign + numStr)
              return num;
            return str;
          }
        } else {
          return str;
        }
      }
    }
    function trimZeros(numStr) {
      if (numStr && numStr.indexOf(".") !== -1) {
        numStr = numStr.replace(/0+$/, "");
        if (numStr === ".")
          numStr = "0";
        else if (numStr[0] === ".")
          numStr = "0" + numStr;
        else if (numStr[numStr.length - 1] === ".")
          numStr = numStr.substr(0, numStr.length - 1);
        return numStr;
      }
      return numStr;
    }
    module2.exports = toNumber;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module2) {
    "use strict";
    var util = require_util();
    var xmlNode = require_xmlNode();
    var readDocType = require_DocTypeReader();
    var toNumber = require_strnum();
    var regx = "<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, util.nameRegexp);
    var OrderedObjParser = class {
      constructor(options) {
        this.options = options;
        this.currentNode = null;
        this.tagsNodeStack = [];
        this.docTypeEntities = {};
        this.lastEntities = {
          "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
          "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
          "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
          "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
        };
        this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
        this.htmlEntities = {
          "space": { regex: /&(nbsp|#160);/g, val: " " },
          // "lt" : { regex: /&(lt|#60);/g, val: "<" },
          // "gt" : { regex: /&(gt|#62);/g, val: ">" },
          // "amp" : { regex: /&(amp|#38);/g, val: "&" },
          // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
          // "apos" : { regex: /&(apos|#39);/g, val: "'" },
          "cent": { regex: /&(cent|#162);/g, val: "\xA2" },
          "pound": { regex: /&(pound|#163);/g, val: "\xA3" },
          "yen": { regex: /&(yen|#165);/g, val: "\xA5" },
          "euro": { regex: /&(euro|#8364);/g, val: "\u20AC" },
          "copyright": { regex: /&(copy|#169);/g, val: "\xA9" },
          "reg": { regex: /&(reg|#174);/g, val: "\xAE" },
          "inr": { regex: /&(inr|#8377);/g, val: "\u20B9" }
        };
        this.addExternalEntities = addExternalEntities;
        this.parseXml = parseXml;
        this.parseTextData = parseTextData;
        this.resolveNameSpace = resolveNameSpace;
        this.buildAttributesMap = buildAttributesMap;
        this.isItStopNode = isItStopNode;
        this.replaceEntitiesValue = replaceEntitiesValue;
        this.readStopNodeData = readStopNodeData;
        this.saveTextToParentTag = saveTextToParentTag;
      }
    };
    function addExternalEntities(externalEntities) {
      const entKeys = Object.keys(externalEntities);
      for (let i10 = 0; i10 < entKeys.length; i10++) {
        const ent = entKeys[i10];
        this.lastEntities[ent] = {
          regex: new RegExp("&" + ent + ";", "g"),
          val: externalEntities[ent]
        };
      }
    }
    function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
      if (val !== void 0) {
        if (this.options.trimValues && !dontTrim) {
          val = val.trim();
        }
        if (val.length > 0) {
          if (!escapeEntities)
            val = this.replaceEntitiesValue(val);
          const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
          if (newval === null || newval === void 0) {
            return val;
          } else if (typeof newval !== typeof val || newval !== val) {
            return newval;
          } else if (this.options.trimValues) {
            return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            const trimmedVal = val.trim();
            if (trimmedVal === val) {
              return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              return val;
            }
          }
        }
      }
    }
    function resolveNameSpace(tagname) {
      if (this.options.removeNSPrefix) {
        const tags = tagname.split(":");
        const prefix = tagname.charAt(0) === "/" ? "/" : "";
        if (tags[0] === "xmlns") {
          return "";
        }
        if (tags.length === 2) {
          tagname = prefix + tags[1];
        }
      }
      return tagname;
    }
    var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function buildAttributesMap(attrStr, jPath) {
      if (!this.options.ignoreAttributes && typeof attrStr === "string") {
        const matches = util.getAllMatches(attrStr, attrsRegx);
        const len = matches.length;
        const attrs = {};
        for (let i10 = 0; i10 < len; i10++) {
          const attrName = this.resolveNameSpace(matches[i10][1]);
          let oldVal = matches[i10][4];
          const aName = this.options.attributeNamePrefix + attrName;
          if (attrName.length) {
            if (oldVal !== void 0) {
              if (this.options.trimValues) {
                oldVal = oldVal.trim();
              }
              oldVal = this.replaceEntitiesValue(oldVal);
              const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
              if (newVal === null || newVal === void 0) {
                attrs[aName] = oldVal;
              } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                attrs[aName] = newVal;
              } else {
                attrs[aName] = parseValue(
                  oldVal,
                  this.options.parseAttributeValue,
                  this.options.numberParseOptions
                );
              }
            } else if (this.options.allowBooleanAttributes) {
              attrs[aName] = true;
            }
          }
        }
        if (!Object.keys(attrs).length) {
          return;
        }
        if (this.options.attributesGroupName) {
          const attrCollection = {};
          attrCollection[this.options.attributesGroupName] = attrs;
          return attrCollection;
        }
        return attrs;
      }
    }
    var parseXml = function(xmlData) {
      xmlData = xmlData.replace(/\r\n?/g, "\n");
      const xmlObj = new xmlNode("!xml");
      let currentNode = xmlObj;
      let textData = "";
      let jPath = "";
      for (let i10 = 0; i10 < xmlData.length; i10++) {
        const ch2 = xmlData[i10];
        if (ch2 === "<") {
          if (xmlData[i10 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i10, "Closing Tag is not closed.");
            let tagName = xmlData.substring(i10 + 2, closeIndex).trim();
            if (this.options.removeNSPrefix) {
              const colonIndex = tagName.indexOf(":");
              if (colonIndex !== -1) {
                tagName = tagName.substr(colonIndex + 1);
              }
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode) {
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
            }
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
            currentNode = this.tagsNodeStack.pop();
            textData = "";
            i10 = closeIndex;
          } else if (xmlData[i10 + 1] === "?") {
            let tagData = readTagExp(xmlData, i10, false, "?>");
            if (!tagData)
              throw new Error("Pi Tag is not closed.");
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
            } else {
              const childNode = new xmlNode(tagData.tagName);
              childNode.add(this.options.textNodeName, "");
              if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath);
              }
              currentNode.addChild(childNode);
            }
            i10 = tagData.closeIndex + 1;
          } else if (xmlData.substr(i10 + 1, 3) === "!--") {
            const endIndex = findClosingIndex(xmlData, "-->", i10 + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              const comment = xmlData.substring(i10 + 4, endIndex - 2);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
            }
            i10 = endIndex;
          } else if (xmlData.substr(i10 + 1, 2) === "!D") {
            const result = readDocType(xmlData, i10);
            this.docTypeEntities = result.entities;
            i10 = result.i;
          } else if (xmlData.substr(i10 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i10, "CDATA is not closed.") - 2;
            const tagExp = xmlData.substring(i10 + 9, closeIndex);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.cdataPropName) {
              currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
            } else {
              let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
              if (val == void 0)
                val = "";
              currentNode.add(this.options.textNodeName, val);
            }
            i10 = closeIndex + 2;
          } else {
            let result = readTagExp(xmlData, i10, this.options.removeNSPrefix);
            let tagName = result.tagName;
            let tagExp = result.tagExp;
            let attrExpPresent = result.attrExpPresent;
            let closeIndex = result.closeIndex;
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode && textData) {
              if (currentNode.tagname !== "!xml") {
                textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
              }
            }
            if (tagName !== xmlObj.tagname) {
              jPath += jPath ? "." + tagName : tagName;
            }
            const lastTag = currentNode;
            if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
              currentNode = this.tagsNodeStack.pop();
            }
            if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
              let tagContent = "";
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                i10 = result.closeIndex;
              } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                i10 = result.closeIndex;
              } else {
                const result2 = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
                if (!result2)
                  throw new Error(`Unexpected end of ${tagName}`);
                i10 = result2.i;
                tagContent = result2.tagContent;
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
              }
              if (tagContent) {
                tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
              }
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
              childNode.add(this.options.textNodeName, tagContent);
              currentNode.addChild(childNode);
            } else {
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                if (this.options.transformTagName) {
                  tagName = this.options.transformTagName(tagName);
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
                }
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
                currentNode.addChild(childNode);
              } else {
                const childNode = new xmlNode(tagName);
                this.tagsNodeStack.push(currentNode);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
                }
                currentNode.addChild(childNode);
                currentNode = childNode;
              }
              textData = "";
              i10 = closeIndex;
            }
          }
        } else {
          textData += xmlData[i10];
        }
      }
      return xmlObj.child;
    };
    var replaceEntitiesValue = function(val) {
      if (this.options.processEntities) {
        for (let entityName in this.docTypeEntities) {
          const entity = this.docTypeEntities[entityName];
          val = val.replace(entity.regx, entity.val);
        }
        for (let entityName in this.lastEntities) {
          const entity = this.lastEntities[entityName];
          val = val.replace(entity.regex, entity.val);
        }
        if (this.options.htmlEntities) {
          for (let entityName in this.htmlEntities) {
            const entity = this.htmlEntities[entityName];
            val = val.replace(entity.regex, entity.val);
          }
        }
        val = val.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return val;
    };
    function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
      if (textData) {
        if (isLeafNode === void 0)
          isLeafNode = Object.keys(currentNode.child).length === 0;
        textData = this.parseTextData(
          textData,
          currentNode.tagname,
          jPath,
          false,
          currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
          isLeafNode
        );
        if (textData !== void 0 && textData !== "")
          currentNode.add(this.options.textNodeName, textData);
        textData = "";
      }
      return textData;
    }
    function isItStopNode(stopNodes, jPath, currentTagName) {
      const allNodesExp = "*." + currentTagName;
      for (const stopNodePath in stopNodes) {
        const stopNodeExp = stopNodes[stopNodePath];
        if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
          return true;
      }
      return false;
    }
    function tagExpWithClosingIndex(xmlData, i10, closingChar = ">") {
      let attrBoundary;
      let tagExp = "";
      for (let index = i10; index < xmlData.length; index++) {
        let ch2 = xmlData[index];
        if (attrBoundary) {
          if (ch2 === attrBoundary)
            attrBoundary = "";
        } else if (ch2 === '"' || ch2 === "'") {
          attrBoundary = ch2;
        } else if (ch2 === closingChar[0]) {
          if (closingChar[1]) {
            if (xmlData[index + 1] === closingChar[1]) {
              return {
                data: tagExp,
                index
              };
            }
          } else {
            return {
              data: tagExp,
              index
            };
          }
        } else if (ch2 === "	") {
          ch2 = " ";
        }
        tagExp += ch2;
      }
    }
    function findClosingIndex(xmlData, str, i10, errMsg) {
      const closingIndex = xmlData.indexOf(str, i10);
      if (closingIndex === -1) {
        throw new Error(errMsg);
      } else {
        return closingIndex + str.length - 1;
      }
    }
    function readTagExp(xmlData, i10, removeNSPrefix, closingChar = ">") {
      const result = tagExpWithClosingIndex(xmlData, i10 + 1, closingChar);
      if (!result)
        return;
      let tagExp = result.data;
      const closeIndex = result.index;
      const separatorIndex = tagExp.search(/\s/);
      let tagName = tagExp;
      let attrExpPresent = true;
      if (separatorIndex !== -1) {
        tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, "");
        tagExp = tagExp.substr(separatorIndex + 1);
      }
      if (removeNSPrefix) {
        const colonIndex = tagName.indexOf(":");
        if (colonIndex !== -1) {
          tagName = tagName.substr(colonIndex + 1);
          attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
        }
      }
      return {
        tagName,
        tagExp,
        closeIndex,
        attrExpPresent
      };
    }
    function readStopNodeData(xmlData, tagName, i10) {
      const startIndex = i10;
      let openTagCount = 1;
      for (; i10 < xmlData.length; i10++) {
        if (xmlData[i10] === "<") {
          if (xmlData[i10 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i10, `${tagName} is not closed`);
            let closeTagName = xmlData.substring(i10 + 2, closeIndex).trim();
            if (closeTagName === tagName) {
              openTagCount--;
              if (openTagCount === 0) {
                return {
                  tagContent: xmlData.substring(startIndex, i10),
                  i: closeIndex
                };
              }
            }
            i10 = closeIndex;
          } else if (xmlData[i10 + 1] === "?") {
            const closeIndex = findClosingIndex(xmlData, "?>", i10 + 1, "StopNode is not closed.");
            i10 = closeIndex;
          } else if (xmlData.substr(i10 + 1, 3) === "!--") {
            const closeIndex = findClosingIndex(xmlData, "-->", i10 + 3, "StopNode is not closed.");
            i10 = closeIndex;
          } else if (xmlData.substr(i10 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i10, "StopNode is not closed.") - 2;
            i10 = closeIndex;
          } else {
            const tagData = readTagExp(xmlData, i10, ">");
            if (tagData) {
              const openTagName = tagData && tagData.tagName;
              if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                openTagCount++;
              }
              i10 = tagData.closeIndex;
            }
          }
        }
      }
    }
    function parseValue(val, shouldParse, options) {
      if (shouldParse && typeof val === "string") {
        const newval = val.trim();
        if (newval === "true")
          return true;
        else if (newval === "false")
          return false;
        else
          return toNumber(val, options);
      } else {
        if (util.isExist(val)) {
          return val;
        } else {
          return "";
        }
      }
    }
    module2.exports = OrderedObjParser;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
    "use strict";
    function prettify(node, options) {
      return compress(node, options);
    }
    function compress(arr, options, jPath) {
      let text;
      const compressedObj = {};
      for (let i10 = 0; i10 < arr.length; i10++) {
        const tagObj = arr[i10];
        const property = propName(tagObj);
        let newJpath = "";
        if (jPath === void 0)
          newJpath = property;
        else
          newJpath = jPath + "." + property;
        if (property === options.textNodeName) {
          if (text === void 0)
            text = tagObj[property];
          else
            text += "" + tagObj[property];
        } else if (property === void 0) {
          continue;
        } else if (tagObj[property]) {
          let val = compress(tagObj[property], options, newJpath);
          const isLeaf = isLeafTag(val, options);
          if (tagObj[":@"]) {
            assignAttributes(val, tagObj[":@"], newJpath, options);
          } else if (Object.keys(val).length === 1 && val[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
            val = val[options.textNodeName];
          } else if (Object.keys(val).length === 0) {
            if (options.alwaysCreateTextNode)
              val[options.textNodeName] = "";
            else
              val = "";
          }
          if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
            if (!Array.isArray(compressedObj[property])) {
              compressedObj[property] = [compressedObj[property]];
            }
            compressedObj[property].push(val);
          } else {
            if (options.isArray(property, newJpath, isLeaf)) {
              compressedObj[property] = [val];
            } else {
              compressedObj[property] = val;
            }
          }
        }
      }
      if (typeof text === "string") {
        if (text.length > 0)
          compressedObj[options.textNodeName] = text;
      } else if (text !== void 0)
        compressedObj[options.textNodeName] = text;
      return compressedObj;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i10 = 0; i10 < keys.length; i10++) {
        const key = keys[i10];
        if (key !== ":@")
          return key;
      }
    }
    function assignAttributes(obj, attrMap, jpath, options) {
      if (attrMap) {
        const keys = Object.keys(attrMap);
        const len = keys.length;
        for (let i10 = 0; i10 < len; i10++) {
          const atrrName = keys[i10];
          if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
            obj[atrrName] = [attrMap[atrrName]];
          } else {
            obj[atrrName] = attrMap[atrrName];
          }
        }
      }
    }
    function isLeafTag(obj, options) {
      const propCount = Object.keys(obj).length;
      if (propCount === 0 || propCount === 1 && obj[options.textNodeName])
        return true;
      return false;
    }
    exports.prettify = prettify;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module2) {
    var { buildOptions } = require_OptionsBuilder();
    var OrderedObjParser = require_OrderedObjParser();
    var { prettify } = require_node2json();
    var validator = require_validator();
    var XMLParser5 = class {
      constructor(options) {
        this.externalEntities = {};
        this.options = buildOptions(options);
      }
      /**
       * Parse XML dats to JS object 
       * @param {string|Buffer} xmlData 
       * @param {boolean|Object} validationOption 
       */
      parse(xmlData, validationOption) {
        if (typeof xmlData === "string") {
        } else if (xmlData.toString) {
          xmlData = xmlData.toString();
        } else {
          throw new Error("XML data is accepted in String or Bytes[] form.");
        }
        if (validationOption) {
          if (validationOption === true)
            validationOption = {};
          const result = validator.validate(xmlData, validationOption);
          if (result !== true) {
            throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
          }
        }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if (this.options.preserveOrder || orderedResult === void 0)
          return orderedResult;
        else
          return prettify(orderedResult, this.options);
      }
      /**
       * Add Entity which is not by default supported by this library
       * @param {string} key 
       * @param {string} value 
       */
      addEntity(key, value) {
        if (value.indexOf("&") !== -1) {
          throw new Error("Entity value can't have '&'");
        } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
          throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        } else if (value === "&") {
          throw new Error("An entity with value '&' is not permitted");
        } else {
          this.externalEntities[key] = value;
        }
      }
    };
    module2.exports = XMLParser5;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module2) {
    var EOL = "\n";
    function toXml(jArray, options) {
      return arrToStr(jArray, options, "", 0);
    }
    function arrToStr(arr, options, jPath, level) {
      let xmlStr = "";
      let indentation = "";
      if (options.format && options.indentBy.length > 0) {
        indentation = EOL + "" + options.indentBy.repeat(level);
      }
      for (let i10 = 0; i10 < arr.length; i10++) {
        const tagObj = arr[i10];
        const tagName = propName(tagObj);
        let newJPath = "";
        if (jPath.length === 0)
          newJPath = tagName;
        else
          newJPath = `${jPath}.${tagName}`;
        if (tagName === options.textNodeName) {
          let tagText = tagObj[tagName];
          if (!isStopNode(newJPath, options)) {
            tagText = options.tagValueProcessor(tagName, tagText);
            tagText = replaceEntitiesValue(tagText, options);
          }
          xmlStr += indentation + tagText;
          continue;
        } else if (tagName === options.cdataPropName) {
          xmlStr += indentation + `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
          continue;
        } else if (tagName === options.commentPropName) {
          xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
          continue;
        } else if (tagName[0] === "?") {
          const attStr2 = attr_to_str(tagObj[":@"], options);
          const tempInd = tagName === "?xml" ? "" : indentation;
          let piTextNodeName = tagObj[tagName][0][options.textNodeName];
          piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
          xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
          continue;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        let tagStart = indentation + `<${tagName}${attStr}`;
        let tagValue = arrToStr(tagObj[tagName], options, newJPath, level + 1);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
          if (options.suppressUnpairedNode)
            xmlStr += tagStart + ">";
          else
            xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
          xmlStr += tagStart + "/>";
        } else {
          xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        }
      }
      return xmlStr;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i10 = 0; i10 < keys.length; i10++) {
        const key = keys[i10];
        if (key !== ":@")
          return key;
      }
    }
    function attr_to_str(attrMap, options) {
      let attrStr = "";
      if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
          let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
          attrVal = replaceEntitiesValue(attrVal, options);
          if (attrVal === true && options.suppressBooleanAttributes) {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
          } else {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
          }
        }
      }
      return attrStr;
    }
    function isStopNode(jPath, options) {
      jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
      let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
      for (let index in options.stopNodes) {
        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
          return true;
      }
      return false;
    }
    function replaceEntitiesValue(textValue, options) {
      if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i10 = 0; i10 < options.entities.length; i10++) {
          const entity = options.entities[i10];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    }
    module2.exports = toXml;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module2) {
    "use strict";
    var buildFromOrderedJs = require_orderedJs2Xml();
    var defaultOptions = {
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      cdataPropName: false,
      format: false,
      indentBy: "  ",
      suppressEmptyNode: false,
      suppressUnpairedNode: true,
      suppressBooleanAttributes: true,
      tagValueProcessor: function(key, a10) {
        return a10;
      },
      attributeValueProcessor: function(attrName, a10) {
        return a10;
      },
      preserveOrder: false,
      commentPropName: false,
      unpairedTags: [],
      entities: [
        { regex: new RegExp("&", "g"), val: "&amp;" },
        //it must be on top
        { regex: new RegExp(">", "g"), val: "&gt;" },
        { regex: new RegExp("<", "g"), val: "&lt;" },
        { regex: new RegExp("'", "g"), val: "&apos;" },
        { regex: new RegExp('"', "g"), val: "&quot;" }
      ],
      processEntities: true,
      stopNodes: [],
      transformTagName: false
    };
    function Builder(options) {
      this.options = Object.assign({}, defaultOptions, options);
      if (this.options.ignoreAttributes || this.options.attributesGroupName) {
        this.isAttribute = function() {
          return false;
        };
      } else {
        this.attrPrefixLen = this.options.attributeNamePrefix.length;
        this.isAttribute = isAttribute;
      }
      this.processTextOrObjNode = processTextOrObjNode;
      if (this.options.format) {
        this.indentate = indentate;
        this.tagEndChar = ">\n";
        this.newLine = "\n";
      } else {
        this.indentate = function() {
          return "";
        };
        this.tagEndChar = ">";
        this.newLine = "";
      }
      if (this.options.suppressEmptyNode) {
        this.buildTextNode = buildEmptyTextNode;
        this.buildObjNode = buildEmptyObjNode;
      } else {
        this.buildTextNode = buildTextValNode;
        this.buildObjNode = buildObjectNode;
      }
      this.buildTextValNode = buildTextValNode;
      this.buildObjectNode = buildObjectNode;
      this.replaceEntitiesValue = replaceEntitiesValue;
      this.buildAttrPairStr = buildAttrPairStr;
    }
    Builder.prototype.build = function(jObj) {
      if (this.options.preserveOrder) {
        return buildFromOrderedJs(jObj, this.options);
      } else {
        if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
          jObj = {
            [this.options.arrayNodeName]: jObj
          };
        }
        return this.j2x(jObj, 0).val;
      }
    };
    Builder.prototype.j2x = function(jObj, level) {
      let attrStr = "";
      let val = "";
      for (let key in jObj) {
        if (typeof jObj[key] === "undefined") {
        } else if (jObj[key] === null) {
          if (key[0] === "?")
            val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
          else
            val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        } else if (jObj[key] instanceof Date) {
          val += this.buildTextNode(jObj[key], key, "", level);
        } else if (typeof jObj[key] !== "object") {
          const attr = this.isAttribute(key);
          if (attr) {
            attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
          } else {
            if (key === this.options.textNodeName) {
              let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
              val += this.replaceEntitiesValue(newval);
            } else {
              val += this.buildTextNode(jObj[key], key, "", level);
            }
          }
        } else if (Array.isArray(jObj[key])) {
          const arrLen = jObj[key].length;
          for (let j10 = 0; j10 < arrLen; j10++) {
            const item = jObj[key][j10];
            if (typeof item === "undefined") {
            } else if (item === null) {
              if (key[0] === "?")
                val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
              else
                val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
            } else if (typeof item === "object") {
              val += this.processTextOrObjNode(item, key, level);
            } else {
              val += this.buildTextNode(item, key, "", level);
            }
          }
        } else {
          if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
            const Ks = Object.keys(jObj[key]);
            const L4 = Ks.length;
            for (let j10 = 0; j10 < L4; j10++) {
              attrStr += this.buildAttrPairStr(Ks[j10], "" + jObj[key][Ks[j10]]);
            }
          } else {
            val += this.processTextOrObjNode(jObj[key], key, level);
          }
        }
      }
      return { attrStr, val };
    };
    function buildAttrPairStr(attrName, val) {
      val = this.options.attributeValueProcessor(attrName, "" + val);
      val = this.replaceEntitiesValue(val);
      if (this.options.suppressBooleanAttributes && val === "true") {
        return " " + attrName;
      } else
        return " " + attrName + '="' + val + '"';
    }
    function processTextOrObjNode(object2, key, level) {
      const result = this.j2x(object2, level + 1);
      if (object2[this.options.textNodeName] !== void 0 && Object.keys(object2).length === 1) {
        return this.buildTextNode(object2[this.options.textNodeName], key, result.attrStr, level);
      } else {
        return this.buildObjNode(result.val, key, result.attrStr, level);
      }
    }
    function buildObjectNode(val, key, attrStr, level) {
      let tagEndExp = "</" + key + this.tagEndChar;
      let piClosingChar = "";
      if (key[0] === "?") {
        piClosingChar = "?";
        tagEndExp = "";
      }
      if (attrStr && val.indexOf("<") === -1) {
        return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val + tagEndExp;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
        return this.indentate(level) + `<!--${val}-->` + this.newLine;
      } else {
        return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val + this.indentate(level) + tagEndExp;
      }
    }
    function buildEmptyObjNode(val, key, attrStr, level) {
      if (val !== "") {
        return this.buildObjectNode(val, key, attrStr, level);
      } else {
        if (key[0] === "?")
          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        else
          return this.indentate(level) + "<" + key + attrStr + "/" + this.tagEndChar;
      }
    }
    function buildTextValNode(val, key, attrStr, level) {
      if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
        return this.indentate(level) + `<![CDATA[${val}]]>` + this.newLine;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
        return this.indentate(level) + `<!--${val}-->` + this.newLine;
      } else {
        let textValue = this.options.tagValueProcessor(key, val);
        textValue = this.replaceEntitiesValue(textValue);
        if (textValue === "" && this.options.unpairedTags.indexOf(key) !== -1) {
          if (this.options.suppressUnpairedNode) {
            return this.indentate(level) + "<" + key + this.tagEndChar;
          } else {
            return this.indentate(level) + "<" + key + "/" + this.tagEndChar;
          }
        } else {
          return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
        }
      }
    }
    function replaceEntitiesValue(textValue) {
      if (textValue && textValue.length > 0 && this.options.processEntities) {
        for (let i10 = 0; i10 < this.options.entities.length; i10++) {
          const entity = this.options.entities[i10];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    }
    function buildEmptyTextNode(val, key, attrStr, level) {
      if (val === "" && this.options.unpairedTags.indexOf(key) !== -1) {
        if (this.options.suppressUnpairedNode) {
          return this.indentate(level) + "<" + key + this.tagEndChar;
        } else {
          return this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        }
      } else if (val !== "") {
        return this.buildTextValNode(val, key, attrStr, level);
      } else {
        if (key[0] === "?")
          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        else
          return this.indentate(level) + "<" + key + attrStr + "/" + this.tagEndChar;
      }
    }
    function indentate(level) {
      return this.options.indentBy.repeat(level);
    }
    function isAttribute(name) {
      if (name.startsWith(this.options.attributeNamePrefix)) {
        return name.substr(this.attrPrefixLen);
      } else {
        return false;
      }
    }
    module2.exports = Builder;
  }
});

// ../../node_modules/fast-xml-parser/src/fxp.js
var require_fxp = __commonJS({
  "../../node_modules/fast-xml-parser/src/fxp.js"(exports, module2) {
    "use strict";
    var validator = require_validator();
    var XMLParser5 = require_XMLParser();
    var XMLBuilder = require_json2xml();
    module2.exports = {
      XMLParser: XMLParser5,
      XMLValidator: validator,
      XMLBuilder
    };
  }
});

// ../../node_modules/@aws-crypto/crc32/node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __read: () => __read,
  __rest: () => __rest,
  __spread: () => __spread,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values
});
function __extends(d10, b10) {
  extendStatics(d10, b10);
  function __() {
    this.constructor = d10;
  }
  d10.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
}
function __rest(s10, e10) {
  var t6 = {};
  for (var p10 in s10)
    if (Object.prototype.hasOwnProperty.call(s10, p10) && e10.indexOf(p10) < 0)
      t6[p10] = s10[p10];
  if (s10 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i10 = 0, p10 = Object.getOwnPropertySymbols(s10); i10 < p10.length; i10++) {
      if (e10.indexOf(p10[i10]) < 0 && Object.prototype.propertyIsEnumerable.call(s10, p10[i10]))
        t6[p10[i10]] = s10[p10[i10]];
    }
  return t6;
}
function __decorate(decorators, target, key, desc) {
  var c10 = arguments.length, r10 = c10 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d10;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r10 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i10 = decorators.length - 1; i10 >= 0; i10--)
      if (d10 = decorators[i10])
        r10 = (c10 < 3 ? d10(r10) : c10 > 3 ? d10(target, key, r10) : d10(target, key)) || r10;
  return c10 > 3 && r10 && Object.defineProperty(target, key, r10), r10;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e10) {
        reject(e10);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e10) {
        reject(e10);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t6[0] & 1)
      throw t6[1];
    return t6[1];
  }, trys: [], ops: [] }, f10, y4, t6, g10;
  return g10 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g10[Symbol.iterator] = function() {
    return this;
  }), g10;
  function verb(n10) {
    return function(v7) {
      return step([n10, v7]);
    };
  }
  function step(op) {
    if (f10)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f10 = 1, y4 && (t6 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t6 = y4["return"]) && t6.call(y4), 0) : y4.next) && !(t6 = t6.call(y4, op[1])).done)
          return t6;
        if (y4 = 0, t6)
          op = [op[0] & 2, t6.value];
        switch (op[0]) {
          case 0:
          case 1:
            t6 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y4 = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t6 = _.trys, t6 = t6.length > 0 && t6[t6.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t6 || op[1] > t6[0] && op[1] < t6[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t6[1]) {
              _.label = t6[1];
              t6 = op;
              break;
            }
            if (t6 && _.label < t6[2]) {
              _.label = t6[2];
              _.ops.push(op);
              break;
            }
            if (t6[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e10) {
        op = [6, e10];
        y4 = 0;
      } finally {
        f10 = t6 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o10, m10, k10, k22) {
  if (k22 === void 0)
    k22 = k10;
  o10[k22] = m10[k10];
}
function __exportStar(m10, exports) {
  for (var p10 in m10)
    if (p10 !== "default" && !exports.hasOwnProperty(p10))
      exports[p10] = m10[p10];
}
function __values(o10) {
  var s10 = typeof Symbol === "function" && Symbol.iterator, m10 = s10 && o10[s10], i10 = 0;
  if (m10)
    return m10.call(o10);
  if (o10 && typeof o10.length === "number")
    return {
      next: function() {
        if (o10 && i10 >= o10.length)
          o10 = void 0;
        return { value: o10 && o10[i10++], done: !o10 };
      }
    };
  throw new TypeError(s10 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o10, n10) {
  var m10 = typeof Symbol === "function" && o10[Symbol.iterator];
  if (!m10)
    return o10;
  var i10 = m10.call(o10), r10, ar2 = [], e10;
  try {
    while ((n10 === void 0 || n10-- > 0) && !(r10 = i10.next()).done)
      ar2.push(r10.value);
  } catch (error) {
    e10 = { error };
  } finally {
    try {
      if (r10 && !r10.done && (m10 = i10["return"]))
        m10.call(i10);
    } finally {
      if (e10)
        throw e10.error;
    }
  }
  return ar2;
}
function __spread() {
  for (var ar2 = [], i10 = 0; i10 < arguments.length; i10++)
    ar2 = ar2.concat(__read(arguments[i10]));
  return ar2;
}
function __spreadArrays() {
  for (var s10 = 0, i10 = 0, il = arguments.length; i10 < il; i10++)
    s10 += arguments[i10].length;
  for (var r10 = Array(s10), k10 = 0, i10 = 0; i10 < il; i10++)
    for (var a10 = arguments[i10], j10 = 0, jl = a10.length; j10 < jl; j10++, k10++)
      r10[k10] = a10[j10];
  return r10;
}
function __await(v7) {
  return this instanceof __await ? (this.v = v7, this) : new __await(v7);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g10 = generator.apply(thisArg, _arguments || []), i10, q10 = [];
  return i10 = {}, verb("next"), verb("throw"), verb("return"), i10[Symbol.asyncIterator] = function() {
    return this;
  }, i10;
  function verb(n10) {
    if (g10[n10])
      i10[n10] = function(v7) {
        return new Promise(function(a10, b10) {
          q10.push([n10, v7, a10, b10]) > 1 || resume(n10, v7);
        });
      };
  }
  function resume(n10, v7) {
    try {
      step(g10[n10](v7));
    } catch (e10) {
      settle(q10[0][3], e10);
    }
  }
  function step(r10) {
    r10.value instanceof __await ? Promise.resolve(r10.value.v).then(fulfill, reject) : settle(q10[0][2], r10);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f10, v7) {
    if (f10(v7), q10.shift(), q10.length)
      resume(q10[0][0], q10[0][1]);
  }
}
function __asyncDelegator(o10) {
  var i10, p10;
  return i10 = {}, verb("next"), verb("throw", function(e10) {
    throw e10;
  }), verb("return"), i10[Symbol.iterator] = function() {
    return this;
  }, i10;
  function verb(n10, f10) {
    i10[n10] = o10[n10] ? function(v7) {
      return (p10 = !p10) ? { value: __await(o10[n10](v7)), done: n10 === "return" } : f10 ? f10(v7) : v7;
    } : f10;
  }
}
function __asyncValues(o10) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m10 = o10[Symbol.asyncIterator], i10;
  return m10 ? m10.call(o10) : (o10 = typeof __values === "function" ? __values(o10) : o10[Symbol.iterator](), i10 = {}, verb("next"), verb("throw"), verb("return"), i10[Symbol.asyncIterator] = function() {
    return this;
  }, i10);
  function verb(n10) {
    i10[n10] = o10[n10] && function(v7) {
      return new Promise(function(resolve, reject) {
        v7 = o10[n10](v7), settle(resolve, reject, v7.done, v7.value);
      });
    };
  }
  function settle(resolve, reject, d10, v7) {
    Promise.resolve(v7).then(function(v8) {
      resolve({ value: v8, done: d10 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k10 in mod)
      if (Object.hasOwnProperty.call(mod, k10))
        result[k10] = mod[k10];
  }
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics, __assign;
var init_tslib_es6 = __esm({
  "../../node_modules/@aws-crypto/crc32/node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d10, b10) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d11, b11) {
        d11.__proto__ = b11;
      } || function(d11, b11) {
        for (var p10 in b11)
          if (b11.hasOwnProperty(p10))
            d11[p10] = b11[p10];
      };
      return extendStatics(d10, b10);
    };
    __assign = function() {
      __assign = Object.assign || function __assign3(t6) {
        for (var s10, i10 = 1, n10 = arguments.length; i10 < n10; i10++) {
          s10 = arguments[i10];
          for (var p10 in s10)
            if (Object.prototype.hasOwnProperty.call(s10, p10))
              t6[p10] = s10[p10];
        }
        return t6;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// ../../node_modules/@aws-sdk/util-utf8-browser/dist-es/pureJs.js
var fromUtf8, toUtf8;
var init_pureJs = __esm({
  "../../node_modules/@aws-sdk/util-utf8-browser/dist-es/pureJs.js"() {
    fromUtf8 = (input) => {
      const bytes = [];
      for (let i10 = 0, len = input.length; i10 < len; i10++) {
        const value = input.charCodeAt(i10);
        if (value < 128) {
          bytes.push(value);
        } else if (value < 2048) {
          bytes.push(value >> 6 | 192, value & 63 | 128);
        } else if (i10 + 1 < input.length && (value & 64512) === 55296 && (input.charCodeAt(i10 + 1) & 64512) === 56320) {
          const surrogatePair = 65536 + ((value & 1023) << 10) + (input.charCodeAt(++i10) & 1023);
          bytes.push(surrogatePair >> 18 | 240, surrogatePair >> 12 & 63 | 128, surrogatePair >> 6 & 63 | 128, surrogatePair & 63 | 128);
        } else {
          bytes.push(value >> 12 | 224, value >> 6 & 63 | 128, value & 63 | 128);
        }
      }
      return Uint8Array.from(bytes);
    };
    toUtf8 = (input) => {
      let decoded = "";
      for (let i10 = 0, len = input.length; i10 < len; i10++) {
        const byte = input[i10];
        if (byte < 128) {
          decoded += String.fromCharCode(byte);
        } else if (192 <= byte && byte < 224) {
          const nextByte = input[++i10];
          decoded += String.fromCharCode((byte & 31) << 6 | nextByte & 63);
        } else if (240 <= byte && byte < 365) {
          const surrogatePair = [byte, input[++i10], input[++i10], input[++i10]];
          const encoded = "%" + surrogatePair.map((byteValue) => byteValue.toString(16)).join("%");
          decoded += decodeURIComponent(encoded);
        } else {
          decoded += String.fromCharCode((byte & 15) << 12 | (input[++i10] & 63) << 6 | input[++i10] & 63);
        }
      }
      return decoded;
    };
  }
});

// ../../node_modules/@aws-sdk/util-utf8-browser/dist-es/whatwgEncodingApi.js
function fromUtf82(input) {
  return new TextEncoder().encode(input);
}
function toUtf82(input) {
  return new TextDecoder("utf-8").decode(input);
}
var init_whatwgEncodingApi = __esm({
  "../../node_modules/@aws-sdk/util-utf8-browser/dist-es/whatwgEncodingApi.js"() {
  }
});

// ../../node_modules/@aws-sdk/util-utf8-browser/dist-es/index.js
var dist_es_exports = {};
__export(dist_es_exports, {
  fromUtf8: () => fromUtf83,
  toUtf8: () => toUtf83
});
var fromUtf83, toUtf83;
var init_dist_es = __esm({
  "../../node_modules/@aws-sdk/util-utf8-browser/dist-es/index.js"() {
    init_pureJs();
    init_whatwgEncodingApi();
    fromUtf83 = (input) => typeof TextEncoder === "function" ? fromUtf82(input) : fromUtf8(input);
    toUtf83 = (input) => typeof TextDecoder === "function" ? toUtf82(input) : toUtf8(input);
  }
});

// ../../node_modules/@aws-crypto/util/build/convertToBuffer.js
var require_convertToBuffer = __commonJS({
  "../../node_modules/@aws-crypto/util/build/convertToBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertToBuffer = void 0;
    var util_utf8_browser_1 = (init_dist_es(), __toCommonJS(dist_es_exports));
    var fromUtf85 = typeof Buffer !== "undefined" && Buffer.from ? function(input) {
      return Buffer.from(input, "utf8");
    } : util_utf8_browser_1.fromUtf8;
    function convertToBuffer(data) {
      if (data instanceof Uint8Array)
        return data;
      if (typeof data === "string") {
        return fromUtf85(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    }
    exports.convertToBuffer = convertToBuffer;
  }
});

// ../../node_modules/@aws-crypto/util/build/isEmptyData.js
var require_isEmptyData = __commonJS({
  "../../node_modules/@aws-crypto/util/build/isEmptyData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmptyData = void 0;
    function isEmptyData(data) {
      if (typeof data === "string") {
        return data.length === 0;
      }
      return data.byteLength === 0;
    }
    exports.isEmptyData = isEmptyData;
  }
});

// ../../node_modules/@aws-crypto/util/build/numToUint8.js
var require_numToUint8 = __commonJS({
  "../../node_modules/@aws-crypto/util/build/numToUint8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.numToUint8 = void 0;
    function numToUint8(num) {
      return new Uint8Array([
        (num & 4278190080) >> 24,
        (num & 16711680) >> 16,
        (num & 65280) >> 8,
        num & 255
      ]);
    }
    exports.numToUint8 = numToUint8;
  }
});

// ../../node_modules/@aws-crypto/util/build/uint32ArrayFrom.js
var require_uint32ArrayFrom = __commonJS({
  "../../node_modules/@aws-crypto/util/build/uint32ArrayFrom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uint32ArrayFrom = void 0;
    function uint32ArrayFrom(a_lookUpTable) {
      if (!Uint32Array.from) {
        var return_array = new Uint32Array(a_lookUpTable.length);
        var a_index = 0;
        while (a_index < a_lookUpTable.length) {
          return_array[a_index] = a_lookUpTable[a_index];
          a_index += 1;
        }
        return return_array;
      }
      return Uint32Array.from(a_lookUpTable);
    }
    exports.uint32ArrayFrom = uint32ArrayFrom;
  }
});

// ../../node_modules/@aws-crypto/util/build/index.js
var require_build = __commonJS({
  "../../node_modules/@aws-crypto/util/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = void 0;
    var convertToBuffer_1 = require_convertToBuffer();
    Object.defineProperty(exports, "convertToBuffer", { enumerable: true, get: function() {
      return convertToBuffer_1.convertToBuffer;
    } });
    var isEmptyData_1 = require_isEmptyData();
    Object.defineProperty(exports, "isEmptyData", { enumerable: true, get: function() {
      return isEmptyData_1.isEmptyData;
    } });
    var numToUint8_1 = require_numToUint8();
    Object.defineProperty(exports, "numToUint8", { enumerable: true, get: function() {
      return numToUint8_1.numToUint8;
    } });
    var uint32ArrayFrom_1 = require_uint32ArrayFrom();
    Object.defineProperty(exports, "uint32ArrayFrom", { enumerable: true, get: function() {
      return uint32ArrayFrom_1.uint32ArrayFrom;
    } });
  }
});

// ../../node_modules/@aws-crypto/crc32/build/aws_crc32.js
var require_aws_crc32 = __commonJS({
  "../../node_modules/@aws-crypto/crc32/build/aws_crc32.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsCrc32 = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var util_1 = require_build();
    var index_1 = require_build2();
    var AwsCrc322 = (
      /** @class */
      function() {
        function AwsCrc323() {
          this.crc32 = new index_1.Crc32();
        }
        AwsCrc323.prototype.update = function(toHash) {
          if ((0, util_1.isEmptyData)(toHash))
            return;
          this.crc32.update((0, util_1.convertToBuffer)(toHash));
        };
        AwsCrc323.prototype.digest = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              return [2, (0, util_1.numToUint8)(this.crc32.digest())];
            });
          });
        };
        AwsCrc323.prototype.reset = function() {
          this.crc32 = new index_1.Crc32();
        };
        return AwsCrc323;
      }()
    );
    exports.AwsCrc32 = AwsCrc322;
  }
});

// ../../node_modules/@aws-crypto/crc32/build/index.js
var require_build2 = __commonJS({
  "../../node_modules/@aws-crypto/crc32/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsCrc32 = exports.Crc32 = exports.crc32 = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var util_1 = require_build();
    function crc32(data) {
      return new Crc323().update(data).digest();
    }
    exports.crc32 = crc32;
    var Crc323 = (
      /** @class */
      function() {
        function Crc324() {
          this.checksum = 4294967295;
        }
        Crc324.prototype.update = function(data) {
          var e_1, _a;
          try {
            for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
              var byte = data_1_1.value;
              this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 255];
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (data_1_1 && !data_1_1.done && (_a = data_1.return))
                _a.call(data_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          return this;
        };
        Crc324.prototype.digest = function() {
          return (this.checksum ^ 4294967295) >>> 0;
        };
        return Crc324;
      }()
    );
    exports.Crc32 = Crc323;
    var a_lookUpTable = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    var lookupTable = (0, util_1.uint32ArrayFrom)(a_lookUpTable);
    var aws_crc32_1 = require_aws_crc32();
    Object.defineProperty(exports, "AwsCrc32", { enumerable: true, get: function() {
      return aws_crc32_1.AwsCrc32;
    } });
  }
});

// ../../node_modules/@aws-crypto/crc32c/node_modules/tslib/tslib.es6.js
var tslib_es6_exports2 = {};
__export(tslib_es6_exports2, {
  __assign: () => __assign2,
  __asyncDelegator: () => __asyncDelegator2,
  __asyncGenerator: () => __asyncGenerator2,
  __asyncValues: () => __asyncValues2,
  __await: () => __await2,
  __awaiter: () => __awaiter2,
  __classPrivateFieldGet: () => __classPrivateFieldGet2,
  __classPrivateFieldSet: () => __classPrivateFieldSet2,
  __createBinding: () => __createBinding2,
  __decorate: () => __decorate2,
  __exportStar: () => __exportStar2,
  __extends: () => __extends2,
  __generator: () => __generator2,
  __importDefault: () => __importDefault2,
  __importStar: () => __importStar2,
  __makeTemplateObject: () => __makeTemplateObject2,
  __metadata: () => __metadata2,
  __param: () => __param2,
  __read: () => __read2,
  __rest: () => __rest2,
  __spread: () => __spread2,
  __spreadArrays: () => __spreadArrays2,
  __values: () => __values2
});
function __extends2(d10, b10) {
  extendStatics2(d10, b10);
  function __() {
    this.constructor = d10;
  }
  d10.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
}
function __rest2(s10, e10) {
  var t6 = {};
  for (var p10 in s10)
    if (Object.prototype.hasOwnProperty.call(s10, p10) && e10.indexOf(p10) < 0)
      t6[p10] = s10[p10];
  if (s10 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i10 = 0, p10 = Object.getOwnPropertySymbols(s10); i10 < p10.length; i10++) {
      if (e10.indexOf(p10[i10]) < 0 && Object.prototype.propertyIsEnumerable.call(s10, p10[i10]))
        t6[p10[i10]] = s10[p10[i10]];
    }
  return t6;
}
function __decorate2(decorators, target, key, desc) {
  var c10 = arguments.length, r10 = c10 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d10;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r10 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i10 = decorators.length - 1; i10 >= 0; i10--)
      if (d10 = decorators[i10])
        r10 = (c10 < 3 ? d10(r10) : c10 > 3 ? d10(target, key, r10) : d10(target, key)) || r10;
  return c10 > 3 && r10 && Object.defineProperty(target, key, r10), r10;
}
function __param2(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata2(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter2(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e10) {
        reject(e10);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e10) {
        reject(e10);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator2(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t6[0] & 1)
      throw t6[1];
    return t6[1];
  }, trys: [], ops: [] }, f10, y4, t6, g10;
  return g10 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g10[Symbol.iterator] = function() {
    return this;
  }), g10;
  function verb(n10) {
    return function(v7) {
      return step([n10, v7]);
    };
  }
  function step(op) {
    if (f10)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f10 = 1, y4 && (t6 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t6 = y4["return"]) && t6.call(y4), 0) : y4.next) && !(t6 = t6.call(y4, op[1])).done)
          return t6;
        if (y4 = 0, t6)
          op = [op[0] & 2, t6.value];
        switch (op[0]) {
          case 0:
          case 1:
            t6 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y4 = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t6 = _.trys, t6 = t6.length > 0 && t6[t6.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t6 || op[1] > t6[0] && op[1] < t6[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t6[1]) {
              _.label = t6[1];
              t6 = op;
              break;
            }
            if (t6 && _.label < t6[2]) {
              _.label = t6[2];
              _.ops.push(op);
              break;
            }
            if (t6[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e10) {
        op = [6, e10];
        y4 = 0;
      } finally {
        f10 = t6 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding2(o10, m10, k10, k22) {
  if (k22 === void 0)
    k22 = k10;
  o10[k22] = m10[k10];
}
function __exportStar2(m10, exports) {
  for (var p10 in m10)
    if (p10 !== "default" && !exports.hasOwnProperty(p10))
      exports[p10] = m10[p10];
}
function __values2(o10) {
  var s10 = typeof Symbol === "function" && Symbol.iterator, m10 = s10 && o10[s10], i10 = 0;
  if (m10)
    return m10.call(o10);
  if (o10 && typeof o10.length === "number")
    return {
      next: function() {
        if (o10 && i10 >= o10.length)
          o10 = void 0;
        return { value: o10 && o10[i10++], done: !o10 };
      }
    };
  throw new TypeError(s10 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read2(o10, n10) {
  var m10 = typeof Symbol === "function" && o10[Symbol.iterator];
  if (!m10)
    return o10;
  var i10 = m10.call(o10), r10, ar2 = [], e10;
  try {
    while ((n10 === void 0 || n10-- > 0) && !(r10 = i10.next()).done)
      ar2.push(r10.value);
  } catch (error) {
    e10 = { error };
  } finally {
    try {
      if (r10 && !r10.done && (m10 = i10["return"]))
        m10.call(i10);
    } finally {
      if (e10)
        throw e10.error;
    }
  }
  return ar2;
}
function __spread2() {
  for (var ar2 = [], i10 = 0; i10 < arguments.length; i10++)
    ar2 = ar2.concat(__read2(arguments[i10]));
  return ar2;
}
function __spreadArrays2() {
  for (var s10 = 0, i10 = 0, il = arguments.length; i10 < il; i10++)
    s10 += arguments[i10].length;
  for (var r10 = Array(s10), k10 = 0, i10 = 0; i10 < il; i10++)
    for (var a10 = arguments[i10], j10 = 0, jl = a10.length; j10 < jl; j10++, k10++)
      r10[k10] = a10[j10];
  return r10;
}
function __await2(v7) {
  return this instanceof __await2 ? (this.v = v7, this) : new __await2(v7);
}
function __asyncGenerator2(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g10 = generator.apply(thisArg, _arguments || []), i10, q10 = [];
  return i10 = {}, verb("next"), verb("throw"), verb("return"), i10[Symbol.asyncIterator] = function() {
    return this;
  }, i10;
  function verb(n10) {
    if (g10[n10])
      i10[n10] = function(v7) {
        return new Promise(function(a10, b10) {
          q10.push([n10, v7, a10, b10]) > 1 || resume(n10, v7);
        });
      };
  }
  function resume(n10, v7) {
    try {
      step(g10[n10](v7));
    } catch (e10) {
      settle(q10[0][3], e10);
    }
  }
  function step(r10) {
    r10.value instanceof __await2 ? Promise.resolve(r10.value.v).then(fulfill, reject) : settle(q10[0][2], r10);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f10, v7) {
    if (f10(v7), q10.shift(), q10.length)
      resume(q10[0][0], q10[0][1]);
  }
}
function __asyncDelegator2(o10) {
  var i10, p10;
  return i10 = {}, verb("next"), verb("throw", function(e10) {
    throw e10;
  }), verb("return"), i10[Symbol.iterator] = function() {
    return this;
  }, i10;
  function verb(n10, f10) {
    i10[n10] = o10[n10] ? function(v7) {
      return (p10 = !p10) ? { value: __await2(o10[n10](v7)), done: n10 === "return" } : f10 ? f10(v7) : v7;
    } : f10;
  }
}
function __asyncValues2(o10) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m10 = o10[Symbol.asyncIterator], i10;
  return m10 ? m10.call(o10) : (o10 = typeof __values2 === "function" ? __values2(o10) : o10[Symbol.iterator](), i10 = {}, verb("next"), verb("throw"), verb("return"), i10[Symbol.asyncIterator] = function() {
    return this;
  }, i10);
  function verb(n10) {
    i10[n10] = o10[n10] && function(v7) {
      return new Promise(function(resolve, reject) {
        v7 = o10[n10](v7), settle(resolve, reject, v7.done, v7.value);
      });
    };
  }
  function settle(resolve, reject, d10, v7) {
    Promise.resolve(v7).then(function(v8) {
      resolve({ value: v8, done: d10 });
    }, reject);
  }
}
function __makeTemplateObject2(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar2(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k10 in mod)
      if (Object.hasOwnProperty.call(mod, k10))
        result[k10] = mod[k10];
  }
  result.default = mod;
  return result;
}
function __importDefault2(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet2(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet2(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics2, __assign2;
var init_tslib_es62 = __esm({
  "../../node_modules/@aws-crypto/crc32c/node_modules/tslib/tslib.es6.js"() {
    extendStatics2 = function(d10, b10) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d11, b11) {
        d11.__proto__ = b11;
      } || function(d11, b11) {
        for (var p10 in b11)
          if (b11.hasOwnProperty(p10))
            d11[p10] = b11[p10];
      };
      return extendStatics2(d10, b10);
    };
    __assign2 = function() {
      __assign2 = Object.assign || function __assign3(t6) {
        for (var s10, i10 = 1, n10 = arguments.length; i10 < n10; i10++) {
          s10 = arguments[i10];
          for (var p10 in s10)
            if (Object.prototype.hasOwnProperty.call(s10, p10))
              t6[p10] = s10[p10];
        }
        return t6;
      };
      return __assign2.apply(this, arguments);
    };
  }
});

// ../../node_modules/@aws-crypto/crc32c/build/aws_crc32c.js
var require_aws_crc32c = __commonJS({
  "../../node_modules/@aws-crypto/crc32c/build/aws_crc32c.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsCrc32c = void 0;
    var tslib_1 = (init_tslib_es62(), __toCommonJS(tslib_es6_exports2));
    var util_1 = require_build();
    var index_1 = require_build3();
    var AwsCrc32c2 = (
      /** @class */
      function() {
        function AwsCrc32c3() {
          this.crc32c = new index_1.Crc32c();
        }
        AwsCrc32c3.prototype.update = function(toHash) {
          if ((0, util_1.isEmptyData)(toHash))
            return;
          this.crc32c.update((0, util_1.convertToBuffer)(toHash));
        };
        AwsCrc32c3.prototype.digest = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              return [2, (0, util_1.numToUint8)(this.crc32c.digest())];
            });
          });
        };
        AwsCrc32c3.prototype.reset = function() {
          this.crc32c = new index_1.Crc32c();
        };
        return AwsCrc32c3;
      }()
    );
    exports.AwsCrc32c = AwsCrc32c2;
  }
});

// ../../node_modules/@aws-crypto/crc32c/build/index.js
var require_build3 = __commonJS({
  "../../node_modules/@aws-crypto/crc32c/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsCrc32c = exports.Crc32c = exports.crc32c = void 0;
    var tslib_1 = (init_tslib_es62(), __toCommonJS(tslib_es6_exports2));
    var util_1 = require_build();
    function crc32c(data) {
      return new Crc32c().update(data).digest();
    }
    exports.crc32c = crc32c;
    var Crc32c = (
      /** @class */
      function() {
        function Crc32c2() {
          this.checksum = 4294967295;
        }
        Crc32c2.prototype.update = function(data) {
          var e_1, _a;
          try {
            for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
              var byte = data_1_1.value;
              this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 255];
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (data_1_1 && !data_1_1.done && (_a = data_1.return))
                _a.call(data_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          return this;
        };
        Crc32c2.prototype.digest = function() {
          return (this.checksum ^ 4294967295) >>> 0;
        };
        return Crc32c2;
      }()
    );
    exports.Crc32c = Crc32c;
    var a_lookupTable = [
      0,
      4067132163,
      3778769143,
      324072436,
      3348797215,
      904991772,
      648144872,
      3570033899,
      2329499855,
      2024987596,
      1809983544,
      2575936315,
      1296289744,
      3207089363,
      2893594407,
      1578318884,
      274646895,
      3795141740,
      4049975192,
      51262619,
      3619967088,
      632279923,
      922689671,
      3298075524,
      2592579488,
      1760304291,
      2075979607,
      2312596564,
      1562183871,
      2943781820,
      3156637768,
      1313733451,
      549293790,
      3537243613,
      3246849577,
      871202090,
      3878099393,
      357341890,
      102525238,
      4101499445,
      2858735121,
      1477399826,
      1264559846,
      3107202533,
      1845379342,
      2677391885,
      2361733625,
      2125378298,
      820201905,
      3263744690,
      3520608582,
      598981189,
      4151959214,
      85089709,
      373468761,
      3827903834,
      3124367742,
      1213305469,
      1526817161,
      2842354314,
      2107672161,
      2412447074,
      2627466902,
      1861252501,
      1098587580,
      3004210879,
      2688576843,
      1378610760,
      2262928035,
      1955203488,
      1742404180,
      2511436119,
      3416409459,
      969524848,
      714683780,
      3639785095,
      205050476,
      4266873199,
      3976438427,
      526918040,
      1361435347,
      2739821008,
      2954799652,
      1114974503,
      2529119692,
      1691668175,
      2005155131,
      2247081528,
      3690758684,
      697762079,
      986182379,
      3366744552,
      476452099,
      3993867776,
      4250756596,
      255256311,
      1640403810,
      2477592673,
      2164122517,
      1922457750,
      2791048317,
      1412925310,
      1197962378,
      3037525897,
      3944729517,
      427051182,
      170179418,
      4165941337,
      746937522,
      3740196785,
      3451792453,
      1070968646,
      1905808397,
      2213795598,
      2426610938,
      1657317369,
      3053634322,
      1147748369,
      1463399397,
      2773627110,
      4215344322,
      153784257,
      444234805,
      3893493558,
      1021025245,
      3467647198,
      3722505002,
      797665321,
      2197175160,
      1889384571,
      1674398607,
      2443626636,
      1164749927,
      3070701412,
      2757221520,
      1446797203,
      137323447,
      4198817972,
      3910406976,
      461344835,
      3484808360,
      1037989803,
      781091935,
      3705997148,
      2460548119,
      1623424788,
      1939049696,
      2180517859,
      1429367560,
      2807687179,
      3020495871,
      1180866812,
      410100952,
      3927582683,
      4182430767,
      186734380,
      3756733383,
      763408580,
      1053836080,
      3434856499,
      2722870694,
      1344288421,
      1131464017,
      2971354706,
      1708204729,
      2545590714,
      2229949006,
      1988219213,
      680717673,
      3673779818,
      3383336350,
      1002577565,
      4010310262,
      493091189,
      238226049,
      4233660802,
      2987750089,
      1082061258,
      1395524158,
      2705686845,
      1972364758,
      2279892693,
      2494862625,
      1725896226,
      952904198,
      3399985413,
      3656866545,
      731699698,
      4283874585,
      222117402,
      510512622,
      3959836397,
      3280807620,
      837199303,
      582374963,
      3504198960,
      68661723,
      4135334616,
      3844915500,
      390545967,
      1230274059,
      3141532936,
      2825850620,
      1510247935,
      2395924756,
      2091215383,
      1878366691,
      2644384480,
      3553878443,
      565732008,
      854102364,
      3229815391,
      340358836,
      3861050807,
      4117890627,
      119113024,
      1493875044,
      2875275879,
      3090270611,
      1247431312,
      2660249211,
      1828433272,
      2141937292,
      2378227087,
      3811616794,
      291187481,
      34330861,
      4032846830,
      615137029,
      3603020806,
      3314634738,
      939183345,
      1776939221,
      2609017814,
      2295496738,
      2058945313,
      2926798794,
      1545135305,
      1330124605,
      3173225534,
      4084100981,
      17165430,
      307568514,
      3762199681,
      888469610,
      3332340585,
      3587147933,
      665062302,
      2042050490,
      2346497209,
      2559330125,
      1793573966,
      3190661285,
      1279665062,
      1595330642,
      2910671697
    ];
    var lookupTable = (0, util_1.uint32ArrayFrom)(a_lookupTable);
    var aws_crc32c_1 = require_aws_crc32c();
    Object.defineProperty(exports, "AwsCrc32c", { enumerable: true, get: function() {
      return aws_crc32c_1.AwsCrc32c;
    } });
  }
});

// ../../node_modules/picomatch/lib/constants.js
var require_constants = __commonJS({
  "../../node_modules/picomatch/lib/constants.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// ../../node_modules/picomatch/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/picomatch/lib/utils.js"(exports) {
    "use strict";
    var path = require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
    exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path.sep === "\\";
    };
    exports.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// ../../node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "../../node_modules/picomatch/lib/scan.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan2 = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n10 = prevIndex ? prevIndex + 1 : start;
          const i10 = slashes[idx];
          const value = input.slice(n10, i10);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i10;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan2;
  }
});

// ../../node_modules/picomatch/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/picomatch/lib/parse.js"(exports, module2) {
    "use strict";
    var constants = require_constants();
    var utils = require_utils();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v7) => utils.escapeRegex(v7)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse3 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n10 = 1) => input[state.index + n10];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate2 = () => {
        let count2 = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count2++;
        }
        if (count2 % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse3(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m10, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m10;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m10 : `\\${m10}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m10) => {
              return m10.length % 2 === 0 ? "\\\\" : m10 ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i10 = arr.length - 1; i10 >= 0; i10--) {
              tokens.pop();
              if (arr[i10].type === "brace") {
                break;
              }
              if (arr[i10].type !== "dots") {
                range.unshift(arr[i10].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t6 of toks) {
              state.output += t6.output || t6.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate2();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse3.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create10 = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create10(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create10(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse3;
  }
});

// ../../node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "../../node_modules/picomatch/lib/picomatch.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var scan2 = require_scan();
    var parse3 = require_parse();
    var utils = require_utils();
    var constants = require_constants();
    var isObject3 = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch2 = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch2(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject3(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch2.compileRe(glob, options) : picomatch2.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch2(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch2.test(input, regex, options, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch2.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch2.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch2.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch2.makeRe(glob, options);
      return regex.test(path.basename(input));
    };
    picomatch2.isMatch = (str, patterns, options) => picomatch2(patterns, options)(str);
    picomatch2.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p10) => picomatch2.parse(p10, options));
      return parse3(pattern, { ...options, fastpaths: false });
    };
    picomatch2.scan = (input, options) => scan2(input, options);
    picomatch2.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch2.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch2.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse3.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse3(input, options);
      }
      return picomatch2.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch2.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch2.constants = constants;
    module2.exports = picomatch2;
  }
});

// ../../node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "../../node_modules/picomatch/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});

// ../../node_modules/mime-db/db.json
var require_db = __commonJS({
  "../../node_modules/mime-db/db.json"(exports, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// ../../node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "../../node_modules/mime-db/index.js"(exports, module2) {
    module2.exports = require_db();
  }
});

// ../../node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "../../node_modules/mime-types/index.js"(exports) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset;
    exports.charsets = { lookup: charset };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = /* @__PURE__ */ Object.create(null);
    exports.lookup = lookup;
    exports.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports.extensions, exports.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime2 = match && db[match[1].toLowerCase()];
      if (mime2 && mime2.charset) {
        return mime2.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime2 = str.indexOf("/") === -1 ? exports.lookup(str) : str;
      if (!mime2) {
        return false;
      }
      if (mime2.indexOf("charset") === -1) {
        var charset2 = exports.charset(mime2);
        if (charset2)
          mime2 += "; charset=" + charset2.toLowerCase();
      }
      return mime2;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime2 = db[type];
        var exts = mime2.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i10 = 0; i10 < exts.length; i10++) {
          var extension2 = exts[i10];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime2.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// ../../node_modules/obliterator/iterator.js
var require_iterator = __commonJS({
  "../../node_modules/obliterator/iterator.js"(exports, module2) {
    function Iterator(next) {
      Object.defineProperty(this, "_next", {
        writable: false,
        enumerable: false,
        value: next
      });
      this.done = false;
    }
    Iterator.prototype.next = function() {
      if (this.done)
        return { done: true };
      var step = this._next();
      if (step.done)
        this.done = true;
      return step;
    };
    if (typeof Symbol !== "undefined")
      Iterator.prototype[Symbol.iterator] = function() {
        return this;
      };
    Iterator.of = function() {
      var args = arguments, l10 = args.length, i10 = 0;
      return new Iterator(function() {
        if (i10 >= l10)
          return { done: true };
        return { done: false, value: args[i10++] };
      });
    };
    Iterator.empty = function() {
      var iterator = new Iterator(null);
      iterator.done = true;
      return iterator;
    };
    Iterator.is = function(value) {
      if (value instanceof Iterator)
        return true;
      return typeof value === "object" && value !== null && typeof value.next === "function";
    };
    module2.exports = Iterator;
  }
});

// ../../node_modules/obliterator/foreach.js
var require_foreach = __commonJS({
  "../../node_modules/obliterator/foreach.js"(exports, module2) {
    var ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== "undefined";
    var SYMBOL_SUPPORT = typeof Symbol !== "undefined";
    function forEach2(iterable, callback) {
      var iterator, k10, i10, l10, s10;
      if (!iterable)
        throw new Error("obliterator/forEach: invalid iterable.");
      if (typeof callback !== "function")
        throw new Error("obliterator/forEach: expecting a callback.");
      if (Array.isArray(iterable) || ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(iterable) || typeof iterable === "string" || iterable.toString() === "[object Arguments]") {
        for (i10 = 0, l10 = iterable.length; i10 < l10; i10++)
          callback(iterable[i10], i10);
        return;
      }
      if (typeof iterable.forEach === "function") {
        iterable.forEach(callback);
        return;
      }
      if (SYMBOL_SUPPORT && Symbol.iterator in iterable && typeof iterable.next !== "function") {
        iterable = iterable[Symbol.iterator]();
      }
      if (typeof iterable.next === "function") {
        iterator = iterable;
        i10 = 0;
        while (s10 = iterator.next(), s10.done !== true) {
          callback(s10.value, i10);
          i10++;
        }
        return;
      }
      for (k10 in iterable) {
        if (iterable.hasOwnProperty(k10)) {
          callback(iterable[k10], k10);
        }
      }
      return;
    }
    forEach2.forEachWithNullKeys = function(iterable, callback) {
      var iterator, k10, i10, l10, s10;
      if (!iterable)
        throw new Error("obliterator/forEachWithNullKeys: invalid iterable.");
      if (typeof callback !== "function")
        throw new Error("obliterator/forEachWithNullKeys: expecting a callback.");
      if (Array.isArray(iterable) || ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(iterable) || typeof iterable === "string" || iterable.toString() === "[object Arguments]") {
        for (i10 = 0, l10 = iterable.length; i10 < l10; i10++)
          callback(iterable[i10], null);
        return;
      }
      if (iterable instanceof Set) {
        iterable.forEach(function(value) {
          callback(value, null);
        });
        return;
      }
      if (typeof iterable.forEach === "function") {
        iterable.forEach(callback);
        return;
      }
      if (SYMBOL_SUPPORT && Symbol.iterator in iterable && typeof iterable.next !== "function") {
        iterable = iterable[Symbol.iterator]();
      }
      if (typeof iterable.next === "function") {
        iterator = iterable;
        i10 = 0;
        while (s10 = iterator.next(), s10.done !== true) {
          callback(s10.value, null);
          i10++;
        }
        return;
      }
      for (k10 in iterable) {
        if (iterable.hasOwnProperty(k10)) {
          callback(iterable[k10], k10);
        }
      }
      return;
    };
    module2.exports = forEach2;
  }
});

// ../../node_modules/mnemonist/utils/typed-arrays.js
var require_typed_arrays = __commonJS({
  "../../node_modules/mnemonist/utils/typed-arrays.js"(exports) {
    var MAX_8BIT_INTEGER = Math.pow(2, 8) - 1;
    var MAX_16BIT_INTEGER = Math.pow(2, 16) - 1;
    var MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;
    var MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1;
    var MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1;
    var MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;
    exports.getPointerArray = function(size) {
      var maxIndex = size - 1;
      if (maxIndex <= MAX_8BIT_INTEGER)
        return Uint8Array;
      if (maxIndex <= MAX_16BIT_INTEGER)
        return Uint16Array;
      if (maxIndex <= MAX_32BIT_INTEGER)
        return Uint32Array;
      return Float64Array;
    };
    exports.getSignedPointerArray = function(size) {
      var maxIndex = size - 1;
      if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)
        return Int8Array;
      if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)
        return Int16Array;
      if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)
        return Int32Array;
      return Float64Array;
    };
    exports.getNumberType = function(value) {
      if (value === (value | 0)) {
        if (Math.sign(value) === -1) {
          if (value <= 127 && value >= -128)
            return Int8Array;
          if (value <= 32767 && value >= -32768)
            return Int16Array;
          return Int32Array;
        } else {
          if (value <= 255)
            return Uint8Array;
          if (value <= 65535)
            return Uint16Array;
          return Uint32Array;
        }
      }
      return Float64Array;
    };
    var TYPE_PRIORITY = {
      Uint8Array: 1,
      Int8Array: 2,
      Uint16Array: 3,
      Int16Array: 4,
      Uint32Array: 5,
      Int32Array: 6,
      Float32Array: 7,
      Float64Array: 8
    };
    exports.getMinimalRepresentation = function(array2, getter3) {
      var maxType = null, maxPriority = 0, p10, t6, v7, i10, l10;
      for (i10 = 0, l10 = array2.length; i10 < l10; i10++) {
        v7 = getter3 ? getter3(array2[i10]) : array2[i10];
        t6 = exports.getNumberType(v7);
        p10 = TYPE_PRIORITY[t6.name];
        if (p10 > maxPriority) {
          maxPriority = p10;
          maxType = t6;
        }
      }
      return maxType;
    };
    exports.isTypedArray = function(value) {
      return typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView(value);
    };
    exports.concat = function() {
      var length = 0, i10, o10, l10;
      for (i10 = 0, l10 = arguments.length; i10 < l10; i10++)
        length += arguments[i10].length;
      var array2 = new arguments[0].constructor(length);
      for (i10 = 0, o10 = 0; i10 < l10; i10++) {
        array2.set(arguments[i10], o10);
        o10 += arguments[i10].length;
      }
      return array2;
    };
    exports.indices = function(length) {
      var PointerArray = exports.getPointerArray(length);
      var array2 = new PointerArray(length);
      for (var i10 = 0; i10 < length; i10++)
        array2[i10] = i10;
      return array2;
    };
  }
});

// ../../node_modules/mnemonist/utils/iterables.js
var require_iterables = __commonJS({
  "../../node_modules/mnemonist/utils/iterables.js"(exports) {
    var forEach2 = require_foreach();
    var typed = require_typed_arrays();
    function isArrayLike(target) {
      return Array.isArray(target) || typed.isTypedArray(target);
    }
    function guessLength(target) {
      if (typeof target.length === "number")
        return target.length;
      if (typeof target.size === "number")
        return target.size;
      return;
    }
    function toArray2(target) {
      var l10 = guessLength(target);
      var array2 = typeof l10 === "number" ? new Array(l10) : [];
      var i10 = 0;
      forEach2(target, function(value) {
        array2[i10++] = value;
      });
      return array2;
    }
    function toArrayWithIndices(target) {
      var l10 = guessLength(target);
      var IndexArray = typeof l10 === "number" ? typed.getPointerArray(l10) : Array;
      var array2 = typeof l10 === "number" ? new Array(l10) : [];
      var indices = typeof l10 === "number" ? new IndexArray(l10) : [];
      var i10 = 0;
      forEach2(target, function(value) {
        array2[i10] = value;
        indices[i10] = i10++;
      });
      return [array2, indices];
    }
    exports.isArrayLike = isArrayLike;
    exports.guessLength = guessLength;
    exports.toArray = toArray2;
    exports.toArrayWithIndices = toArrayWithIndices;
  }
});

// ../../node_modules/mnemonist/lru-cache.js
var require_lru_cache = __commonJS({
  "../../node_modules/mnemonist/lru-cache.js"(exports, module2) {
    var Iterator = require_iterator();
    var forEach2 = require_foreach();
    var typed = require_typed_arrays();
    var iterables = require_iterables();
    function LRUCache2(Keys, Values, capacity) {
      if (arguments.length < 2) {
        capacity = Keys;
        Keys = null;
        Values = null;
      }
      this.capacity = capacity;
      if (typeof this.capacity !== "number" || this.capacity <= 0)
        throw new Error("mnemonist/lru-cache: capacity should be positive number.");
      var PointerArray = typed.getPointerArray(capacity);
      this.forward = new PointerArray(capacity);
      this.backward = new PointerArray(capacity);
      this.K = typeof Keys === "function" ? new Keys(capacity) : new Array(capacity);
      this.V = typeof Values === "function" ? new Values(capacity) : new Array(capacity);
      this.size = 0;
      this.head = 0;
      this.tail = 0;
      this.items = {};
    }
    LRUCache2.prototype.clear = function() {
      this.size = 0;
      this.head = 0;
      this.tail = 0;
      this.items = {};
    };
    LRUCache2.prototype.splayOnTop = function(pointer) {
      var oldHead = this.head;
      if (this.head === pointer)
        return this;
      var previous = this.backward[pointer], next = this.forward[pointer];
      if (this.tail === pointer) {
        this.tail = previous;
      } else {
        this.backward[next] = previous;
      }
      this.forward[previous] = next;
      this.backward[oldHead] = pointer;
      this.head = pointer;
      this.forward[pointer] = oldHead;
      return this;
    };
    LRUCache2.prototype.set = function(key, value) {
      var pointer = this.items[key];
      if (typeof pointer !== "undefined") {
        this.splayOnTop(pointer);
        this.V[pointer] = value;
        return;
      }
      if (this.size < this.capacity) {
        pointer = this.size++;
      } else {
        pointer = this.tail;
        this.tail = this.backward[pointer];
        delete this.items[this.K[pointer]];
      }
      this.items[key] = pointer;
      this.K[pointer] = key;
      this.V[pointer] = value;
      this.forward[pointer] = this.head;
      this.backward[this.head] = pointer;
      this.head = pointer;
    };
    LRUCache2.prototype.setpop = function(key, value) {
      var oldValue = null;
      var oldKey = null;
      var pointer = this.items[key];
      if (typeof pointer !== "undefined") {
        this.splayOnTop(pointer);
        oldValue = this.V[pointer];
        this.V[pointer] = value;
        return { evicted: false, key, value: oldValue };
      }
      if (this.size < this.capacity) {
        pointer = this.size++;
      } else {
        pointer = this.tail;
        this.tail = this.backward[pointer];
        oldValue = this.V[pointer];
        oldKey = this.K[pointer];
        delete this.items[this.K[pointer]];
      }
      this.items[key] = pointer;
      this.K[pointer] = key;
      this.V[pointer] = value;
      this.forward[pointer] = this.head;
      this.backward[this.head] = pointer;
      this.head = pointer;
      if (oldKey) {
        return { evicted: true, key: oldKey, value: oldValue };
      } else {
        return null;
      }
    };
    LRUCache2.prototype.has = function(key) {
      return key in this.items;
    };
    LRUCache2.prototype.get = function(key) {
      var pointer = this.items[key];
      if (typeof pointer === "undefined")
        return;
      this.splayOnTop(pointer);
      return this.V[pointer];
    };
    LRUCache2.prototype.peek = function(key) {
      var pointer = this.items[key];
      if (typeof pointer === "undefined")
        return;
      return this.V[pointer];
    };
    LRUCache2.prototype.forEach = function(callback, scope) {
      scope = arguments.length > 1 ? scope : this;
      var i10 = 0, l10 = this.size;
      var pointer = this.head, keys = this.K, values = this.V, forward = this.forward;
      while (i10 < l10) {
        callback.call(scope, values[pointer], keys[pointer], this);
        pointer = forward[pointer];
        i10++;
      }
    };
    LRUCache2.prototype.keys = function() {
      var i10 = 0, l10 = this.size;
      var pointer = this.head, keys = this.K, forward = this.forward;
      return new Iterator(function() {
        if (i10 >= l10)
          return { done: true };
        var key = keys[pointer];
        i10++;
        if (i10 < l10)
          pointer = forward[pointer];
        return {
          done: false,
          value: key
        };
      });
    };
    LRUCache2.prototype.values = function() {
      var i10 = 0, l10 = this.size;
      var pointer = this.head, values = this.V, forward = this.forward;
      return new Iterator(function() {
        if (i10 >= l10)
          return { done: true };
        var value = values[pointer];
        i10++;
        if (i10 < l10)
          pointer = forward[pointer];
        return {
          done: false,
          value
        };
      });
    };
    LRUCache2.prototype.entries = function() {
      var i10 = 0, l10 = this.size;
      var pointer = this.head, keys = this.K, values = this.V, forward = this.forward;
      return new Iterator(function() {
        if (i10 >= l10)
          return { done: true };
        var key = keys[pointer], value = values[pointer];
        i10++;
        if (i10 < l10)
          pointer = forward[pointer];
        return {
          done: false,
          value: [key, value]
        };
      });
    };
    if (typeof Symbol !== "undefined")
      LRUCache2.prototype[Symbol.iterator] = LRUCache2.prototype.entries;
    LRUCache2.prototype.inspect = function() {
      var proxy = /* @__PURE__ */ new Map();
      var iterator = this.entries(), step;
      while (step = iterator.next(), !step.done)
        proxy.set(step.value[0], step.value[1]);
      Object.defineProperty(proxy, "constructor", {
        value: LRUCache2,
        enumerable: false
      });
      return proxy;
    };
    if (typeof Symbol !== "undefined")
      LRUCache2.prototype[Symbol.for("nodejs.util.inspect.custom")] = LRUCache2.prototype.inspect;
    LRUCache2.from = function(iterable, Keys, Values, capacity) {
      if (arguments.length < 2) {
        capacity = iterables.guessLength(iterable);
        if (typeof capacity !== "number")
          throw new Error("mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.");
      } else if (arguments.length === 2) {
        capacity = Keys;
        Keys = null;
        Values = null;
      }
      var cache = new LRUCache2(Keys, Values, capacity);
      forEach2(iterable, function(value, key) {
        cache.set(key, value);
      });
      return cache;
    };
    module2.exports = LRUCache2;
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/util.js
var require_util2 = __commonJS({
  "../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/util.js"(exports) {
    "use strict";
    var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
    var regexName = new RegExp("^" + nameRegexp + "$");
    var getAllMatches = function(string2, regex) {
      const matches = [];
      let match = regex.exec(string2);
      while (match) {
        const allmatches = [];
        allmatches.startIndex = regex.lastIndex - match[0].length;
        const len = match.length;
        for (let index = 0; index < len; index++) {
          allmatches.push(match[index]);
        }
        matches.push(allmatches);
        match = regex.exec(string2);
      }
      return matches;
    };
    var isName = function(string2) {
      const match = regexName.exec(string2);
      return !(match === null || typeof match === "undefined");
    };
    exports.isExist = function(v7) {
      return typeof v7 !== "undefined";
    };
    exports.isEmptyObject = function(obj) {
      return Object.keys(obj).length === 0;
    };
    exports.merge = function(target, a10, arrayMode) {
      if (a10) {
        const keys = Object.keys(a10);
        const len = keys.length;
        for (let i10 = 0; i10 < len; i10++) {
          if (arrayMode === "strict") {
            target[keys[i10]] = [a10[keys[i10]]];
          } else {
            target[keys[i10]] = a10[keys[i10]];
          }
        }
      }
    };
    exports.getValue = function(v7) {
      if (exports.isExist(v7)) {
        return v7;
      } else {
        return "";
      }
    };
    exports.isName = isName;
    exports.getAllMatches = getAllMatches;
    exports.nameRegexp = nameRegexp;
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/validator.js
var require_validator2 = __commonJS({
  "../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/validator.js"(exports) {
    "use strict";
    var util = require_util2();
    var defaultOptions = {
      allowBooleanAttributes: false,
      //A tag can have attributes without any value
      unpairedTags: []
    };
    exports.validate = function(xmlData, options) {
      options = Object.assign({}, defaultOptions, options);
      const tags = [];
      let tagFound = false;
      let reachedRoot = false;
      if (xmlData[0] === "\uFEFF") {
        xmlData = xmlData.substr(1);
      }
      for (let i10 = 0; i10 < xmlData.length; i10++) {
        if (xmlData[i10] === "<" && xmlData[i10 + 1] === "?") {
          i10 += 2;
          i10 = readPI(xmlData, i10);
          if (i10.err)
            return i10;
        } else if (xmlData[i10] === "<") {
          let tagStartPos = i10;
          i10++;
          if (xmlData[i10] === "!") {
            i10 = readCommentAndCDATA(xmlData, i10);
            continue;
          } else {
            let closingTag = false;
            if (xmlData[i10] === "/") {
              closingTag = true;
              i10++;
            }
            let tagName = "";
            for (; i10 < xmlData.length && xmlData[i10] !== ">" && xmlData[i10] !== " " && xmlData[i10] !== "	" && xmlData[i10] !== "\n" && xmlData[i10] !== "\r"; i10++) {
              tagName += xmlData[i10];
            }
            tagName = tagName.trim();
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substring(0, tagName.length - 1);
              i10--;
            }
            if (!validateTagName(tagName)) {
              let msg;
              if (tagName.trim().length === 0) {
                msg = "Invalid space after '<'.";
              } else {
                msg = "Tag '" + tagName + "' is an invalid name.";
              }
              return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i10));
            }
            const result = readAttributeStr(xmlData, i10);
            if (result === false) {
              return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i10));
            }
            let attrStr = result.value;
            i10 = result.index;
            if (attrStr[attrStr.length - 1] === "/") {
              const attrStrStart = i10 - attrStr.length;
              attrStr = attrStr.substring(0, attrStr.length - 1);
              const isValid = validateAttributeString(attrStr, options);
              if (isValid === true) {
                tagFound = true;
              } else {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
              }
            } else if (closingTag) {
              if (!result.tagClosed) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i10));
              } else if (attrStr.trim().length > 0) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
              } else {
                const otg = tags.pop();
                if (tagName !== otg.tagName) {
                  let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                  return getErrorObject(
                    "InvalidTag",
                    "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                    getLineNumberForPosition(xmlData, tagStartPos)
                  );
                }
                if (tags.length == 0) {
                  reachedRoot = true;
                }
              }
            } else {
              const isValid = validateAttributeString(attrStr, options);
              if (isValid !== true) {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i10 - attrStr.length + isValid.err.line));
              }
              if (reachedRoot === true) {
                return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i10));
              } else if (options.unpairedTags.indexOf(tagName) !== -1) {
              } else {
                tags.push({ tagName, tagStartPos });
              }
              tagFound = true;
            }
            for (i10++; i10 < xmlData.length; i10++) {
              if (xmlData[i10] === "<") {
                if (xmlData[i10 + 1] === "!") {
                  i10++;
                  i10 = readCommentAndCDATA(xmlData, i10);
                  continue;
                } else if (xmlData[i10 + 1] === "?") {
                  i10 = readPI(xmlData, ++i10);
                  if (i10.err)
                    return i10;
                } else {
                  break;
                }
              } else if (xmlData[i10] === "&") {
                const afterAmp = validateAmpersand(xmlData, i10);
                if (afterAmp == -1)
                  return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i10));
                i10 = afterAmp;
              } else {
                if (reachedRoot === true && !isWhiteSpace(xmlData[i10])) {
                  return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i10));
                }
              }
            }
            if (xmlData[i10] === "<") {
              i10--;
            }
          }
        } else {
          if (isWhiteSpace(xmlData[i10])) {
            continue;
          }
          return getErrorObject("InvalidChar", "char '" + xmlData[i10] + "' is not expected.", getLineNumberForPosition(xmlData, i10));
        }
      }
      if (!tagFound) {
        return getErrorObject("InvalidXml", "Start tag expected.", 1);
      } else if (tags.length == 1) {
        return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
      } else if (tags.length > 0) {
        return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t6) => t6.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
      }
      return true;
    };
    function isWhiteSpace(char) {
      return char === " " || char === "	" || char === "\n" || char === "\r";
    }
    function readPI(xmlData, i10) {
      const start = i10;
      for (; i10 < xmlData.length; i10++) {
        if (xmlData[i10] == "?" || xmlData[i10] == " ") {
          const tagname = xmlData.substr(start, i10 - start);
          if (i10 > 5 && tagname === "xml") {
            return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i10));
          } else if (xmlData[i10] == "?" && xmlData[i10 + 1] == ">") {
            i10++;
            break;
          } else {
            continue;
          }
        }
      }
      return i10;
    }
    function readCommentAndCDATA(xmlData, i10) {
      if (xmlData.length > i10 + 5 && xmlData[i10 + 1] === "-" && xmlData[i10 + 2] === "-") {
        for (i10 += 3; i10 < xmlData.length; i10++) {
          if (xmlData[i10] === "-" && xmlData[i10 + 1] === "-" && xmlData[i10 + 2] === ">") {
            i10 += 2;
            break;
          }
        }
      } else if (xmlData.length > i10 + 8 && xmlData[i10 + 1] === "D" && xmlData[i10 + 2] === "O" && xmlData[i10 + 3] === "C" && xmlData[i10 + 4] === "T" && xmlData[i10 + 5] === "Y" && xmlData[i10 + 6] === "P" && xmlData[i10 + 7] === "E") {
        let angleBracketsCount = 1;
        for (i10 += 8; i10 < xmlData.length; i10++) {
          if (xmlData[i10] === "<") {
            angleBracketsCount++;
          } else if (xmlData[i10] === ">") {
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          }
        }
      } else if (xmlData.length > i10 + 9 && xmlData[i10 + 1] === "[" && xmlData[i10 + 2] === "C" && xmlData[i10 + 3] === "D" && xmlData[i10 + 4] === "A" && xmlData[i10 + 5] === "T" && xmlData[i10 + 6] === "A" && xmlData[i10 + 7] === "[") {
        for (i10 += 8; i10 < xmlData.length; i10++) {
          if (xmlData[i10] === "]" && xmlData[i10 + 1] === "]" && xmlData[i10 + 2] === ">") {
            i10 += 2;
            break;
          }
        }
      }
      return i10;
    }
    var doubleQuote = '"';
    var singleQuote = "'";
    function readAttributeStr(xmlData, i10) {
      let attrStr = "";
      let startChar = "";
      let tagClosed = false;
      for (; i10 < xmlData.length; i10++) {
        if (xmlData[i10] === doubleQuote || xmlData[i10] === singleQuote) {
          if (startChar === "") {
            startChar = xmlData[i10];
          } else if (startChar !== xmlData[i10]) {
          } else {
            startChar = "";
          }
        } else if (xmlData[i10] === ">") {
          if (startChar === "") {
            tagClosed = true;
            break;
          }
        }
        attrStr += xmlData[i10];
      }
      if (startChar !== "") {
        return false;
      }
      return {
        value: attrStr,
        index: i10,
        tagClosed
      };
    }
    var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function validateAttributeString(attrStr, options) {
      const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
      const attrNames = {};
      for (let i10 = 0; i10 < matches.length; i10++) {
        if (matches[i10][1].length === 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i10][2] + "' has no space in starting.", getPositionFromMatch(matches[i10]));
        } else if (matches[i10][3] !== void 0 && matches[i10][4] === void 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i10][2] + "' is without value.", getPositionFromMatch(matches[i10]));
        } else if (matches[i10][3] === void 0 && !options.allowBooleanAttributes) {
          return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i10][2] + "' is not allowed.", getPositionFromMatch(matches[i10]));
        }
        const attrName = matches[i10][2];
        if (!validateAttrName(attrName)) {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i10]));
        }
        if (!attrNames.hasOwnProperty(attrName)) {
          attrNames[attrName] = 1;
        } else {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i10]));
        }
      }
      return true;
    }
    function validateNumberAmpersand(xmlData, i10) {
      let re = /\d/;
      if (xmlData[i10] === "x") {
        i10++;
        re = /[\da-fA-F]/;
      }
      for (; i10 < xmlData.length; i10++) {
        if (xmlData[i10] === ";")
          return i10;
        if (!xmlData[i10].match(re))
          break;
      }
      return -1;
    }
    function validateAmpersand(xmlData, i10) {
      i10++;
      if (xmlData[i10] === ";")
        return -1;
      if (xmlData[i10] === "#") {
        i10++;
        return validateNumberAmpersand(xmlData, i10);
      }
      let count2 = 0;
      for (; i10 < xmlData.length; i10++, count2++) {
        if (xmlData[i10].match(/\w/) && count2 < 20)
          continue;
        if (xmlData[i10] === ";")
          break;
        return -1;
      }
      return i10;
    }
    function getErrorObject(code, message, lineNumber) {
      return {
        err: {
          code,
          msg: message,
          line: lineNumber.line || lineNumber,
          col: lineNumber.col
        }
      };
    }
    function validateAttrName(attrName) {
      return util.isName(attrName);
    }
    function validateTagName(tagname) {
      return util.isName(tagname);
    }
    function getLineNumberForPosition(xmlData, index) {
      const lines = xmlData.substring(0, index).split(/\r?\n/);
      return {
        line: lines.length,
        // column number is last line's length + 1, because column numbering starts at 1:
        col: lines[lines.length - 1].length + 1
      };
    }
    function getPositionFromMatch(match) {
      return match.startIndex + match[1].length;
    }
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder2 = __commonJS({
  "../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
    var defaultOptions = {
      preserveOrder: false,
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      removeNSPrefix: false,
      // remove NS from tag name or attribute name if true
      allowBooleanAttributes: false,
      //a tag can have attributes without any value
      //ignoreRootElement : false,
      parseTagValue: true,
      parseAttributeValue: false,
      trimValues: true,
      //Trim string values of tag and attributes
      cdataPropName: false,
      numberParseOptions: {
        hex: true,
        leadingZeros: true,
        eNotation: true
      },
      tagValueProcessor: function(tagName, val) {
        return val;
      },
      attributeValueProcessor: function(attrName, val) {
        return val;
      },
      stopNodes: [],
      //nested tags will not be parsed even for errors
      alwaysCreateTextNode: false,
      isArray: () => false,
      commentPropName: false,
      unpairedTags: [],
      processEntities: true,
      htmlEntities: false,
      ignoreDeclaration: false,
      ignorePiTags: false,
      transformTagName: false,
      transformAttributeName: false
    };
    var buildOptions = function(options) {
      return Object.assign({}, defaultOptions, options);
    };
    exports.buildOptions = buildOptions;
    exports.defaultOptions = defaultOptions;
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode2 = __commonJS({
  "../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module2) {
    "use strict";
    var XmlNode2 = class {
      constructor(tagname) {
        this.tagname = tagname;
        this.child = [];
        this[":@"] = {};
      }
      add(key, val) {
        if (key === "__proto__")
          key = "#__proto__";
        this.child.push({ [key]: val });
      }
      addChild(node) {
        if (node.tagname === "__proto__")
          node.tagname = "#__proto__";
        if (node[":@"] && Object.keys(node[":@"]).length > 0) {
          this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
        } else {
          this.child.push({ [node.tagname]: node.child });
        }
      }
    };
    module2.exports = XmlNode2;
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader2 = __commonJS({
  "../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module2) {
    function readDocType(xmlData, i10) {
      const entities = {};
      if (xmlData[i10 + 3] === "O" && xmlData[i10 + 4] === "C" && xmlData[i10 + 5] === "T" && xmlData[i10 + 6] === "Y" && xmlData[i10 + 7] === "P" && xmlData[i10 + 8] === "E") {
        i10 = i10 + 9;
        let angleBracketsCount = 1;
        let hasBody = false, entity = false, comment = false;
        let exp = "";
        for (; i10 < xmlData.length; i10++) {
          if (xmlData[i10] === "<" && !comment) {
            if (hasBody && xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "E" && xmlData[i10 + 3] === "N" && xmlData[i10 + 4] === "T" && xmlData[i10 + 5] === "I" && xmlData[i10 + 6] === "T" && xmlData[i10 + 7] === "Y") {
              i10 += 7;
              entity = true;
            } else if (hasBody && xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "E" && xmlData[i10 + 3] === "L" && xmlData[i10 + 4] === "E" && xmlData[i10 + 5] === "M" && xmlData[i10 + 6] === "E" && xmlData[i10 + 7] === "N" && xmlData[i10 + 8] === "T") {
              i10 += 8;
            } else if (hasBody && xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "A" && xmlData[i10 + 3] === "T" && xmlData[i10 + 4] === "T" && xmlData[i10 + 5] === "L" && xmlData[i10 + 6] === "I" && xmlData[i10 + 7] === "S" && xmlData[i10 + 8] === "T") {
              i10 += 8;
            } else if (hasBody && xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "N" && xmlData[i10 + 3] === "O" && xmlData[i10 + 4] === "T" && xmlData[i10 + 5] === "A" && xmlData[i10 + 6] === "T" && xmlData[i10 + 7] === "I" && xmlData[i10 + 8] === "O" && xmlData[i10 + 9] === "N") {
              i10 += 9;
            } else if (
              //comment
              xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "-" && xmlData[i10 + 3] === "-"
            ) {
              comment = true;
            } else {
              throw new Error("Invalid DOCTYPE");
            }
            angleBracketsCount++;
            exp = "";
          } else if (xmlData[i10] === ">") {
            if (comment) {
              if (xmlData[i10 - 1] === "-" && xmlData[i10 - 2] === "-") {
                comment = false;
                angleBracketsCount--;
              }
            } else {
              if (entity) {
                parseEntityExp(exp, entities);
                entity = false;
              }
              angleBracketsCount--;
            }
            if (angleBracketsCount === 0) {
              break;
            }
          } else if (xmlData[i10] === "[") {
            hasBody = true;
          } else {
            exp += xmlData[i10];
          }
        }
        if (angleBracketsCount !== 0) {
          throw new Error(`Unclosed DOCTYPE`);
        }
      } else {
        throw new Error(`Invalid Tag instead of DOCTYPE`);
      }
      return { entities, i: i10 };
    }
    var entityRegex = RegExp(`^\\s([a-zA-z0-0]+)[ 	](['"])([^&]+)\\2`);
    function parseEntityExp(exp, entities) {
      const match = entityRegex.exec(exp);
      if (match) {
        entities[match[1]] = {
          regx: RegExp(`&${match[1]};`, "g"),
          val: match[3]
        };
      }
    }
    module2.exports = readDocType;
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser2 = __commonJS({
  "../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module2) {
    "use strict";
    var util = require_util2();
    var xmlNode = require_xmlNode2();
    var readDocType = require_DocTypeReader2();
    var toNumber = require_strnum();
    var regx = "<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, util.nameRegexp);
    var OrderedObjParser = class {
      constructor(options) {
        this.options = options;
        this.currentNode = null;
        this.tagsNodeStack = [];
        this.docTypeEntities = {};
        this.lastEntities = {
          "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
          "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
          "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
          "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
        };
        this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
        this.htmlEntities = {
          "space": { regex: /&(nbsp|#160);/g, val: " " },
          // "lt" : { regex: /&(lt|#60);/g, val: "<" },
          // "gt" : { regex: /&(gt|#62);/g, val: ">" },
          // "amp" : { regex: /&(amp|#38);/g, val: "&" },
          // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
          // "apos" : { regex: /&(apos|#39);/g, val: "'" },
          "cent": { regex: /&(cent|#162);/g, val: "\xA2" },
          "pound": { regex: /&(pound|#163);/g, val: "\xA3" },
          "yen": { regex: /&(yen|#165);/g, val: "\xA5" },
          "euro": { regex: /&(euro|#8364);/g, val: "\u20AC" },
          "copyright": { regex: /&(copy|#169);/g, val: "\xA9" },
          "reg": { regex: /&(reg|#174);/g, val: "\xAE" },
          "inr": { regex: /&(inr|#8377);/g, val: "\u20B9" }
        };
        this.addExternalEntities = addExternalEntities;
        this.parseXml = parseXml;
        this.parseTextData = parseTextData;
        this.resolveNameSpace = resolveNameSpace;
        this.buildAttributesMap = buildAttributesMap;
        this.isItStopNode = isItStopNode;
        this.replaceEntitiesValue = replaceEntitiesValue;
        this.readStopNodeData = readStopNodeData;
        this.saveTextToParentTag = saveTextToParentTag;
      }
    };
    function addExternalEntities(externalEntities) {
      const entKeys = Object.keys(externalEntities);
      for (let i10 = 0; i10 < entKeys.length; i10++) {
        const ent = entKeys[i10];
        this.lastEntities[ent] = {
          regex: new RegExp("&" + ent + ";", "g"),
          val: externalEntities[ent]
        };
      }
    }
    function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
      if (val !== void 0) {
        if (this.options.trimValues && !dontTrim) {
          val = val.trim();
        }
        if (val.length > 0) {
          if (!escapeEntities)
            val = this.replaceEntitiesValue(val);
          const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
          if (newval === null || newval === void 0) {
            return val;
          } else if (typeof newval !== typeof val || newval !== val) {
            return newval;
          } else if (this.options.trimValues) {
            return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            const trimmedVal = val.trim();
            if (trimmedVal === val) {
              return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              return val;
            }
          }
        }
      }
    }
    function resolveNameSpace(tagname) {
      if (this.options.removeNSPrefix) {
        const tags = tagname.split(":");
        const prefix = tagname.charAt(0) === "/" ? "/" : "";
        if (tags[0] === "xmlns") {
          return "";
        }
        if (tags.length === 2) {
          tagname = prefix + tags[1];
        }
      }
      return tagname;
    }
    var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function buildAttributesMap(attrStr, jPath) {
      if (!this.options.ignoreAttributes && typeof attrStr === "string") {
        const matches = util.getAllMatches(attrStr, attrsRegx);
        const len = matches.length;
        const attrs = {};
        for (let i10 = 0; i10 < len; i10++) {
          const attrName = this.resolveNameSpace(matches[i10][1]);
          let oldVal = matches[i10][4];
          let aName = this.options.attributeNamePrefix + attrName;
          if (attrName.length) {
            if (this.options.transformAttributeName) {
              aName = this.options.transformAttributeName(aName);
            }
            if (aName === "__proto__")
              aName = "#__proto__";
            if (oldVal !== void 0) {
              if (this.options.trimValues) {
                oldVal = oldVal.trim();
              }
              oldVal = this.replaceEntitiesValue(oldVal);
              const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
              if (newVal === null || newVal === void 0) {
                attrs[aName] = oldVal;
              } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                attrs[aName] = newVal;
              } else {
                attrs[aName] = parseValue(
                  oldVal,
                  this.options.parseAttributeValue,
                  this.options.numberParseOptions
                );
              }
            } else if (this.options.allowBooleanAttributes) {
              attrs[aName] = true;
            }
          }
        }
        if (!Object.keys(attrs).length) {
          return;
        }
        if (this.options.attributesGroupName) {
          const attrCollection = {};
          attrCollection[this.options.attributesGroupName] = attrs;
          return attrCollection;
        }
        return attrs;
      }
    }
    var parseXml = function(xmlData) {
      xmlData = xmlData.replace(/\r\n?/g, "\n");
      const xmlObj = new xmlNode("!xml");
      let currentNode = xmlObj;
      let textData = "";
      let jPath = "";
      for (let i10 = 0; i10 < xmlData.length; i10++) {
        const ch2 = xmlData[i10];
        if (ch2 === "<") {
          if (xmlData[i10 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i10, "Closing Tag is not closed.");
            let tagName = xmlData.substring(i10 + 2, closeIndex).trim();
            if (this.options.removeNSPrefix) {
              const colonIndex = tagName.indexOf(":");
              if (colonIndex !== -1) {
                tagName = tagName.substr(colonIndex + 1);
              }
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode) {
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
            }
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
            currentNode = this.tagsNodeStack.pop();
            textData = "";
            i10 = closeIndex;
          } else if (xmlData[i10 + 1] === "?") {
            let tagData = readTagExp(xmlData, i10, false, "?>");
            if (!tagData)
              throw new Error("Pi Tag is not closed.");
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
            } else {
              const childNode = new xmlNode(tagData.tagName);
              childNode.add(this.options.textNodeName, "");
              if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath);
              }
              currentNode.addChild(childNode);
            }
            i10 = tagData.closeIndex + 1;
          } else if (xmlData.substr(i10 + 1, 3) === "!--") {
            const endIndex = findClosingIndex(xmlData, "-->", i10 + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              const comment = xmlData.substring(i10 + 4, endIndex - 2);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
            }
            i10 = endIndex;
          } else if (xmlData.substr(i10 + 1, 2) === "!D") {
            const result = readDocType(xmlData, i10);
            this.docTypeEntities = result.entities;
            i10 = result.i;
          } else if (xmlData.substr(i10 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i10, "CDATA is not closed.") - 2;
            const tagExp = xmlData.substring(i10 + 9, closeIndex);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.cdataPropName) {
              currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
            } else {
              let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
              if (val == void 0)
                val = "";
              currentNode.add(this.options.textNodeName, val);
            }
            i10 = closeIndex + 2;
          } else {
            let result = readTagExp(xmlData, i10, this.options.removeNSPrefix);
            let tagName = result.tagName;
            let tagExp = result.tagExp;
            let attrExpPresent = result.attrExpPresent;
            let closeIndex = result.closeIndex;
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode && textData) {
              if (currentNode.tagname !== "!xml") {
                textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
              }
            }
            if (tagName !== xmlObj.tagname) {
              jPath += jPath ? "." + tagName : tagName;
            }
            const lastTag = currentNode;
            if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
              currentNode = this.tagsNodeStack.pop();
            }
            if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
              let tagContent = "";
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                i10 = result.closeIndex;
              } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                i10 = result.closeIndex;
              } else {
                const result2 = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
                if (!result2)
                  throw new Error(`Unexpected end of ${tagName}`);
                i10 = result2.i;
                tagContent = result2.tagContent;
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
              }
              if (tagContent) {
                tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
              }
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
              childNode.add(this.options.textNodeName, tagContent);
              currentNode.addChild(childNode);
            } else {
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                if (this.options.transformTagName) {
                  tagName = this.options.transformTagName(tagName);
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
                }
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
                currentNode.addChild(childNode);
              } else {
                const childNode = new xmlNode(tagName);
                this.tagsNodeStack.push(currentNode);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
                }
                currentNode.addChild(childNode);
                currentNode = childNode;
              }
              textData = "";
              i10 = closeIndex;
            }
          }
        } else {
          textData += xmlData[i10];
        }
      }
      return xmlObj.child;
    };
    var replaceEntitiesValue = function(val) {
      if (this.options.processEntities) {
        for (let entityName in this.docTypeEntities) {
          const entity = this.docTypeEntities[entityName];
          val = val.replace(entity.regx, entity.val);
        }
        for (let entityName in this.lastEntities) {
          const entity = this.lastEntities[entityName];
          val = val.replace(entity.regex, entity.val);
        }
        if (this.options.htmlEntities) {
          for (let entityName in this.htmlEntities) {
            const entity = this.htmlEntities[entityName];
            val = val.replace(entity.regex, entity.val);
          }
        }
        val = val.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return val;
    };
    function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
      if (textData) {
        if (isLeafNode === void 0)
          isLeafNode = Object.keys(currentNode.child).length === 0;
        textData = this.parseTextData(
          textData,
          currentNode.tagname,
          jPath,
          false,
          currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
          isLeafNode
        );
        if (textData !== void 0 && textData !== "")
          currentNode.add(this.options.textNodeName, textData);
        textData = "";
      }
      return textData;
    }
    function isItStopNode(stopNodes, jPath, currentTagName) {
      const allNodesExp = "*." + currentTagName;
      for (const stopNodePath in stopNodes) {
        const stopNodeExp = stopNodes[stopNodePath];
        if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
          return true;
      }
      return false;
    }
    function tagExpWithClosingIndex(xmlData, i10, closingChar = ">") {
      let attrBoundary;
      let tagExp = "";
      for (let index = i10; index < xmlData.length; index++) {
        let ch2 = xmlData[index];
        if (attrBoundary) {
          if (ch2 === attrBoundary)
            attrBoundary = "";
        } else if (ch2 === '"' || ch2 === "'") {
          attrBoundary = ch2;
        } else if (ch2 === closingChar[0]) {
          if (closingChar[1]) {
            if (xmlData[index + 1] === closingChar[1]) {
              return {
                data: tagExp,
                index
              };
            }
          } else {
            return {
              data: tagExp,
              index
            };
          }
        } else if (ch2 === "	") {
          ch2 = " ";
        }
        tagExp += ch2;
      }
    }
    function findClosingIndex(xmlData, str, i10, errMsg) {
      const closingIndex = xmlData.indexOf(str, i10);
      if (closingIndex === -1) {
        throw new Error(errMsg);
      } else {
        return closingIndex + str.length - 1;
      }
    }
    function readTagExp(xmlData, i10, removeNSPrefix, closingChar = ">") {
      const result = tagExpWithClosingIndex(xmlData, i10 + 1, closingChar);
      if (!result)
        return;
      let tagExp = result.data;
      const closeIndex = result.index;
      const separatorIndex = tagExp.search(/\s/);
      let tagName = tagExp;
      let attrExpPresent = true;
      if (separatorIndex !== -1) {
        tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, "");
        tagExp = tagExp.substr(separatorIndex + 1);
      }
      if (removeNSPrefix) {
        const colonIndex = tagName.indexOf(":");
        if (colonIndex !== -1) {
          tagName = tagName.substr(colonIndex + 1);
          attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
        }
      }
      return {
        tagName,
        tagExp,
        closeIndex,
        attrExpPresent
      };
    }
    function readStopNodeData(xmlData, tagName, i10) {
      const startIndex = i10;
      let openTagCount = 1;
      for (; i10 < xmlData.length; i10++) {
        if (xmlData[i10] === "<") {
          if (xmlData[i10 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i10, `${tagName} is not closed`);
            let closeTagName = xmlData.substring(i10 + 2, closeIndex).trim();
            if (closeTagName === tagName) {
              openTagCount--;
              if (openTagCount === 0) {
                return {
                  tagContent: xmlData.substring(startIndex, i10),
                  i: closeIndex
                };
              }
            }
            i10 = closeIndex;
          } else if (xmlData[i10 + 1] === "?") {
            const closeIndex = findClosingIndex(xmlData, "?>", i10 + 1, "StopNode is not closed.");
            i10 = closeIndex;
          } else if (xmlData.substr(i10 + 1, 3) === "!--") {
            const closeIndex = findClosingIndex(xmlData, "-->", i10 + 3, "StopNode is not closed.");
            i10 = closeIndex;
          } else if (xmlData.substr(i10 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i10, "StopNode is not closed.") - 2;
            i10 = closeIndex;
          } else {
            const tagData = readTagExp(xmlData, i10, ">");
            if (tagData) {
              const openTagName = tagData && tagData.tagName;
              if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                openTagCount++;
              }
              i10 = tagData.closeIndex;
            }
          }
        }
      }
    }
    function parseValue(val, shouldParse, options) {
      if (shouldParse && typeof val === "string") {
        const newval = val.trim();
        if (newval === "true")
          return true;
        else if (newval === "false")
          return false;
        else
          return toNumber(val, options);
      } else {
        if (util.isExist(val)) {
          return val;
        } else {
          return "";
        }
      }
    }
    module2.exports = OrderedObjParser;
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json2 = __commonJS({
  "../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
    "use strict";
    function prettify(node, options) {
      return compress(node, options);
    }
    function compress(arr, options, jPath) {
      let text;
      const compressedObj = {};
      for (let i10 = 0; i10 < arr.length; i10++) {
        const tagObj = arr[i10];
        const property = propName(tagObj);
        let newJpath = "";
        if (jPath === void 0)
          newJpath = property;
        else
          newJpath = jPath + "." + property;
        if (property === options.textNodeName) {
          if (text === void 0)
            text = tagObj[property];
          else
            text += "" + tagObj[property];
        } else if (property === void 0) {
          continue;
        } else if (tagObj[property]) {
          let val = compress(tagObj[property], options, newJpath);
          const isLeaf = isLeafTag(val, options);
          if (tagObj[":@"]) {
            assignAttributes(val, tagObj[":@"], newJpath, options);
          } else if (Object.keys(val).length === 1 && val[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
            val = val[options.textNodeName];
          } else if (Object.keys(val).length === 0) {
            if (options.alwaysCreateTextNode)
              val[options.textNodeName] = "";
            else
              val = "";
          }
          if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
            if (!Array.isArray(compressedObj[property])) {
              compressedObj[property] = [compressedObj[property]];
            }
            compressedObj[property].push(val);
          } else {
            if (options.isArray(property, newJpath, isLeaf)) {
              compressedObj[property] = [val];
            } else {
              compressedObj[property] = val;
            }
          }
        }
      }
      if (typeof text === "string") {
        if (text.length > 0)
          compressedObj[options.textNodeName] = text;
      } else if (text !== void 0)
        compressedObj[options.textNodeName] = text;
      return compressedObj;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i10 = 0; i10 < keys.length; i10++) {
        const key = keys[i10];
        if (key !== ":@")
          return key;
      }
    }
    function assignAttributes(obj, attrMap, jpath, options) {
      if (attrMap) {
        const keys = Object.keys(attrMap);
        const len = keys.length;
        for (let i10 = 0; i10 < len; i10++) {
          const atrrName = keys[i10];
          if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
            obj[atrrName] = [attrMap[atrrName]];
          } else {
            obj[atrrName] = attrMap[atrrName];
          }
        }
      }
    }
    function isLeafTag(obj, options) {
      const propCount = Object.keys(obj).length;
      if (propCount === 0 || propCount === 1 && obj[options.textNodeName])
        return true;
      return false;
    }
    exports.prettify = prettify;
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser2 = __commonJS({
  "../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module2) {
    var { buildOptions } = require_OptionsBuilder2();
    var OrderedObjParser = require_OrderedObjParser2();
    var { prettify } = require_node2json2();
    var validator = require_validator2();
    var XMLParser5 = class {
      constructor(options) {
        this.externalEntities = {};
        this.options = buildOptions(options);
      }
      /**
       * Parse XML dats to JS object 
       * @param {string|Buffer} xmlData 
       * @param {boolean|Object} validationOption 
       */
      parse(xmlData, validationOption) {
        if (typeof xmlData === "string") {
        } else if (xmlData.toString) {
          xmlData = xmlData.toString();
        } else {
          throw new Error("XML data is accepted in String or Bytes[] form.");
        }
        if (validationOption) {
          if (validationOption === true)
            validationOption = {};
          const result = validator.validate(xmlData, validationOption);
          if (result !== true) {
            throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
          }
        }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if (this.options.preserveOrder || orderedResult === void 0)
          return orderedResult;
        else
          return prettify(orderedResult, this.options);
      }
      /**
       * Add Entity which is not by default supported by this library
       * @param {string} key 
       * @param {string} value 
       */
      addEntity(key, value) {
        if (value.indexOf("&") !== -1) {
          throw new Error("Entity value can't have '&'");
        } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
          throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        } else if (value === "&") {
          throw new Error("An entity with value '&' is not permitted");
        } else {
          this.externalEntities[key] = value;
        }
      }
    };
    module2.exports = XMLParser5;
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml2 = __commonJS({
  "../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module2) {
    var EOL = "\n";
    function toXml(jArray, options) {
      let indentation = "";
      if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
      }
      return arrToStr(jArray, options, "", indentation);
    }
    function arrToStr(arr, options, jPath, indentation) {
      let xmlStr = "";
      let isPreviousElementTag = false;
      for (let i10 = 0; i10 < arr.length; i10++) {
        const tagObj = arr[i10];
        const tagName = propName(tagObj);
        let newJPath = "";
        if (jPath.length === 0)
          newJPath = tagName;
        else
          newJPath = `${jPath}.${tagName}`;
        if (tagName === options.textNodeName) {
          let tagText = tagObj[tagName];
          if (!isStopNode(newJPath, options)) {
            tagText = options.tagValueProcessor(tagName, tagText);
            tagText = replaceEntitiesValue(tagText, options);
          }
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += tagText;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.cdataPropName) {
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.commentPropName) {
          xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
          isPreviousElementTag = true;
          continue;
        } else if (tagName[0] === "?") {
          const attStr2 = attr_to_str(tagObj[":@"], options);
          const tempInd = tagName === "?xml" ? "" : indentation;
          let piTextNodeName = tagObj[tagName][0][options.textNodeName];
          piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
          xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
          isPreviousElementTag = true;
          continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
          newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
          if (options.suppressUnpairedNode)
            xmlStr += tagStart + ">";
          else
            xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
          xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
          xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
          xmlStr += tagStart + ">";
          if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
            xmlStr += indentation + options.indentBy + tagValue + indentation;
          } else {
            xmlStr += tagValue;
          }
          xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
      }
      return xmlStr;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i10 = 0; i10 < keys.length; i10++) {
        const key = keys[i10];
        if (key !== ":@")
          return key;
      }
    }
    function attr_to_str(attrMap, options) {
      let attrStr = "";
      if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
          let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
          attrVal = replaceEntitiesValue(attrVal, options);
          if (attrVal === true && options.suppressBooleanAttributes) {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
          } else {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
          }
        }
      }
      return attrStr;
    }
    function isStopNode(jPath, options) {
      jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
      let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
      for (let index in options.stopNodes) {
        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
          return true;
      }
      return false;
    }
    function replaceEntitiesValue(textValue, options) {
      if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i10 = 0; i10 < options.entities.length; i10++) {
          const entity = options.entities[i10];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    }
    module2.exports = toXml;
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml2 = __commonJS({
  "../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module2) {
    "use strict";
    var buildFromOrderedJs = require_orderedJs2Xml2();
    var defaultOptions = {
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      cdataPropName: false,
      format: false,
      indentBy: "  ",
      suppressEmptyNode: false,
      suppressUnpairedNode: true,
      suppressBooleanAttributes: true,
      tagValueProcessor: function(key, a10) {
        return a10;
      },
      attributeValueProcessor: function(attrName, a10) {
        return a10;
      },
      preserveOrder: false,
      commentPropName: false,
      unpairedTags: [],
      entities: [
        { regex: new RegExp("&", "g"), val: "&amp;" },
        //it must be on top
        { regex: new RegExp(">", "g"), val: "&gt;" },
        { regex: new RegExp("<", "g"), val: "&lt;" },
        { regex: new RegExp("'", "g"), val: "&apos;" },
        { regex: new RegExp('"', "g"), val: "&quot;" }
      ],
      processEntities: true,
      stopNodes: []
      // transformTagName: false,
      // transformAttributeName: false,
    };
    function Builder(options) {
      this.options = Object.assign({}, defaultOptions, options);
      if (this.options.ignoreAttributes || this.options.attributesGroupName) {
        this.isAttribute = function() {
          return false;
        };
      } else {
        this.attrPrefixLen = this.options.attributeNamePrefix.length;
        this.isAttribute = isAttribute;
      }
      this.processTextOrObjNode = processTextOrObjNode;
      if (this.options.format) {
        this.indentate = indentate;
        this.tagEndChar = ">\n";
        this.newLine = "\n";
      } else {
        this.indentate = function() {
          return "";
        };
        this.tagEndChar = ">";
        this.newLine = "";
      }
    }
    Builder.prototype.build = function(jObj) {
      if (this.options.preserveOrder) {
        return buildFromOrderedJs(jObj, this.options);
      } else {
        if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
          jObj = {
            [this.options.arrayNodeName]: jObj
          };
        }
        return this.j2x(jObj, 0).val;
      }
    };
    Builder.prototype.j2x = function(jObj, level) {
      let attrStr = "";
      let val = "";
      for (let key in jObj) {
        if (typeof jObj[key] === "undefined") {
        } else if (jObj[key] === null) {
          if (key[0] === "?")
            val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
          else
            val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        } else if (jObj[key] instanceof Date) {
          val += this.buildTextValNode(jObj[key], key, "", level);
        } else if (typeof jObj[key] !== "object") {
          const attr = this.isAttribute(key);
          if (attr) {
            attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
          } else {
            if (key === this.options.textNodeName) {
              let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
              val += this.replaceEntitiesValue(newval);
            } else {
              val += this.buildTextValNode(jObj[key], key, "", level);
            }
          }
        } else if (Array.isArray(jObj[key])) {
          const arrLen = jObj[key].length;
          for (let j10 = 0; j10 < arrLen; j10++) {
            const item = jObj[key][j10];
            if (typeof item === "undefined") {
            } else if (item === null) {
              if (key[0] === "?")
                val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
              else
                val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
            } else if (typeof item === "object") {
              val += this.processTextOrObjNode(item, key, level);
            } else {
              val += this.buildTextValNode(item, key, "", level);
            }
          }
        } else {
          if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
            const Ks = Object.keys(jObj[key]);
            const L4 = Ks.length;
            for (let j10 = 0; j10 < L4; j10++) {
              attrStr += this.buildAttrPairStr(Ks[j10], "" + jObj[key][Ks[j10]]);
            }
          } else {
            val += this.processTextOrObjNode(jObj[key], key, level);
          }
        }
      }
      return { attrStr, val };
    };
    Builder.prototype.buildAttrPairStr = function(attrName, val) {
      val = this.options.attributeValueProcessor(attrName, "" + val);
      val = this.replaceEntitiesValue(val);
      if (this.options.suppressBooleanAttributes && val === "true") {
        return " " + attrName;
      } else
        return " " + attrName + '="' + val + '"';
    };
    function processTextOrObjNode(object2, key, level) {
      const result = this.j2x(object2, level + 1);
      if (object2[this.options.textNodeName] !== void 0 && Object.keys(object2).length === 1) {
        return this.buildTextValNode(object2[this.options.textNodeName], key, result.attrStr, level);
      } else {
        return this.buildObjectNode(result.val, key, result.attrStr, level);
      }
    }
    Builder.prototype.buildObjectNode = function(val, key, attrStr, level) {
      if (val === "") {
        if (key[0] === "?")
          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        else {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        }
      } else {
        let tagEndExp = "</" + key + this.tagEndChar;
        let piClosingChar = "";
        if (key[0] === "?") {
          piClosingChar = "?";
          tagEndExp = "";
        }
        if (attrStr && val.indexOf("<") === -1) {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val + tagEndExp;
        } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
          return this.indentate(level) + `<!--${val}-->` + this.newLine;
        } else {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val + this.indentate(level) + tagEndExp;
        }
      }
    };
    Builder.prototype.closeTag = function(key) {
      let closeTag = "";
      if (this.options.unpairedTags.indexOf(key) !== -1) {
        if (!this.options.suppressUnpairedNode)
          closeTag = "/";
      } else if (this.options.suppressEmptyNode) {
        closeTag = "/";
      } else {
        closeTag = `></${key}`;
      }
      return closeTag;
    };
    Builder.prototype.buildTextValNode = function(val, key, attrStr, level) {
      if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
        return this.indentate(level) + `<![CDATA[${val}]]>` + this.newLine;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
        return this.indentate(level) + `<!--${val}-->` + this.newLine;
      } else if (key[0] === "?") {
        return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
      } else {
        let textValue = this.options.tagValueProcessor(key, val);
        textValue = this.replaceEntitiesValue(textValue);
        if (textValue === "") {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        } else {
          return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
        }
      }
    };
    Builder.prototype.replaceEntitiesValue = function(textValue) {
      if (textValue && textValue.length > 0 && this.options.processEntities) {
        for (let i10 = 0; i10 < this.options.entities.length; i10++) {
          const entity = this.options.entities[i10];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    };
    function indentate(level) {
      return this.options.indentBy.repeat(level);
    }
    function isAttribute(name) {
      if (name.startsWith(this.options.attributeNamePrefix)) {
        return name.substr(this.attrPrefixLen);
      } else {
        return false;
      }
    }
    module2.exports = Builder;
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/fxp.js
var require_fxp2 = __commonJS({
  "../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/fxp.js"(exports, module2) {
    "use strict";
    var validator = require_validator2();
    var XMLParser5 = require_XMLParser2();
    var XMLBuilder = require_json2xml2();
    module2.exports = {
      XMLParser: XMLParser5,
      XMLValidator: validator,
      XMLBuilder
    };
  }
});

// ../../node_modules/chunk/src/chunk.js
var require_chunk = __commonJS({
  "../../node_modules/chunk/src/chunk.js"(exports, module2) {
    "use strict";
    (function() {
      function chunk2(collection, size) {
        var result = [];
        size = parseInt(size) || 2;
        for (var x5 = 0; x5 < Math.ceil(collection.length / size); x5++) {
          var start = x5 * size;
          var end = start + size;
          result.push(collection.slice(start, end));
        }
        return result;
      }
      if (typeof exports !== "undefined") {
        if (typeof module2 !== "undefined" && module2.exports) {
          exports = module2.exports = chunk2;
        }
        exports.chunk = chunk2;
      } else {
        this.chunk = chunk2;
      }
    }).call(exports);
  }
});

// ../../node_modules/throat/index.js
var require_throat = __commonJS({
  "../../node_modules/throat/index.js"(exports, module2) {
    "use strict";
    function throatInternal(size) {
      var queue = new Queue();
      var s10 = size | 0;
      function run(fn, self2, args) {
        if ((s10 | 0) !== 0) {
          s10 = (s10 | 0) - 1;
          return new Promise(function(resolve) {
            resolve(fn.apply(self2, args));
          }).then(onFulfill, onReject);
        }
        return new Promise(function(resolve) {
          queue.push(new Delayed(resolve, fn, self2, args));
        }).then(runDelayed);
      }
      function runDelayed(d10) {
        try {
          return Promise.resolve(d10.fn.apply(d10.self, d10.args)).then(
            onFulfill,
            onReject
          );
        } catch (ex) {
          onReject(ex);
        }
      }
      function onFulfill(result) {
        release3();
        return result;
      }
      function onReject(error) {
        release3();
        throw error;
      }
      function release3() {
        var next = queue.shift();
        if (next) {
          next.resolve(next);
        } else {
          s10 = (s10 | 0) + 1;
        }
      }
      return run;
    }
    function earlyBound(size, fn) {
      const run = throatInternal(size | 0);
      return function() {
        var args = new Array(arguments.length);
        for (var i10 = 0; i10 < arguments.length; i10++) {
          args[i10] = arguments[i10];
        }
        return run(fn, this, args);
      };
    }
    function lateBound(size) {
      const run = throatInternal(size | 0);
      return function(fn) {
        if (typeof fn !== "function") {
          throw new TypeError(
            "Expected throat fn to be a function but got " + typeof fn
          );
        }
        var args = new Array(arguments.length - 1);
        for (var i10 = 1; i10 < arguments.length; i10++) {
          args[i10 - 1] = arguments[i10];
        }
        return run(fn, this, args);
      };
    }
    module2.exports = function throat2(size, fn) {
      if (typeof size === "function") {
        var temp = fn;
        fn = size;
        size = temp;
      }
      if (typeof size !== "number") {
        throw new TypeError(
          "Expected throat size to be a number but got " + typeof size
        );
      }
      if (fn !== void 0 && typeof fn !== "function") {
        throw new TypeError(
          "Expected throat fn to be a function but got " + typeof fn
        );
      }
      if (typeof fn === "function") {
        return earlyBound(size | 0, fn);
      } else {
        return lateBound(size | 0);
      }
    };
    module2.exports.default = module2.exports;
    function Delayed(resolve, fn, self2, args) {
      this.resolve = resolve;
      this.fn = fn;
      this.self = self2 || null;
      this.args = args;
    }
    var blockSize = 64;
    function Queue() {
      this._s1 = [];
      this._s2 = [];
      this._shiftBlock = this._pushBlock = new Array(blockSize);
      this._pushIndex = 0;
      this._shiftIndex = 0;
    }
    Queue.prototype.push = function(value) {
      if (this._pushIndex === blockSize) {
        this._pushIndex = 0;
        this._s1[this._s1.length] = this._pushBlock = new Array(blockSize);
      }
      this._pushBlock[this._pushIndex++] = value;
    };
    Queue.prototype.shift = function() {
      if (this._shiftIndex === blockSize) {
        var s22 = this._s2;
        if (s22.length === 0) {
          var s1 = this._s1;
          if (s1.length === 0) {
            return void 0;
          }
          this._s1 = s22;
          s22 = this._s2 = s1.reverse();
        }
        this._shiftIndex = 0;
        this._shiftBlock = s22.pop();
      }
      if (this._pushBlock === this._shiftBlock && this._pushIndex === this._shiftIndex) {
        return void 0;
      }
      var result = this._shiftBlock[this._shiftIndex];
      this._shiftBlock[this._shiftIndex++] = null;
      return result;
    };
  }
});

// index.ts
var sdk_exports = {};
__export(sdk_exports, {
  events: () => events,
  http: () => http4,
  params: () => params,
  schedule: () => schedule,
  storage: () => storage
});
module.exports = __toCommonJS(sdk_exports);

// ../../lib/fs/index.ts
var import_promises = __toESM(require("fs/promises"), 1);

// ../../node_modules/aws4fetch/dist/aws4fetch.esm.mjs
var encoder = new TextEncoder();
var HOST_SERVICES = {
  appstream2: "appstream",
  cloudhsmv2: "cloudhsm",
  email: "ses",
  marketplace: "aws-marketplace",
  mobile: "AWSMobileHubService",
  pinpoint: "mobiletargeting",
  queue: "sqs",
  "git-codecommit": "codecommit",
  "mturk-requester-sandbox": "mturk-requester",
  "personalize-runtime": "personalize"
};
var UNSIGNABLE_HEADERS = /* @__PURE__ */ new Set([
  "authorization",
  "content-type",
  "content-length",
  "user-agent",
  "presigned-expires",
  "expect",
  "x-amzn-trace-id",
  "range",
  "connection"
]);
var AwsClient = class {
  constructor({ accessKeyId, secretAccessKey, sessionToken, service, region, cache, retries, initRetryMs }) {
    if (accessKeyId == null)
      throw new TypeError("accessKeyId is a required option");
    if (secretAccessKey == null)
      throw new TypeError("secretAccessKey is a required option");
    this.accessKeyId = accessKeyId;
    this.secretAccessKey = secretAccessKey;
    this.sessionToken = sessionToken;
    this.service = service;
    this.region = region;
    this.cache = cache || /* @__PURE__ */ new Map();
    this.retries = retries != null ? retries : 10;
    this.initRetryMs = initRetryMs || 50;
  }
  async sign(input, init) {
    if (input instanceof Request) {
      const { method, url, headers, body } = input;
      init = Object.assign({ method, url, headers }, init);
      if (init.body == null && headers.has("Content-Type")) {
        init.body = body != null && headers.has("X-Amz-Content-Sha256") ? body : await input.clone().arrayBuffer();
      }
      input = url;
    }
    const signer = new AwsV4Signer(Object.assign({ url: input }, init, this, init && init.aws));
    const signed = Object.assign({}, init, await signer.sign());
    delete signed.aws;
    try {
      return new Request(signed.url.toString(), signed);
    } catch (e10) {
      if (e10 instanceof TypeError) {
        return new Request(signed.url.toString(), Object.assign({ duplex: "half" }, signed));
      }
      throw e10;
    }
  }
  async fetch(input, init) {
    for (let i10 = 0; i10 <= this.retries; i10++) {
      const fetched = fetch(await this.sign(input, init));
      if (i10 === this.retries) {
        return fetched;
      }
      const res = await fetched;
      if (res.status < 500 && res.status !== 429) {
        return res;
      }
      await new Promise((resolve) => setTimeout(resolve, Math.random() * this.initRetryMs * Math.pow(2, i10)));
    }
    throw new Error("An unknown error occurred, ensure retries is not negative");
  }
};
var AwsV4Signer = class {
  constructor({ method, url, headers, body, accessKeyId, secretAccessKey, sessionToken, service, region, cache, datetime, signQuery, appendSessionToken, allHeaders, singleEncode }) {
    if (url == null)
      throw new TypeError("url is a required option");
    if (accessKeyId == null)
      throw new TypeError("accessKeyId is a required option");
    if (secretAccessKey == null)
      throw new TypeError("secretAccessKey is a required option");
    this.method = method || (body ? "POST" : "GET");
    this.url = new URL(url);
    this.headers = new Headers(headers || {});
    this.body = body;
    this.accessKeyId = accessKeyId;
    this.secretAccessKey = secretAccessKey;
    this.sessionToken = sessionToken;
    let guessedService, guessedRegion;
    if (!service || !region) {
      [guessedService, guessedRegion] = guessServiceRegion(this.url, this.headers);
    }
    this.service = service || guessedService || "";
    this.region = region || guessedRegion || "us-east-1";
    this.cache = cache || /* @__PURE__ */ new Map();
    this.datetime = datetime || (/* @__PURE__ */ new Date()).toISOString().replace(/[:-]|\.\d{3}/g, "");
    this.signQuery = signQuery;
    this.appendSessionToken = appendSessionToken || this.service === "iotdevicegateway";
    this.headers.delete("Host");
    if (this.service === "s3" && !this.signQuery && !this.headers.has("X-Amz-Content-Sha256")) {
      this.headers.set("X-Amz-Content-Sha256", "UNSIGNED-PAYLOAD");
    }
    const params2 = this.signQuery ? this.url.searchParams : this.headers;
    params2.set("X-Amz-Date", this.datetime);
    if (this.sessionToken && !this.appendSessionToken) {
      params2.set("X-Amz-Security-Token", this.sessionToken);
    }
    this.signableHeaders = ["host", ...this.headers.keys()].filter((header) => allHeaders || !UNSIGNABLE_HEADERS.has(header)).sort();
    this.signedHeaders = this.signableHeaders.join(";");
    this.canonicalHeaders = this.signableHeaders.map((header) => header + ":" + (header === "host" ? this.url.host : (this.headers.get(header) || "").replace(/\s+/g, " "))).join("\n");
    this.credentialString = [this.datetime.slice(0, 8), this.region, this.service, "aws4_request"].join("/");
    if (this.signQuery) {
      if (this.service === "s3" && !params2.has("X-Amz-Expires")) {
        params2.set("X-Amz-Expires", "86400");
      }
      params2.set("X-Amz-Algorithm", "AWS4-HMAC-SHA256");
      params2.set("X-Amz-Credential", this.accessKeyId + "/" + this.credentialString);
      params2.set("X-Amz-SignedHeaders", this.signedHeaders);
    }
    if (this.service === "s3") {
      try {
        this.encodedPath = decodeURIComponent(this.url.pathname.replace(/\+/g, " "));
      } catch (e10) {
        this.encodedPath = this.url.pathname;
      }
    } else {
      this.encodedPath = this.url.pathname.replace(/\/+/g, "/");
    }
    if (!singleEncode) {
      this.encodedPath = encodeURIComponent(this.encodedPath).replace(/%2F/g, "/");
    }
    this.encodedPath = encodeRfc3986(this.encodedPath);
    const seenKeys = /* @__PURE__ */ new Set();
    this.encodedSearch = [...this.url.searchParams].filter(([k10]) => {
      if (!k10)
        return false;
      if (this.service === "s3") {
        if (seenKeys.has(k10))
          return false;
        seenKeys.add(k10);
      }
      return true;
    }).map((pair) => pair.map((p10) => encodeRfc3986(encodeURIComponent(p10)))).sort(([k1, v1], [k22, v22]) => k1 < k22 ? -1 : k1 > k22 ? 1 : v1 < v22 ? -1 : v1 > v22 ? 1 : 0).map((pair) => pair.join("=")).join("&");
  }
  async sign() {
    if (this.signQuery) {
      this.url.searchParams.set("X-Amz-Signature", await this.signature());
      if (this.sessionToken && this.appendSessionToken) {
        this.url.searchParams.set("X-Amz-Security-Token", this.sessionToken);
      }
    } else {
      this.headers.set("Authorization", await this.authHeader());
    }
    return {
      method: this.method,
      url: this.url,
      headers: this.headers,
      body: this.body
    };
  }
  async authHeader() {
    return [
      "AWS4-HMAC-SHA256 Credential=" + this.accessKeyId + "/" + this.credentialString,
      "SignedHeaders=" + this.signedHeaders,
      "Signature=" + await this.signature()
    ].join(", ");
  }
  async signature() {
    const date2 = this.datetime.slice(0, 8);
    const cacheKey = [this.secretAccessKey, date2, this.region, this.service].join();
    let kCredentials = this.cache.get(cacheKey);
    if (!kCredentials) {
      const kDate = await hmac("AWS4" + this.secretAccessKey, date2);
      const kRegion = await hmac(kDate, this.region);
      const kService = await hmac(kRegion, this.service);
      kCredentials = await hmac(kService, "aws4_request");
      this.cache.set(cacheKey, kCredentials);
    }
    return buf2hex(await hmac(kCredentials, await this.stringToSign()));
  }
  async stringToSign() {
    return [
      "AWS4-HMAC-SHA256",
      this.datetime,
      this.credentialString,
      buf2hex(await hash(await this.canonicalString()))
    ].join("\n");
  }
  async canonicalString() {
    return [
      this.method.toUpperCase(),
      this.encodedPath,
      this.encodedSearch,
      this.canonicalHeaders + "\n",
      this.signedHeaders,
      await this.hexBodyHash()
    ].join("\n");
  }
  async hexBodyHash() {
    let hashHeader = this.headers.get("X-Amz-Content-Sha256") || (this.service === "s3" && this.signQuery ? "UNSIGNED-PAYLOAD" : null);
    if (hashHeader == null) {
      if (this.body && typeof this.body !== "string" && !("byteLength" in this.body)) {
        throw new Error("body must be a string, ArrayBuffer or ArrayBufferView, unless you include the X-Amz-Content-Sha256 header");
      }
      hashHeader = buf2hex(await hash(this.body || ""));
    }
    return hashHeader;
  }
};
async function hmac(key, string2) {
  const cryptoKey = await crypto.subtle.importKey(
    "raw",
    typeof key === "string" ? encoder.encode(key) : key,
    { name: "HMAC", hash: { name: "SHA-256" } },
    false,
    ["sign"]
  );
  return crypto.subtle.sign("HMAC", cryptoKey, encoder.encode(string2));
}
async function hash(content) {
  return crypto.subtle.digest("SHA-256", typeof content === "string" ? encoder.encode(content) : content);
}
function buf2hex(buffer) {
  return Array.prototype.map.call(new Uint8Array(buffer), (x5) => ("0" + x5.toString(16)).slice(-2)).join("");
}
function encodeRfc3986(urlEncodedStr) {
  return urlEncodedStr.replace(/[!'()*]/g, (c10) => "%" + c10.charCodeAt(0).toString(16).toUpperCase());
}
function guessServiceRegion(url, headers) {
  const { hostname, pathname } = url;
  if (hostname.endsWith(".r2.cloudflarestorage.com")) {
    return ["s3", "auto"];
  }
  if (hostname.endsWith(".backblazeb2.com")) {
    const match2 = hostname.match(/^(?:[^.]+\.)?s3\.([^.]+)\.backblazeb2\.com$/);
    return match2 != null ? ["s3", match2[1]] : ["", ""];
  }
  const match = hostname.replace("dualstack.", "").match(/([^.]+)\.(?:([^.]*)\.)?amazonaws\.com(?:\.cn)?$/);
  let [service, region] = (match || ["", ""]).slice(1, 3);
  if (region === "us-gov") {
    region = "us-gov-west-1";
  } else if (region === "s3" || region === "s3-accelerate") {
    region = "us-east-1";
    service = "s3";
  } else if (service === "iot") {
    if (hostname.startsWith("iot.")) {
      service = "execute-api";
    } else if (hostname.startsWith("data.jobs.iot.")) {
      service = "iot-jobs-data";
    } else {
      service = pathname === "/mqtt" ? "iotdevicegateway" : "iotdata";
    }
  } else if (service === "autoscaling") {
    const targetPrefix = (headers.get("X-Amz-Target") || "").split(".")[0];
    if (targetPrefix === "AnyScaleFrontendService") {
      service = "application-autoscaling";
    } else if (targetPrefix === "AnyScaleScalingPlannerFrontendService") {
      service = "autoscaling-plans";
    }
  } else if (region == null && service.startsWith("s3-")) {
    region = service.slice(3).replace(/^fips-|^external-1/, "");
    service = "s3";
  } else if (service.endsWith("-fips")) {
    service = service.slice(0, -5);
  } else if (region && /-\d$/.test(service) && !/-\d$/.test(region)) {
    [service, region] = [region, service];
  }
  return [HOST_SERVICES[service] || service, region];
}

// ../../lib/aws/s3.ts
var aws = new AwsClient({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  sessionToken: process.env.AWS_SESSION_TOKEN,
  region: process.env.AWS_REGION
});

// ../../lib/fs/index.ts
var CHUNK_SIZE = 1024;
var StreamingResponse = class extends Response {
  #body;
  constructor(body, init) {
    const isStream = body instanceof ReadableStream;
    super(isStream ? null : body, init);
    this.#body = body;
  }
  get body() {
    return this.#body;
  }
};
function createReadableStream(filename) {
  let fileHandle;
  let position = 0;
  return new ReadableStream({
    async start() {
      fileHandle = await import_promises.default.open(filename, "r");
    },
    async pull(controller) {
      const buffer = new Uint8Array(CHUNK_SIZE);
      const { bytesRead } = await fileHandle.read(buffer, 0, CHUNK_SIZE, position);
      if (bytesRead === 0) {
        await fileHandle.close();
        controller.close();
      } else {
        position += bytesRead;
        controller.enqueue(buffer.subarray(0, bytesRead));
      }
    },
    cancel() {
      return fileHandle.close();
    }
  });
}

// http/framework/finish.ts
async function finish(item, ...details) {
  await new Promise((resolve, reject) => {
    if (item.writableEnded || item.complete) {
      resolve();
      return;
    }
    let finished = false;
    function done(err) {
      if (finished) {
        return;
      }
      finished = true;
      item.removeListener("error", done);
      item.removeListener("end", done);
      item.removeListener("finish", done);
      if (err) {
        reject(err);
      } else {
        resolve();
      }
    }
    item.once("error", done);
    item.once("end", done);
    item.once("finish", done);
  });
  return item;
}

// http/framework/get-framework.ts
var import_node_http2 = __toESM(require("http"), 1);

// http/framework/response.ts
var import_node_http = __toESM(require("http"), 1);
var headerEnd = "\r\n\r\n";
var BODY = Symbol();
var HEADERS = Symbol();
function getString(data) {
  if (Buffer.isBuffer(data)) {
    return data.toString("utf8");
  } else if (typeof data === "string") {
    return data;
  } else {
    throw new Error(`response.write() of unexpected type: ${typeof data}`);
  }
}
function addData(stream, data) {
  if (Buffer.isBuffer(data) || typeof data === "string" || data instanceof Uint8Array) {
    stream[BODY].push(Buffer.from(data));
  } else {
    throw new Error(`response.write() of unexpected type: ${typeof data}`);
  }
}
var ServerlessResponse = class extends import_node_http.default.ServerResponse {
  _header = "";
  _wroteHeader = false;
  constructor(request2) {
    super(request2);
    this[BODY] = [];
    this[HEADERS] = {};
    this.useChunkedEncodingByDefault = false;
    this.chunkedEncoding = false;
    this._header = "";
    this.assignSocket({
      _writableState: {},
      writable: true,
      // @ts-ignore
      on: Function.prototype,
      // @ts-ignore
      removeListener: Function.prototype,
      // @ts-ignore
      destroy: Function.prototype,
      // @ts-ignore
      cork: Function.prototype,
      // @ts-ignore
      uncork: Function.prototype,
      // @ts-ignore
      write: (data, encoding, cb2) => {
        if (typeof encoding === "function") {
          cb2 = encoding;
          encoding = void 0;
        }
        if (this._header === "" || this._wroteHeader) {
          addData(this, data);
        } else {
          const string2 = getString(data);
          const index = string2.indexOf(headerEnd);
          if (index !== -1) {
            const remainder = string2.slice(index + headerEnd.length);
            if (remainder) {
              addData(this, remainder);
            }
            this._wroteHeader = true;
          }
        }
        if (typeof cb2 === "function") {
          cb2();
        }
      }
    });
    this.once("finish", () => {
      this.emit("close");
    });
  }
  static from(res) {
    const response = new ServerlessResponse(res);
    response.statusCode = res.statusCode;
    response[HEADERS] = res.headers;
    response[BODY] = [Buffer.from(res.body)];
    response.end();
    return response;
  }
  static body(res) {
    return Buffer.concat(res[BODY]);
  }
  static headers(res) {
    const headers = typeof res.getHeaders === "function" ? res.getHeaders() : res._headers;
    return Object.assign(headers, res[HEADERS]);
  }
  get headers() {
    return this[HEADERS];
  }
  setHeader(key, value) {
    if (this._wroteHeader) {
      this[HEADERS][key] = value;
    } else {
      super.setHeader(key, value);
    }
    return this;
  }
  writeHead(statusCode, reason, obj) {
    if (reason || obj) {
      let headers = {};
      if (typeof reason === "string" && obj) {
        headers = obj;
      } else if (typeof reason === "object") {
        headers = reason;
      }
      for (const name in headers) {
        this.setHeader(name, headers[name]);
        if (!this._wroteHeader) {
          break;
        }
      }
    }
    super.writeHead(statusCode, reason, obj);
    return this;
  }
};

// http/framework/get-framework.ts
function common(cb2) {
  return (request2) => {
    const response = new ServerlessResponse(request2);
    cb2(request2, response);
    return response;
  };
}
function getFramework(app) {
  if (app instanceof import_node_http2.default.Server) {
    return (request2) => {
      const response = new ServerlessResponse(request2);
      app.emit("request", request2, response);
      return response;
    };
  }
  if (typeof app.callback === "function") {
    return common(app.callback());
  }
  if (typeof app.handle === "function") {
    return common((request2, response) => {
      app.handle(request2, response);
    });
  }
  if (typeof app.handler === "function") {
    return common((request2, response) => {
      app.handler(request2, response);
    });
  }
  if (typeof app._onRequest === "function") {
    return common((request2, response) => {
      app._onRequest(request2, response);
    });
  }
  if (typeof app === "function") {
    return common(app);
  }
  if (app.router && typeof app.router.route == "function") {
    return common((req, res) => {
      const { url, method, headers, body } = req;
      app.router.route({ url, method, headers, body }, res);
    });
  }
  if (app._core && typeof app._core._dispatch === "function") {
    return common(
      app._core._dispatch({
        app
      })
    );
  }
  if (typeof app.inject === "function") {
    return async (request2) => {
      const { method, url, headers, body } = request2;
      const res = await app.inject({ method, url, headers, payload: body });
      return ServerlessResponse.from(res);
    };
  }
  if (typeof app.main === "function") {
    return common(app.main);
  }
  throw new Error("Unsupported framework");
}

// http/framework/request.ts
var import_node_http3 = __toESM(require("http"), 1);
var ServerlessRequest = class extends import_node_http3.default.IncomingMessage {
  // type dis
  requestContext;
  // type dis
  apiGateway;
  constructor({
    method,
    url,
    headers,
    body,
    remoteAddress
  }) {
    super({
      encrypted: true,
      readable: false,
      remoteAddress,
      address: () => ({ port: 443 }),
      // @ts-ignore
      end: Function.prototype,
      // @ts-ignore
      destroy: Function.prototype
    });
    if (typeof headers["content-length"] === "undefined") {
      headers["content-length"] = body ? Buffer.byteLength(body).toString() : "0";
    }
    Object.assign(this, {
      ip: remoteAddress,
      complete: true,
      httpVersion: "1.1",
      httpVersionMajor: "1",
      httpVersionMinor: "1",
      method,
      headers,
      body,
      url
    });
    this._read = () => {
      this.push(body);
      this.push(null);
    };
  }
};

// http/framework/create-request.ts
var create_request_default = (request2, context) => {
  const httpHeaders = {};
  request2.headers.forEach((value, key) => {
    httpHeaders[key] = value;
  });
  return new ServerlessRequest({
    method: request2.method,
    headers: httpHeaders,
    body: request2.body,
    remoteAddress: context.remoteAddress,
    url: context.url
  });
};

// http/framework/is-binary.ts
var BINARY_ENCODINGS = ["gzip", "deflate", "br"];
var BINARY_CONTENT_TYPES = (process.env.BINARY_CONTENT_TYPES || "").split(",");
function isBinaryEncoding(headers) {
  const contentEncoding = headers["content-encoding"];
  if (typeof contentEncoding === "string") {
    return contentEncoding.split(",").some((value) => BINARY_ENCODINGS.some((binaryEncoding) => value.indexOf(binaryEncoding) !== -1));
  }
}
function isBinaryContent(headers, options) {
  const contentTypes = [].concat(options?.binary && Array.isArray(options.binary) ? options.binary : BINARY_CONTENT_TYPES).map((candidate) => new RegExp(`^${candidate.replace(/\*/g, ".*")}$`));
  const contentType = (headers["content-type"] || "").split(";")[0];
  return !!contentType && contentTypes.some((candidate) => candidate.test(contentType));
}
function isBinary(headers, options) {
  if (options.binary === false) {
    return false;
  }
  if (options.binary === true) {
    return true;
  }
  if (typeof options.binary === "function") {
    return options.binary(headers);
  }
  return isBinaryEncoding(headers) || isBinaryContent(headers, options);
}

// http/framework/sanitize-headers.ts
function sanitizeHeaders(headers) {
  return Object.keys(headers).reduce(
    (memo, key) => {
      const value = headers[key];
      if (Array.isArray(value)) {
        memo.multiValueHeaders[key] = value;
        if (key.toLowerCase() !== "set-cookie") {
          memo.headers[key] = value.join(", ");
        }
      } else {
        memo.headers[key] = value == null ? "" : value.toString();
      }
      return memo;
    },
    {
      headers: {},
      multiValueHeaders: {}
    }
  );
}

// http/framework/format-response.ts
var format_response_default = (response, options) => {
  const { statusCode } = response;
  const { headers, multiValueHeaders } = sanitizeHeaders(ServerlessResponse.headers(response));
  let cookies = [];
  if (multiValueHeaders["set-cookie"]) {
    cookies = multiValueHeaders["set-cookie"];
  }
  const isBase64Encoded = isBinary(headers, options);
  const encoding = isBase64Encoded ? "base64" : "utf8";
  let body = ServerlessResponse.body(response).toString(encoding);
  if (headers["transfer-encoding"] === "chunked" || response.chunkedEncoding) {
    const raw = ServerlessResponse.body(response).toString().split("\r\n");
    const parsed = [];
    for (let i10 = 0; i10 < raw.length; i10 += 2) {
      const size = parseInt(raw[i10], 16);
      const value = raw[i10 + 1];
      if (value) {
        parsed.push(value.substring(0, size));
      }
    }
    body = parsed.join("");
  }
  const formattedResponse = { statusCode, headers, isBase64Encoded, body, cookies };
  return formattedResponse;
};

// http/framework/aws.ts
var aws_default = (options = {
  requestId: "",
  basePath: void 0,
  binary: false
}) => {
  return (getResponse) => async (requestEvent, context) => {
    const request2 = create_request_default(requestEvent, context);
    const response = await getResponse(request2, requestEvent, context);
    const formatted = format_response_default(response, options);
    const fetchResponse = new Response(formatted.body, {
      headers: formatted.headers,
      status: formatted.statusCode
    });
    return fetchResponse;
  };
};

// logging.ts
function applicationError(err, msg) {
  console.log(
    JSON.stringify({
      time: Date.now(),
      level: 50,
      msg,
      err: { message: err.message, stack: err.stack, code: err.code }
    }) + "\n"
  );
}

// http/index.ts
var Handler = class {
  prefix;
  handler;
  constructor(prefix, handler) {
    this.prefix = prefix;
    this.handler = handler;
  }
};
function normalize(path) {
  return path.replace(/^\/*([^\/]+)?\/*$/, "$1").replace(/\/+/g, "/");
}
var Http = class {
  loaders = [];
  listenerAdded = false;
  defaultNotFoundResponse = new Response("Not Found", { status: 404 });
  defaultErrorResponse = new Response("Internal Server Error", { status: 500 });
  use(prefixOrHandler, _handler) {
    const handler = _handler ? _handler : prefixOrHandler;
    const eventPrefix = _handler ? normalize(prefixOrHandler) : "";
    const handlerPrefix = `/${eventPrefix}`;
    this.loaders.push(new Handler(handlerPrefix, handler));
    this.addListener();
  }
  addListener() {
    if (this.listenerAdded) {
      return;
    }
    addEventListener("fetch", (event, eventContext) => {
      event.respondWith(this.handleEvent(event, eventContext));
    });
    this.listenerAdded = true;
  }
  useNodeHandler(handler) {
    this.use(this.nodeAdapter(handler));
  }
  async handleEvent(event, context) {
    const notFoundResponses = [];
    const url = new URL(event.request.url);
    try {
      for (const loader of this.loaders) {
        if (!url.pathname.startsWith(loader.prefix)) {
          continue;
        }
        const result = loader.handler(event.request, context);
        if (!result) {
          continue;
        }
        const response = await result;
        if (!response) {
          continue;
        }
        if (response.status !== 404) {
          return response;
        }
        notFoundResponses.push(response);
      }
      return notFoundResponses.shift() || this.defaultNotFoundResponse;
    } catch (err) {
      applicationError(err, "HTTP handler failed");
      return this.defaultErrorResponse;
    }
  }
  nodeAdapter(handler) {
    const options = {
      binary: void 0,
      requestId: "x-request-id",
      basePath: void 0
    };
    const framework = getFramework(handler);
    return aws_default(options)(async (request2, ...context) => {
      await finish(request2, ...context);
      const response = await framework(request2);
      await finish(response, ...context);
      return response;
    });
  }
  on(eventName, relativePath) {
    if (eventName.toString() === "404") {
      this.defaultNotFoundResponse = new StreamingResponse(createReadableStream(relativePath), {
        status: 404,
        headers: {
          "Content-Type": "text/html",
          "Cache-Control": `max-age=0, s-maxage=31449600, must-revalidate`
        }
      });
    } else if (eventName.toString() === "500") {
      this.defaultErrorResponse = new StreamingResponse(createReadableStream(relativePath), {
        status: 500,
        headers: {
          "Content-Type": "text/html",
          "Cache-Control": `max-age=0, s-maxage=31449600, must-revalidate`
        }
      });
    } else {
      throw new Error(`Unsupported event name for http.on(): ${eventName}`);
    }
    this.addListener();
  }
};
var http4 = new Http();

// schedule/index.ts
var import_cron_validate = __toESM(require_lib(), 1);

// schedule/schedule-utils.ts
var import_dayjs = __toESM(require_dayjs_min(), 1);
var import_utc = __toESM(require_utc(), 1);
import_dayjs.default.extend(import_utc.default);
var MAX_NUMERIC_OFFSET = 10 * 365 * 24 * 60 * 60 * 1e3;
function validUnit(unit, items) {
  return items.includes(unit) || items.includes(unit + "s");
}
function parseAfter(after, base) {
  if (!after) {
    return base;
  }
  if (typeof after === "number") {
    return new Date(Math.abs(after) <= MAX_NUMERIC_OFFSET ? base + after : after).getTime();
  } else if (after instanceof Date) {
    return after.getTime();
  } else {
    const date2 = Date.parse(after);
    if (date2) {
      return date2;
    }
    try {
      const [num, unit] = after.toLowerCase().split(" ");
      if (!validUnit(unit, ["seconds", "minutes", "hours", "days", "weeks", "months", "years"])) {
        return NaN;
      }
      return import_dayjs.default.utc(base).add(Number.parseInt(num), unit).valueOf();
    } catch (err) {
      return NaN;
    }
  }
}
function convertRateToCron(rate) {
  if (!rate) {
    return;
  }
  const [_num, unit] = rate.toLowerCase().split(" ");
  if (!validUnit(unit, ["minutes", "hours", "days"])) {
    return;
  }
  const num = Number.parseInt(_num);
  if (isNaN(num) || num <= 0) {
    return;
  }
  switch (unit) {
    case "minute":
    case "minutes":
      if (num < 60 && 60 % num === 0) {
        return `0/${num} * * * ? *`;
      }
      break;
    case "hour":
    case "hours":
      if (num < 24 && 24 % num === 0) {
        return `0 */${num} * * ? *`;
      }
      break;
  }
  return;
}

// schedule/index.ts
var allowedScheduleUnits = /(minute|minutes|hour|hours|day|days)/g;
var expressionVersions = /(rate|every|cron)/g;
var specialChars = /["'()]/g;
var ScheduleError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "ScheduleError";
  }
};
var Handler2 = class {
  name;
  id;
  schedule;
  timeout;
  errors;
  handler;
  constructor(params2) {
    const { id, schedule: schedule2, handler, timeout, name, errors } = params2;
    this.name = name;
    this.id = id;
    this.schedule = schedule2;
    this.handler = handler;
    this.timeout = timeout;
    this.errors = errors;
    addEventListener(`schedule:${id}`, handler, {
      source: "schedule",
      invocationType: "schedule",
      timeout,
      id,
      name,
      meta: { schedule: schedule2 }
    });
    Schedule.handlerRegistry[id] = this;
  }
};
var _Schedule = class {
  handlers;
  errors;
  name;
  constructor(name) {
    if (name) {
      this.name = name;
    }
    this.handlers = [];
    this.errors = [];
  }
  static handle(name) {
    if (name) {
      if (name.length > 64) {
        throw new ScheduleError("Schedule name must be 64 characters or less");
      }
      const duplicate = Object.values(_Schedule.handlerRegistry).find((handler) => handler.name === name);
      if (duplicate) {
        throw new ScheduleError(`Schedule name must be unique. "${name}" is already in use.`);
      }
    }
    const schedule2 = new _Schedule(name);
    return {
      every: schedule2.every.bind(schedule2),
      cron: schedule2.cron.bind(schedule2),
      at: schedule2.at.bind(schedule2),
      task: schedule2.task.bind(schedule2)
    };
  }
  parseExpression(expression) {
    return expression.replace(expressionVersions, "").replace(specialChars, "");
  }
  validate(expression) {
    if (expression.match(/rate/) || expression.match(/every/)) {
      if (!expression.match(allowedScheduleUnits)) {
        return false;
      }
    } else if (expression.match(/cron/)) {
      const cronExpression = expression.replace(expressionVersions, "").replace(specialChars, "");
      const cronResult = (0, import_cron_validate.default)(cronExpression, { preset: "aws-cloud-watch" });
      if (!cronResult.isValid()) {
        return false;
      }
    } else {
      return false;
    }
    return true;
  }
  use(schedule2, ...args) {
    let [config, handler] = args;
    if (!handler) {
      handler = config;
      config = {};
    }
    if (!handler) {
      const testHandler = this.handlers.find((s10) => s10.schedule === schedule2);
      if (!testHandler) {
        throw new ScheduleError(`No handler found for schedule: ${schedule2}`);
      }
      return testHandler;
    }
    const id = `schedule-${_Schedule.count}`;
    const isValidExpression = this.validate(schedule2);
    if (!isValidExpression) {
      this.errors.push(`Invalid schedule expression: ${schedule2}`);
      return null;
    }
    _Schedule.count++;
    let { timeout = 2e4 } = config || {};
    if (timeout > 3e5) {
      this.errors.push("Maximum timeout for scheduled tasks is 300000 ms");
      timeout = 3e5;
    }
    this.handlers.push(
      new Handler2({
        id,
        schedule: schedule2,
        handler,
        timeout,
        errors: this.errors,
        name: this.name
      })
    );
    return null;
  }
  cron(expression, ...args) {
    return this.use(`cron(${expression})`, ...args);
  }
  every(rate, ...args) {
    return this.rate(rate, ...args);
  }
  rate(rate, ...args) {
    const cron2 = convertRateToCron(rate);
    const expression = cron2 ? `cron(${cron2})` : `rate(${rate})`;
    return this.use(expression, ...args);
  }
  task(...args) {
    console.log("Not implemented yet");
  }
  // TODO: to make this work, we need to detect if this is running inside a handler
  // it cannot run at root
  async at(date2, payload) {
    console.log("Not implemented yet");
  }
};
var Schedule = _Schedule;
__publicField(Schedule, "count", 0);
__publicField(Schedule, "taskCount", 0);
__publicField(Schedule, "handlerRegistry", {});
var schedule = Schedule.handle;

// ../../node_modules/@aws-sdk/middleware-endpoint/dist-es/service-customizations/s3.js
var resolveParamsForS3 = async (endpointParams) => {
  const bucket = endpointParams?.Bucket || "";
  if (typeof endpointParams.Bucket === "string") {
    endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
  }
  if (isArnBucketName(bucket)) {
    if (endpointParams.ForcePathStyle === true) {
      throw new Error("Path-style addressing cannot be used with ARN buckets");
    }
  } else if (!isDnsCompatibleBucketName(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
    endpointParams.ForcePathStyle = true;
  }
  if (endpointParams.DisableMultiRegionAccessPoints) {
    endpointParams.disableMultiRegionAccessPoints = true;
    endpointParams.DisableMRAP = true;
  }
  return endpointParams;
};
var DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
var IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
var DOTS_PATTERN = /\.\./;
var isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
var isArnBucketName = (bucketName) => {
  const [arn, partition2, service, region, account, typeOrId] = bucketName.split(":");
  const isArn = arn === "arn" && bucketName.split(":").length >= 6;
  const isValidArn = [arn, partition2, service, account, typeOrId].filter(Boolean).length === 5;
  if (isArn && !isValidArn) {
    throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
  }
  return arn === "arn" && !!partition2 && !!service && !!account && !!typeOrId;
};

// ../../node_modules/@aws-sdk/middleware-endpoint/dist-es/adaptors/createConfigValueProvider.js
var createConfigValueProvider = (configKey, canonicalEndpointParamKey, config) => {
  const configProvider = async () => {
    const configValue = config[configKey] ?? config[canonicalEndpointParamKey];
    if (typeof configValue === "function") {
      return configValue();
    }
    return configValue;
  };
  if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
    return async () => {
      const endpoint = await configProvider();
      if (endpoint && typeof endpoint === "object") {
        if ("url" in endpoint) {
          return endpoint.url.href;
        }
        if ("hostname" in endpoint) {
          const { protocol, hostname, port, path } = endpoint;
          return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
        }
      }
      return endpoint;
    };
  }
  return configProvider;
};

// ../../node_modules/@aws-sdk/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js
var getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
  const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
  if (typeof clientConfig.endpointProvider !== "function") {
    throw new Error("config.endpointProvider is not set.");
  }
  const endpoint = clientConfig.endpointProvider(endpointParams, context);
  return endpoint;
};
var resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
  const endpointParams = {};
  const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
  for (const [name, instruction] of Object.entries(instructions)) {
    switch (instruction.type) {
      case "staticContextParams":
        endpointParams[name] = instruction.value;
        break;
      case "contextParams":
        endpointParams[name] = commandInput[instruction.name];
        break;
      case "clientContextParams":
      case "builtInParams":
        endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig)();
        break;
      default:
        throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
    }
  }
  if (Object.keys(instructions).length === 0) {
    Object.assign(endpointParams, clientConfig);
  }
  if (String(clientConfig.serviceId).toLowerCase() === "s3") {
    await resolveParamsForS3(endpointParams);
  }
  return endpointParams;
};

// ../../node_modules/@aws-sdk/querystring-parser/dist-es/index.js
function parseQueryString(querystring) {
  const query = {};
  querystring = querystring.replace(/^\?/, "");
  if (querystring) {
    for (const pair of querystring.split("&")) {
      let [key, value = null] = pair.split("=");
      key = decodeURIComponent(key);
      if (value) {
        value = decodeURIComponent(value);
      }
      if (!(key in query)) {
        query[key] = value;
      } else if (Array.isArray(query[key])) {
        query[key].push(value);
      } else {
        query[key] = [query[key], value];
      }
    }
  }
  return query;
}

// ../../node_modules/@aws-sdk/url-parser/dist-es/index.js
var parseUrl = (url) => {
  if (typeof url === "string") {
    return parseUrl(new URL(url));
  }
  const { hostname, pathname, port, protocol, search } = url;
  let query;
  if (search) {
    query = parseQueryString(search);
  }
  return {
    hostname,
    port: port ? parseInt(port) : void 0,
    protocol,
    path: pathname,
    query
  };
};

// ../../node_modules/@aws-sdk/middleware-endpoint/dist-es/adaptors/toEndpointV1.js
var toEndpointV1 = (endpoint) => {
  if (typeof endpoint === "object") {
    if ("url" in endpoint) {
      return parseUrl(endpoint.url);
    }
    return endpoint;
  }
  return parseUrl(endpoint);
};

// ../../node_modules/@aws-sdk/middleware-endpoint/dist-es/endpointMiddleware.js
var endpointMiddleware = ({ config, instructions }) => {
  return (next, context) => async (args) => {
    const endpoint = await getEndpointFromInstructions(args.input, {
      getEndpointParameterInstructions() {
        return instructions;
      }
    }, { ...config }, context);
    context.endpointV2 = endpoint;
    context.authSchemes = endpoint.properties?.authSchemes;
    const authScheme = context.authSchemes?.[0];
    if (authScheme) {
      context["signing_region"] = authScheme.signingRegion;
      context["signing_service"] = authScheme.signingName;
    }
    return next({
      ...args
    });
  };
};

// ../../node_modules/@aws-sdk/middleware-serde/dist-es/deserializerMiddleware.js
var deserializerMiddleware = (options, deserializer) => (next, context) => async (args) => {
  const { response } = await next(args);
  try {
    const parsed = await deserializer(response, options);
    return {
      response,
      output: parsed
    };
  } catch (error) {
    Object.defineProperty(error, "$response", {
      value: response
    });
    throw error;
  }
};

// ../../node_modules/@aws-sdk/middleware-serde/dist-es/serializerMiddleware.js
var serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
  const endpoint = context.endpointV2?.url && options.urlParser ? async () => options.urlParser(context.endpointV2.url) : options.endpoint;
  if (!endpoint) {
    throw new Error("No valid endpoint provider available.");
  }
  const request2 = await serializer(args.input, { ...options, endpoint });
  return next({
    ...args,
    request: request2
  });
};

// ../../node_modules/@aws-sdk/middleware-serde/dist-es/serdePlugin.js
var deserializerMiddlewareOption = {
  name: "deserializerMiddleware",
  step: "deserialize",
  tags: ["DESERIALIZER"],
  override: true
};
var serializerMiddlewareOption = {
  name: "serializerMiddleware",
  step: "serialize",
  tags: ["SERIALIZER"],
  override: true
};
function getSerdePlugin(config, serializer, deserializer) {
  return {
    applyToStack: (commandStack) => {
      commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption);
      commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption);
    }
  };
}

// ../../node_modules/@aws-sdk/middleware-endpoint/dist-es/getEndpointPlugin.js
var endpointMiddlewareOptions = {
  step: "serialize",
  tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
  name: "endpointV2Middleware",
  override: true,
  relation: "before",
  toMiddleware: serializerMiddlewareOption.name
};
var getEndpointPlugin = (config, instructions) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(endpointMiddleware({
      config,
      instructions
    }), endpointMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/util-middleware/dist-es/normalizeProvider.js
var normalizeProvider = (input) => {
  if (typeof input === "function")
    return input;
  const promisified = Promise.resolve(input);
  return () => promisified;
};

// ../../node_modules/@aws-sdk/middleware-endpoint/dist-es/resolveEndpointConfig.js
var resolveEndpointConfig = (input) => {
  const tls = input.tls ?? true;
  const { endpoint } = input;
  const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await normalizeProvider(endpoint)()) : void 0;
  const isCustomEndpoint = !!endpoint;
  return {
    ...input,
    endpoint: customEndpointProvider,
    tls,
    isCustomEndpoint,
    useDualstackEndpoint: normalizeProvider(input.useDualstackEndpoint ?? false),
    useFipsEndpoint: normalizeProvider(input.useFipsEndpoint ?? false)
  };
};

// ../../node_modules/@aws-sdk/smithy-client/dist-es/NoOpLogger.js
var NoOpLogger = class {
  trace() {
  }
  debug() {
  }
  info() {
  }
  warn() {
  }
  error() {
  }
};

// ../../node_modules/@aws-sdk/middleware-stack/dist-es/MiddlewareStack.js
var constructStack = () => {
  let absoluteEntries = [];
  let relativeEntries = [];
  const entriesNameSet = /* @__PURE__ */ new Set();
  const sort = (entries) => entries.sort((a10, b10) => stepWeights[b10.step] - stepWeights[a10.step] || priorityWeights[b10.priority || "normal"] - priorityWeights[a10.priority || "normal"]);
  const removeByName = (toRemove) => {
    let isRemoved = false;
    const filterCb = (entry) => {
      if (entry.name && entry.name === toRemove) {
        isRemoved = true;
        entriesNameSet.delete(toRemove);
        return false;
      }
      return true;
    };
    absoluteEntries = absoluteEntries.filter(filterCb);
    relativeEntries = relativeEntries.filter(filterCb);
    return isRemoved;
  };
  const removeByReference = (toRemove) => {
    let isRemoved = false;
    const filterCb = (entry) => {
      if (entry.middleware === toRemove) {
        isRemoved = true;
        if (entry.name)
          entriesNameSet.delete(entry.name);
        return false;
      }
      return true;
    };
    absoluteEntries = absoluteEntries.filter(filterCb);
    relativeEntries = relativeEntries.filter(filterCb);
    return isRemoved;
  };
  const cloneTo = (toStack) => {
    absoluteEntries.forEach((entry) => {
      toStack.add(entry.middleware, { ...entry });
    });
    relativeEntries.forEach((entry) => {
      toStack.addRelativeTo(entry.middleware, { ...entry });
    });
    return toStack;
  };
  const expandRelativeMiddlewareList = (from) => {
    const expandedMiddlewareList = [];
    from.before.forEach((entry) => {
      if (entry.before.length === 0 && entry.after.length === 0) {
        expandedMiddlewareList.push(entry);
      } else {
        expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
      }
    });
    expandedMiddlewareList.push(from);
    from.after.reverse().forEach((entry) => {
      if (entry.before.length === 0 && entry.after.length === 0) {
        expandedMiddlewareList.push(entry);
      } else {
        expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
      }
    });
    return expandedMiddlewareList;
  };
  const getMiddlewareList = (debug = false) => {
    const normalizedAbsoluteEntries = [];
    const normalizedRelativeEntries = [];
    const normalizedEntriesNameMap = {};
    absoluteEntries.forEach((entry) => {
      const normalizedEntry = {
        ...entry,
        before: [],
        after: []
      };
      if (normalizedEntry.name)
        normalizedEntriesNameMap[normalizedEntry.name] = normalizedEntry;
      normalizedAbsoluteEntries.push(normalizedEntry);
    });
    relativeEntries.forEach((entry) => {
      const normalizedEntry = {
        ...entry,
        before: [],
        after: []
      };
      if (normalizedEntry.name)
        normalizedEntriesNameMap[normalizedEntry.name] = normalizedEntry;
      normalizedRelativeEntries.push(normalizedEntry);
    });
    normalizedRelativeEntries.forEach((entry) => {
      if (entry.toMiddleware) {
        const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
        if (toMiddleware === void 0) {
          if (debug) {
            return;
          }
          throw new Error(`${entry.toMiddleware} is not found when adding ${entry.name || "anonymous"} middleware ${entry.relation} ${entry.toMiddleware}`);
        }
        if (entry.relation === "after") {
          toMiddleware.after.push(entry);
        }
        if (entry.relation === "before") {
          toMiddleware.before.push(entry);
        }
      }
    });
    const mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expendedMiddlewareList) => {
      wholeList.push(...expendedMiddlewareList);
      return wholeList;
    }, []);
    return mainChain;
  };
  const stack = {
    add: (middleware, options = {}) => {
      const { name, override } = options;
      const entry = {
        step: "initialize",
        priority: "normal",
        middleware,
        ...options
      };
      if (name) {
        if (entriesNameSet.has(name)) {
          if (!override)
            throw new Error(`Duplicate middleware name '${name}'`);
          const toOverrideIndex = absoluteEntries.findIndex((entry2) => entry2.name === name);
          const toOverride = absoluteEntries[toOverrideIndex];
          if (toOverride.step !== entry.step || toOverride.priority !== entry.priority) {
            throw new Error(`"${name}" middleware with ${toOverride.priority} priority in ${toOverride.step} step cannot be overridden by same-name middleware with ${entry.priority} priority in ${entry.step} step.`);
          }
          absoluteEntries.splice(toOverrideIndex, 1);
        }
        entriesNameSet.add(name);
      }
      absoluteEntries.push(entry);
    },
    addRelativeTo: (middleware, options) => {
      const { name, override } = options;
      const entry = {
        middleware,
        ...options
      };
      if (name) {
        if (entriesNameSet.has(name)) {
          if (!override)
            throw new Error(`Duplicate middleware name '${name}'`);
          const toOverrideIndex = relativeEntries.findIndex((entry2) => entry2.name === name);
          const toOverride = relativeEntries[toOverrideIndex];
          if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
            throw new Error(`"${name}" middleware ${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden by same-name middleware ${entry.relation} "${entry.toMiddleware}" middleware.`);
          }
          relativeEntries.splice(toOverrideIndex, 1);
        }
        entriesNameSet.add(name);
      }
      relativeEntries.push(entry);
    },
    clone: () => cloneTo(constructStack()),
    use: (plugin) => {
      plugin.applyToStack(stack);
    },
    remove: (toRemove) => {
      if (typeof toRemove === "string")
        return removeByName(toRemove);
      else
        return removeByReference(toRemove);
    },
    removeByTag: (toRemove) => {
      let isRemoved = false;
      const filterCb = (entry) => {
        const { tags, name } = entry;
        if (tags && tags.includes(toRemove)) {
          if (name)
            entriesNameSet.delete(name);
          isRemoved = true;
          return false;
        }
        return true;
      };
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    },
    concat: (from) => {
      const cloned = cloneTo(constructStack());
      cloned.use(from);
      return cloned;
    },
    applyToStack: cloneTo,
    identify: () => {
      return getMiddlewareList(true).map((mw) => {
        return mw.name + ": " + (mw.tags || []).join(",");
      });
    },
    resolve: (handler, context) => {
      for (const middleware of getMiddlewareList().map((entry) => entry.middleware).reverse()) {
        handler = middleware(handler, context);
      }
      return handler;
    }
  };
  return stack;
};
var stepWeights = {
  initialize: 5,
  serialize: 4,
  build: 3,
  finalizeRequest: 2,
  deserialize: 1
};
var priorityWeights = {
  high: 3,
  normal: 2,
  low: 1
};

// ../../node_modules/@aws-sdk/smithy-client/dist-es/client.js
var Client = class {
  constructor(config) {
    this.middlewareStack = constructStack();
    this.config = config;
  }
  send(command, optionsOrCb, cb2) {
    const options = typeof optionsOrCb !== "function" ? optionsOrCb : void 0;
    const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb2;
    const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
    if (callback) {
      handler(command).then((result) => callback(null, result.output), (err) => callback(err)).catch(() => {
      });
    } else {
      return handler(command).then((result) => result.output);
    }
  }
  destroy() {
    if (this.config.requestHandler.destroy)
      this.config.requestHandler.destroy();
  }
};

// ../../node_modules/@aws-sdk/smithy-client/dist-es/command.js
var Command = class {
  constructor() {
    this.middlewareStack = constructStack();
  }
};

// ../../node_modules/@aws-sdk/smithy-client/dist-es/constants.js
var SENSITIVE_STRING = "***SensitiveInformation***";

// ../../node_modules/@aws-sdk/smithy-client/dist-es/parse-utils.js
var parseBoolean = (value) => {
  switch (value) {
    case "true":
      return true;
    case "false":
      return false;
    default:
      throw new Error(`Unable to parse boolean value "${value}"`);
  }
};
var expectNumber = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value === "string") {
    const parsed = parseFloat(value);
    if (!Number.isNaN(parsed)) {
      if (String(parsed) !== String(value)) {
        logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
      }
      return parsed;
    }
  }
  if (typeof value === "number") {
    return value;
  }
  throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
};
var MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
var expectFloat32 = (value) => {
  const expected = expectNumber(value);
  if (expected !== void 0 && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
    if (Math.abs(expected) > MAX_FLOAT) {
      throw new TypeError(`Expected 32-bit float, got ${value}`);
    }
  }
  return expected;
};
var expectLong = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (Number.isInteger(value) && !Number.isNaN(value)) {
    return value;
  }
  throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
};
var expectInt32 = (value) => expectSizedInt(value, 32);
var expectShort = (value) => expectSizedInt(value, 16);
var expectByte = (value) => expectSizedInt(value, 8);
var expectSizedInt = (value, size) => {
  const expected = expectLong(value);
  if (expected !== void 0 && castInt(expected, size) !== expected) {
    throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
  }
  return expected;
};
var castInt = (value, size) => {
  switch (size) {
    case 32:
      return Int32Array.of(value)[0];
    case 16:
      return Int16Array.of(value)[0];
    case 8:
      return Int8Array.of(value)[0];
  }
};
var expectNonNull = (value, location) => {
  if (value === null || value === void 0) {
    if (location) {
      throw new TypeError(`Expected a non-null value for ${location}`);
    }
    throw new TypeError("Expected a non-null value");
  }
  return value;
};
var expectObject = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value === "object" && !Array.isArray(value)) {
    return value;
  }
  const receivedType = Array.isArray(value) ? "array" : typeof value;
  throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
};
var expectString = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value === "string") {
    return value;
  }
  if (["boolean", "number", "bigint"].includes(typeof value)) {
    logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
    return String(value);
  }
  throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
};
var strictParseFloat32 = (value) => {
  if (typeof value == "string") {
    return expectFloat32(parseNumber(value));
  }
  return expectFloat32(value);
};
var NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
var parseNumber = (value) => {
  const matches = value.match(NUMBER_REGEX);
  if (matches === null || matches[0].length !== value.length) {
    throw new TypeError(`Expected real number, got implicit NaN`);
  }
  return parseFloat(value);
};
var strictParseLong = (value) => {
  if (typeof value === "string") {
    return expectLong(parseNumber(value));
  }
  return expectLong(value);
};
var strictParseInt32 = (value) => {
  if (typeof value === "string") {
    return expectInt32(parseNumber(value));
  }
  return expectInt32(value);
};
var strictParseShort = (value) => {
  if (typeof value === "string") {
    return expectShort(parseNumber(value));
  }
  return expectShort(value);
};
var strictParseByte = (value) => {
  if (typeof value === "string") {
    return expectByte(parseNumber(value));
  }
  return expectByte(value);
};
var stackTraceWarning = (message) => {
  return String(new TypeError(message).stack || message).split("\n").slice(0, 5).filter((s10) => !s10.includes("stackTraceWarning")).join("\n");
};
var logger = {
  warn: console.warn
};

// ../../node_modules/@aws-sdk/smithy-client/dist-es/date-utils.js
var DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
var MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function dateToUtcString(date2) {
  const year = date2.getUTCFullYear();
  const month = date2.getUTCMonth();
  const dayOfWeek = date2.getUTCDay();
  const dayOfMonthInt = date2.getUTCDate();
  const hoursInt = date2.getUTCHours();
  const minutesInt = date2.getUTCMinutes();
  const secondsInt = date2.getUTCSeconds();
  const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
  const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
  const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
  const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
  return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
}
var RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
var RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
var parseRfc3339DateTimeWithOffset = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value !== "string") {
    throw new TypeError("RFC-3339 date-times must be expressed as strings");
  }
  const match = RFC3339_WITH_OFFSET.exec(value);
  if (!match) {
    throw new TypeError("Invalid RFC-3339 date-time value");
  }
  const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
  const year = strictParseShort(stripLeadingZeroes(yearStr));
  const month = parseDateValue(monthStr, "month", 1, 12);
  const day = parseDateValue(dayStr, "day", 1, 31);
  const date2 = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
  if (offsetStr.toUpperCase() != "Z") {
    date2.setTime(date2.getTime() - parseOffsetToMilliseconds(offsetStr));
  }
  return date2;
};
var IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
var RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
var ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
var parseRfc7231DateTime = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value !== "string") {
    throw new TypeError("RFC-7231 date-times must be expressed as strings");
  }
  let match = IMF_FIXDATE.exec(value);
  if (match) {
    const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
    return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
  }
  match = RFC_850_DATE.exec(value);
  if (match) {
    const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
    return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
      hours,
      minutes,
      seconds,
      fractionalMilliseconds
    }));
  }
  match = ASC_TIME.exec(value);
  if (match) {
    const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
    return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
  }
  throw new TypeError("Invalid RFC-7231 date-time value");
};
var buildDate = (year, month, day, time) => {
  const adjustedMonth = month - 1;
  validateDayOfMonth(year, adjustedMonth, day);
  return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
};
var parseTwoDigitYear = (value) => {
  const thisYear = (/* @__PURE__ */ new Date()).getUTCFullYear();
  const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value));
  if (valueInThisCentury < thisYear) {
    return valueInThisCentury + 100;
  }
  return valueInThisCentury;
};
var FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1e3;
var adjustRfc850Year = (input) => {
  if (input.getTime() - (/* @__PURE__ */ new Date()).getTime() > FIFTY_YEARS_IN_MILLIS) {
    return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
  }
  return input;
};
var parseMonthByShortName = (value) => {
  const monthIdx = MONTHS.indexOf(value);
  if (monthIdx < 0) {
    throw new TypeError(`Invalid month: ${value}`);
  }
  return monthIdx + 1;
};
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var validateDayOfMonth = (year, month, day) => {
  let maxDays = DAYS_IN_MONTH[month];
  if (month === 1 && isLeapYear(year)) {
    maxDays = 29;
  }
  if (day > maxDays) {
    throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
  }
};
var isLeapYear = (year) => {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
var parseDateValue = (value, type, lower, upper) => {
  const dateVal = strictParseByte(stripLeadingZeroes(value));
  if (dateVal < lower || dateVal > upper) {
    throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
  }
  return dateVal;
};
var parseMilliseconds = (value) => {
  if (value === null || value === void 0) {
    return 0;
  }
  return strictParseFloat32("0." + value) * 1e3;
};
var parseOffsetToMilliseconds = (value) => {
  const directionStr = value[0];
  let direction = 1;
  if (directionStr == "+") {
    direction = 1;
  } else if (directionStr == "-") {
    direction = -1;
  } else {
    throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
  }
  const hour = Number(value.substring(1, 3));
  const minute = Number(value.substring(4, 6));
  return direction * (hour * 60 + minute) * 60 * 1e3;
};
var stripLeadingZeroes = (value) => {
  let idx = 0;
  while (idx < value.length - 1 && value.charAt(idx) === "0") {
    idx++;
  }
  if (idx === 0) {
    return value;
  }
  return value.slice(idx);
};

// ../../node_modules/@aws-sdk/smithy-client/dist-es/exceptions.js
var ServiceException = class extends Error {
  constructor(options) {
    super(options.message);
    Object.setPrototypeOf(this, ServiceException.prototype);
    this.name = options.name;
    this.$fault = options.$fault;
    this.$metadata = options.$metadata;
  }
};
var decorateServiceException = (exception, additions = {}) => {
  Object.entries(additions).filter(([, v7]) => v7 !== void 0).forEach(([k10, v7]) => {
    if (exception[k10] == void 0 || exception[k10] === "") {
      exception[k10] = v7;
    }
  });
  const message = exception.message || exception.Message || "UnknownError";
  exception.message = message;
  delete exception.Message;
  return exception;
};

// ../../node_modules/@aws-sdk/smithy-client/dist-es/default-error-handler.js
var throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
  const $metadata = deserializeMetadata(output);
  const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : void 0;
  const response = new exceptionCtor({
    name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknownError",
    $fault: "client",
    $metadata
  });
  throw decorateServiceException(response, parsedBody);
};
var deserializeMetadata = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});

// ../../node_modules/@aws-sdk/smithy-client/dist-es/defaults-mode.js
var loadConfigsForDefaultMode = (mode) => {
  switch (mode) {
    case "standard":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "in-region":
      return {
        retryMode: "standard",
        connectionTimeout: 1100
      };
    case "cross-region":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "mobile":
      return {
        retryMode: "standard",
        connectionTimeout: 3e4
      };
    default:
      return {};
  }
};

// ../../node_modules/@aws-sdk/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js
var warningEmitted = false;
var emitWarningIfUnsupportedVersion = (version) => {
  if (version && !warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 14) {
    warningEmitted = true;
  }
};

// ../../node_modules/@aws-sdk/smithy-client/dist-es/extended-encode-uri-component.js
function extendedEncodeURIComponent(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c10) {
    return "%" + c10.charCodeAt(0).toString(16).toUpperCase();
  });
}

// ../../node_modules/@aws-sdk/smithy-client/dist-es/get-array-if-single-item.js
var getArrayIfSingleItem = (mayBeArray) => Array.isArray(mayBeArray) ? mayBeArray : [mayBeArray];

// ../../node_modules/@aws-sdk/smithy-client/dist-es/get-value-from-text-node.js
var getValueFromTextNode = (obj) => {
  const textNodeName = "#text";
  for (const key in obj) {
    if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== void 0) {
      obj[key] = obj[key][textNodeName];
    } else if (typeof obj[key] === "object" && obj[key] !== null) {
      obj[key] = getValueFromTextNode(obj[key]);
    }
  }
  return obj;
};

// ../../node_modules/@aws-sdk/smithy-client/dist-es/lazy-json.js
var StringWrapper = function() {
  const Class = Object.getPrototypeOf(this).constructor;
  const Constructor = Function.bind.apply(String, [null, ...arguments]);
  const instance = new Constructor();
  Object.setPrototypeOf(instance, Class.prototype);
  return instance;
};
StringWrapper.prototype = Object.create(String.prototype, {
  constructor: {
    value: StringWrapper,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
Object.setPrototypeOf(StringWrapper, String);

// ../../node_modules/@aws-sdk/smithy-client/dist-es/object-mapping.js
function map2(arg0, arg1, arg2) {
  let target;
  let filter;
  let instructions;
  if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
    target = {};
    instructions = arg0;
  } else {
    target = arg0;
    if (typeof arg1 === "function") {
      filter = arg1;
      instructions = arg2;
      return mapWithFilter(target, filter, instructions);
    } else {
      instructions = arg1;
    }
  }
  for (const key of Object.keys(instructions)) {
    if (!Array.isArray(instructions[key])) {
      target[key] = instructions[key];
      continue;
    }
    let [filter2, value] = instructions[key];
    if (typeof value === "function") {
      let _value;
      const defaultFilterPassed = filter2 === void 0 && (_value = value()) != null;
      const customFilterPassed = typeof filter2 === "function" && !!filter2(void 0) || typeof filter2 !== "function" && !!filter2;
      if (defaultFilterPassed) {
        target[key] = _value;
      } else if (customFilterPassed) {
        target[key] = value();
      }
    } else {
      const defaultFilterPassed = filter2 === void 0 && value != null;
      const customFilterPassed = typeof filter2 === "function" && !!filter2(value) || typeof filter2 !== "function" && !!filter2;
      if (defaultFilterPassed || customFilterPassed) {
        target[key] = value;
      }
    }
  }
  return target;
}
var mapWithFilter = (target, filter, instructions) => {
  return map2(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
    if (Array.isArray(value)) {
      _instructions[key] = value;
    } else {
      if (typeof value === "function") {
        _instructions[key] = [filter, value()];
      } else {
        _instructions[key] = [filter, value];
      }
    }
    return _instructions;
  }, {}));
};

// ../../node_modules/@aws-sdk/smithy-client/dist-es/resolve-path.js
var resolvedPath = (resolvedPath2, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
  if (input != null && input[memberName] !== void 0) {
    const labelValue = labelValueProvider();
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
    }
    resolvedPath2 = resolvedPath2.replace(uriLabel, isGreedyLabel ? labelValue.split("/").map((segment) => extendedEncodeURIComponent(segment)).join("/") : extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: " + memberName + ".");
  }
  return resolvedPath2;
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/models/S3ServiceException.js
var S3ServiceException = class extends ServiceException {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, S3ServiceException.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/models/models_0.js
var RequestCharged;
(function(RequestCharged2) {
  RequestCharged2["requester"] = "requester";
})(RequestCharged || (RequestCharged = {}));
var RequestPayer;
(function(RequestPayer2) {
  RequestPayer2["requester"] = "requester";
})(RequestPayer || (RequestPayer = {}));
var BucketAccelerateStatus;
(function(BucketAccelerateStatus2) {
  BucketAccelerateStatus2["Enabled"] = "Enabled";
  BucketAccelerateStatus2["Suspended"] = "Suspended";
})(BucketAccelerateStatus || (BucketAccelerateStatus = {}));
var Type;
(function(Type2) {
  Type2["AmazonCustomerByEmail"] = "AmazonCustomerByEmail";
  Type2["CanonicalUser"] = "CanonicalUser";
  Type2["Group"] = "Group";
})(Type || (Type = {}));
var Permission;
(function(Permission2) {
  Permission2["FULL_CONTROL"] = "FULL_CONTROL";
  Permission2["READ"] = "READ";
  Permission2["READ_ACP"] = "READ_ACP";
  Permission2["WRITE"] = "WRITE";
  Permission2["WRITE_ACP"] = "WRITE_ACP";
})(Permission || (Permission = {}));
var OwnerOverride;
(function(OwnerOverride2) {
  OwnerOverride2["Destination"] = "Destination";
})(OwnerOverride || (OwnerOverride = {}));
var ServerSideEncryption;
(function(ServerSideEncryption2) {
  ServerSideEncryption2["AES256"] = "AES256";
  ServerSideEncryption2["aws_kms"] = "aws:kms";
})(ServerSideEncryption || (ServerSideEncryption = {}));
var ObjectCannedACL;
(function(ObjectCannedACL2) {
  ObjectCannedACL2["authenticated_read"] = "authenticated-read";
  ObjectCannedACL2["aws_exec_read"] = "aws-exec-read";
  ObjectCannedACL2["bucket_owner_full_control"] = "bucket-owner-full-control";
  ObjectCannedACL2["bucket_owner_read"] = "bucket-owner-read";
  ObjectCannedACL2["private"] = "private";
  ObjectCannedACL2["public_read"] = "public-read";
  ObjectCannedACL2["public_read_write"] = "public-read-write";
})(ObjectCannedACL || (ObjectCannedACL = {}));
var ChecksumAlgorithm;
(function(ChecksumAlgorithm3) {
  ChecksumAlgorithm3["CRC32"] = "CRC32";
  ChecksumAlgorithm3["CRC32C"] = "CRC32C";
  ChecksumAlgorithm3["SHA1"] = "SHA1";
  ChecksumAlgorithm3["SHA256"] = "SHA256";
})(ChecksumAlgorithm || (ChecksumAlgorithm = {}));
var MetadataDirective;
(function(MetadataDirective2) {
  MetadataDirective2["COPY"] = "COPY";
  MetadataDirective2["REPLACE"] = "REPLACE";
})(MetadataDirective || (MetadataDirective = {}));
var ObjectLockLegalHoldStatus;
(function(ObjectLockLegalHoldStatus2) {
  ObjectLockLegalHoldStatus2["OFF"] = "OFF";
  ObjectLockLegalHoldStatus2["ON"] = "ON";
})(ObjectLockLegalHoldStatus || (ObjectLockLegalHoldStatus = {}));
var ObjectLockMode;
(function(ObjectLockMode2) {
  ObjectLockMode2["COMPLIANCE"] = "COMPLIANCE";
  ObjectLockMode2["GOVERNANCE"] = "GOVERNANCE";
})(ObjectLockMode || (ObjectLockMode = {}));
var StorageClass;
(function(StorageClass2) {
  StorageClass2["DEEP_ARCHIVE"] = "DEEP_ARCHIVE";
  StorageClass2["GLACIER"] = "GLACIER";
  StorageClass2["GLACIER_IR"] = "GLACIER_IR";
  StorageClass2["INTELLIGENT_TIERING"] = "INTELLIGENT_TIERING";
  StorageClass2["ONEZONE_IA"] = "ONEZONE_IA";
  StorageClass2["OUTPOSTS"] = "OUTPOSTS";
  StorageClass2["REDUCED_REDUNDANCY"] = "REDUCED_REDUNDANCY";
  StorageClass2["STANDARD"] = "STANDARD";
  StorageClass2["STANDARD_IA"] = "STANDARD_IA";
})(StorageClass || (StorageClass = {}));
var TaggingDirective;
(function(TaggingDirective2) {
  TaggingDirective2["COPY"] = "COPY";
  TaggingDirective2["REPLACE"] = "REPLACE";
})(TaggingDirective || (TaggingDirective = {}));
var ObjectNotInActiveTierError = class extends S3ServiceException {
  constructor(opts) {
    super({
      name: "ObjectNotInActiveTierError",
      $fault: "client",
      ...opts
    });
    this.name = "ObjectNotInActiveTierError";
    this.$fault = "client";
    Object.setPrototypeOf(this, ObjectNotInActiveTierError.prototype);
  }
};
var BucketCannedACL;
(function(BucketCannedACL2) {
  BucketCannedACL2["authenticated_read"] = "authenticated-read";
  BucketCannedACL2["private"] = "private";
  BucketCannedACL2["public_read"] = "public-read";
  BucketCannedACL2["public_read_write"] = "public-read-write";
})(BucketCannedACL || (BucketCannedACL = {}));
var BucketLocationConstraint;
(function(BucketLocationConstraint2) {
  BucketLocationConstraint2["EU"] = "EU";
  BucketLocationConstraint2["af_south_1"] = "af-south-1";
  BucketLocationConstraint2["ap_east_1"] = "ap-east-1";
  BucketLocationConstraint2["ap_northeast_1"] = "ap-northeast-1";
  BucketLocationConstraint2["ap_northeast_2"] = "ap-northeast-2";
  BucketLocationConstraint2["ap_northeast_3"] = "ap-northeast-3";
  BucketLocationConstraint2["ap_south_1"] = "ap-south-1";
  BucketLocationConstraint2["ap_southeast_1"] = "ap-southeast-1";
  BucketLocationConstraint2["ap_southeast_2"] = "ap-southeast-2";
  BucketLocationConstraint2["ap_southeast_3"] = "ap-southeast-3";
  BucketLocationConstraint2["ca_central_1"] = "ca-central-1";
  BucketLocationConstraint2["cn_north_1"] = "cn-north-1";
  BucketLocationConstraint2["cn_northwest_1"] = "cn-northwest-1";
  BucketLocationConstraint2["eu_central_1"] = "eu-central-1";
  BucketLocationConstraint2["eu_north_1"] = "eu-north-1";
  BucketLocationConstraint2["eu_south_1"] = "eu-south-1";
  BucketLocationConstraint2["eu_west_1"] = "eu-west-1";
  BucketLocationConstraint2["eu_west_2"] = "eu-west-2";
  BucketLocationConstraint2["eu_west_3"] = "eu-west-3";
  BucketLocationConstraint2["me_south_1"] = "me-south-1";
  BucketLocationConstraint2["sa_east_1"] = "sa-east-1";
  BucketLocationConstraint2["us_east_2"] = "us-east-2";
  BucketLocationConstraint2["us_gov_east_1"] = "us-gov-east-1";
  BucketLocationConstraint2["us_gov_west_1"] = "us-gov-west-1";
  BucketLocationConstraint2["us_west_1"] = "us-west-1";
  BucketLocationConstraint2["us_west_2"] = "us-west-2";
})(BucketLocationConstraint || (BucketLocationConstraint = {}));
var ObjectOwnership;
(function(ObjectOwnership2) {
  ObjectOwnership2["BucketOwnerEnforced"] = "BucketOwnerEnforced";
  ObjectOwnership2["BucketOwnerPreferred"] = "BucketOwnerPreferred";
  ObjectOwnership2["ObjectWriter"] = "ObjectWriter";
})(ObjectOwnership || (ObjectOwnership = {}));
var AnalyticsFilter;
(function(AnalyticsFilter2) {
  AnalyticsFilter2.visit = (value, visitor) => {
    if (value.Prefix !== void 0)
      return visitor.Prefix(value.Prefix);
    if (value.Tag !== void 0)
      return visitor.Tag(value.Tag);
    if (value.And !== void 0)
      return visitor.And(value.And);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(AnalyticsFilter || (AnalyticsFilter = {}));
var AnalyticsS3ExportFileFormat;
(function(AnalyticsS3ExportFileFormat2) {
  AnalyticsS3ExportFileFormat2["CSV"] = "CSV";
})(AnalyticsS3ExportFileFormat || (AnalyticsS3ExportFileFormat = {}));
var StorageClassAnalysisSchemaVersion;
(function(StorageClassAnalysisSchemaVersion2) {
  StorageClassAnalysisSchemaVersion2["V_1"] = "V_1";
})(StorageClassAnalysisSchemaVersion || (StorageClassAnalysisSchemaVersion = {}));
var IntelligentTieringStatus;
(function(IntelligentTieringStatus2) {
  IntelligentTieringStatus2["Disabled"] = "Disabled";
  IntelligentTieringStatus2["Enabled"] = "Enabled";
})(IntelligentTieringStatus || (IntelligentTieringStatus = {}));
var IntelligentTieringAccessTier;
(function(IntelligentTieringAccessTier2) {
  IntelligentTieringAccessTier2["ARCHIVE_ACCESS"] = "ARCHIVE_ACCESS";
  IntelligentTieringAccessTier2["DEEP_ARCHIVE_ACCESS"] = "DEEP_ARCHIVE_ACCESS";
})(IntelligentTieringAccessTier || (IntelligentTieringAccessTier = {}));
var InventoryFormat;
(function(InventoryFormat2) {
  InventoryFormat2["CSV"] = "CSV";
  InventoryFormat2["ORC"] = "ORC";
  InventoryFormat2["Parquet"] = "Parquet";
})(InventoryFormat || (InventoryFormat = {}));
var InventoryIncludedObjectVersions;
(function(InventoryIncludedObjectVersions2) {
  InventoryIncludedObjectVersions2["All"] = "All";
  InventoryIncludedObjectVersions2["Current"] = "Current";
})(InventoryIncludedObjectVersions || (InventoryIncludedObjectVersions = {}));
var InventoryOptionalField;
(function(InventoryOptionalField2) {
  InventoryOptionalField2["BucketKeyStatus"] = "BucketKeyStatus";
  InventoryOptionalField2["ChecksumAlgorithm"] = "ChecksumAlgorithm";
  InventoryOptionalField2["ETag"] = "ETag";
  InventoryOptionalField2["EncryptionStatus"] = "EncryptionStatus";
  InventoryOptionalField2["IntelligentTieringAccessTier"] = "IntelligentTieringAccessTier";
  InventoryOptionalField2["IsMultipartUploaded"] = "IsMultipartUploaded";
  InventoryOptionalField2["LastModifiedDate"] = "LastModifiedDate";
  InventoryOptionalField2["ObjectLockLegalHoldStatus"] = "ObjectLockLegalHoldStatus";
  InventoryOptionalField2["ObjectLockMode"] = "ObjectLockMode";
  InventoryOptionalField2["ObjectLockRetainUntilDate"] = "ObjectLockRetainUntilDate";
  InventoryOptionalField2["ReplicationStatus"] = "ReplicationStatus";
  InventoryOptionalField2["Size"] = "Size";
  InventoryOptionalField2["StorageClass"] = "StorageClass";
})(InventoryOptionalField || (InventoryOptionalField = {}));
var InventoryFrequency;
(function(InventoryFrequency2) {
  InventoryFrequency2["Daily"] = "Daily";
  InventoryFrequency2["Weekly"] = "Weekly";
})(InventoryFrequency || (InventoryFrequency = {}));
var LifecycleRuleFilter;
(function(LifecycleRuleFilter2) {
  LifecycleRuleFilter2.visit = (value, visitor) => {
    if (value.Prefix !== void 0)
      return visitor.Prefix(value.Prefix);
    if (value.Tag !== void 0)
      return visitor.Tag(value.Tag);
    if (value.ObjectSizeGreaterThan !== void 0)
      return visitor.ObjectSizeGreaterThan(value.ObjectSizeGreaterThan);
    if (value.ObjectSizeLessThan !== void 0)
      return visitor.ObjectSizeLessThan(value.ObjectSizeLessThan);
    if (value.And !== void 0)
      return visitor.And(value.And);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(LifecycleRuleFilter || (LifecycleRuleFilter = {}));
var TransitionStorageClass;
(function(TransitionStorageClass2) {
  TransitionStorageClass2["DEEP_ARCHIVE"] = "DEEP_ARCHIVE";
  TransitionStorageClass2["GLACIER"] = "GLACIER";
  TransitionStorageClass2["GLACIER_IR"] = "GLACIER_IR";
  TransitionStorageClass2["INTELLIGENT_TIERING"] = "INTELLIGENT_TIERING";
  TransitionStorageClass2["ONEZONE_IA"] = "ONEZONE_IA";
  TransitionStorageClass2["STANDARD_IA"] = "STANDARD_IA";
})(TransitionStorageClass || (TransitionStorageClass = {}));
var ExpirationStatus;
(function(ExpirationStatus2) {
  ExpirationStatus2["Disabled"] = "Disabled";
  ExpirationStatus2["Enabled"] = "Enabled";
})(ExpirationStatus || (ExpirationStatus = {}));
var BucketLogsPermission;
(function(BucketLogsPermission2) {
  BucketLogsPermission2["FULL_CONTROL"] = "FULL_CONTROL";
  BucketLogsPermission2["READ"] = "READ";
  BucketLogsPermission2["WRITE"] = "WRITE";
})(BucketLogsPermission || (BucketLogsPermission = {}));
var MetricsFilter;
(function(MetricsFilter2) {
  MetricsFilter2.visit = (value, visitor) => {
    if (value.Prefix !== void 0)
      return visitor.Prefix(value.Prefix);
    if (value.Tag !== void 0)
      return visitor.Tag(value.Tag);
    if (value.AccessPointArn !== void 0)
      return visitor.AccessPointArn(value.AccessPointArn);
    if (value.And !== void 0)
      return visitor.And(value.And);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(MetricsFilter || (MetricsFilter = {}));
var FilterRuleName;
(function(FilterRuleName2) {
  FilterRuleName2["prefix"] = "prefix";
  FilterRuleName2["suffix"] = "suffix";
})(FilterRuleName || (FilterRuleName = {}));
var DeleteMarkerReplicationStatus;
(function(DeleteMarkerReplicationStatus2) {
  DeleteMarkerReplicationStatus2["Disabled"] = "Disabled";
  DeleteMarkerReplicationStatus2["Enabled"] = "Enabled";
})(DeleteMarkerReplicationStatus || (DeleteMarkerReplicationStatus = {}));
var MetricsStatus;
(function(MetricsStatus2) {
  MetricsStatus2["Disabled"] = "Disabled";
  MetricsStatus2["Enabled"] = "Enabled";
})(MetricsStatus || (MetricsStatus = {}));
var ReplicationTimeStatus;
(function(ReplicationTimeStatus2) {
  ReplicationTimeStatus2["Disabled"] = "Disabled";
  ReplicationTimeStatus2["Enabled"] = "Enabled";
})(ReplicationTimeStatus || (ReplicationTimeStatus = {}));
var ExistingObjectReplicationStatus;
(function(ExistingObjectReplicationStatus2) {
  ExistingObjectReplicationStatus2["Disabled"] = "Disabled";
  ExistingObjectReplicationStatus2["Enabled"] = "Enabled";
})(ExistingObjectReplicationStatus || (ExistingObjectReplicationStatus = {}));
var ReplicationRuleFilter;
(function(ReplicationRuleFilter2) {
  ReplicationRuleFilter2.visit = (value, visitor) => {
    if (value.Prefix !== void 0)
      return visitor.Prefix(value.Prefix);
    if (value.Tag !== void 0)
      return visitor.Tag(value.Tag);
    if (value.And !== void 0)
      return visitor.And(value.And);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(ReplicationRuleFilter || (ReplicationRuleFilter = {}));
var ReplicaModificationsStatus;
(function(ReplicaModificationsStatus2) {
  ReplicaModificationsStatus2["Disabled"] = "Disabled";
  ReplicaModificationsStatus2["Enabled"] = "Enabled";
})(ReplicaModificationsStatus || (ReplicaModificationsStatus = {}));
var SseKmsEncryptedObjectsStatus;
(function(SseKmsEncryptedObjectsStatus2) {
  SseKmsEncryptedObjectsStatus2["Disabled"] = "Disabled";
  SseKmsEncryptedObjectsStatus2["Enabled"] = "Enabled";
})(SseKmsEncryptedObjectsStatus || (SseKmsEncryptedObjectsStatus = {}));
var ReplicationRuleStatus;
(function(ReplicationRuleStatus2) {
  ReplicationRuleStatus2["Disabled"] = "Disabled";
  ReplicationRuleStatus2["Enabled"] = "Enabled";
})(ReplicationRuleStatus || (ReplicationRuleStatus = {}));
var Payer;
(function(Payer2) {
  Payer2["BucketOwner"] = "BucketOwner";
  Payer2["Requester"] = "Requester";
})(Payer || (Payer = {}));
var MFADeleteStatus;
(function(MFADeleteStatus2) {
  MFADeleteStatus2["Disabled"] = "Disabled";
  MFADeleteStatus2["Enabled"] = "Enabled";
})(MFADeleteStatus || (MFADeleteStatus = {}));
var BucketVersioningStatus;
(function(BucketVersioningStatus2) {
  BucketVersioningStatus2["Enabled"] = "Enabled";
  BucketVersioningStatus2["Suspended"] = "Suspended";
})(BucketVersioningStatus || (BucketVersioningStatus = {}));
var Protocol;
(function(Protocol2) {
  Protocol2["http"] = "http";
  Protocol2["https"] = "https";
})(Protocol || (Protocol = {}));
var ReplicationStatus;
(function(ReplicationStatus2) {
  ReplicationStatus2["COMPLETE"] = "COMPLETE";
  ReplicationStatus2["FAILED"] = "FAILED";
  ReplicationStatus2["PENDING"] = "PENDING";
  ReplicationStatus2["REPLICA"] = "REPLICA";
})(ReplicationStatus || (ReplicationStatus = {}));
var ChecksumMode;
(function(ChecksumMode2) {
  ChecksumMode2["ENABLED"] = "ENABLED";
})(ChecksumMode || (ChecksumMode = {}));
var InvalidObjectState = class extends S3ServiceException {
  constructor(opts) {
    super({
      name: "InvalidObjectState",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidObjectState";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidObjectState.prototype);
    this.StorageClass = opts.StorageClass;
    this.AccessTier = opts.AccessTier;
  }
};
var NoSuchKey = class extends S3ServiceException {
  constructor(opts) {
    super({
      name: "NoSuchKey",
      $fault: "client",
      ...opts
    });
    this.name = "NoSuchKey";
    this.$fault = "client";
    Object.setPrototypeOf(this, NoSuchKey.prototype);
  }
};
var ObjectAttributes;
(function(ObjectAttributes2) {
  ObjectAttributes2["CHECKSUM"] = "Checksum";
  ObjectAttributes2["ETAG"] = "ETag";
  ObjectAttributes2["OBJECT_PARTS"] = "ObjectParts";
  ObjectAttributes2["OBJECT_SIZE"] = "ObjectSize";
  ObjectAttributes2["STORAGE_CLASS"] = "StorageClass";
})(ObjectAttributes || (ObjectAttributes = {}));
var ObjectLockEnabled;
(function(ObjectLockEnabled2) {
  ObjectLockEnabled2["Enabled"] = "Enabled";
})(ObjectLockEnabled || (ObjectLockEnabled = {}));
var ObjectLockRetentionMode;
(function(ObjectLockRetentionMode2) {
  ObjectLockRetentionMode2["COMPLIANCE"] = "COMPLIANCE";
  ObjectLockRetentionMode2["GOVERNANCE"] = "GOVERNANCE";
})(ObjectLockRetentionMode || (ObjectLockRetentionMode = {}));
var NotFound = class extends S3ServiceException {
  constructor(opts) {
    super({
      name: "NotFound",
      $fault: "client",
      ...opts
    });
    this.name = "NotFound";
    this.$fault = "client";
    Object.setPrototypeOf(this, NotFound.prototype);
  }
};
var ArchiveStatus;
(function(ArchiveStatus2) {
  ArchiveStatus2["ARCHIVE_ACCESS"] = "ARCHIVE_ACCESS";
  ArchiveStatus2["DEEP_ARCHIVE_ACCESS"] = "DEEP_ARCHIVE_ACCESS";
})(ArchiveStatus || (ArchiveStatus = {}));
var EncodingType;
(function(EncodingType2) {
  EncodingType2["url"] = "url";
})(EncodingType || (EncodingType = {}));
var ObjectStorageClass;
(function(ObjectStorageClass2) {
  ObjectStorageClass2["DEEP_ARCHIVE"] = "DEEP_ARCHIVE";
  ObjectStorageClass2["GLACIER"] = "GLACIER";
  ObjectStorageClass2["GLACIER_IR"] = "GLACIER_IR";
  ObjectStorageClass2["INTELLIGENT_TIERING"] = "INTELLIGENT_TIERING";
  ObjectStorageClass2["ONEZONE_IA"] = "ONEZONE_IA";
  ObjectStorageClass2["OUTPOSTS"] = "OUTPOSTS";
  ObjectStorageClass2["REDUCED_REDUNDANCY"] = "REDUCED_REDUNDANCY";
  ObjectStorageClass2["STANDARD"] = "STANDARD";
  ObjectStorageClass2["STANDARD_IA"] = "STANDARD_IA";
})(ObjectStorageClass || (ObjectStorageClass = {}));
var NoSuchBucket = class extends S3ServiceException {
  constructor(opts) {
    super({
      name: "NoSuchBucket",
      $fault: "client",
      ...opts
    });
    this.name = "NoSuchBucket";
    this.$fault = "client";
    Object.setPrototypeOf(this, NoSuchBucket.prototype);
  }
};
var ObjectVersionStorageClass;
(function(ObjectVersionStorageClass2) {
  ObjectVersionStorageClass2["STANDARD"] = "STANDARD";
})(ObjectVersionStorageClass || (ObjectVersionStorageClass = {}));
var MFADelete;
(function(MFADelete2) {
  MFADelete2["Disabled"] = "Disabled";
  MFADelete2["Enabled"] = "Enabled";
})(MFADelete || (MFADelete = {}));
var CopyObjectOutputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING },
  ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING }
});
var CopyObjectRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING },
  ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING },
  ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING },
  ...obj.CopySourceSSECustomerKey && { CopySourceSSECustomerKey: SENSITIVE_STRING }
});
var DeleteObjectOutputFilterSensitiveLog = (obj) => ({
  ...obj
});
var DeleteObjectRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var GetObjectOutputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING }
});
var GetObjectRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING }
});
var HeadObjectOutputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING }
});
var HeadObjectRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING }
});
var ListObjectsV2OutputFilterSensitiveLog = (obj) => ({
  ...obj
});
var ListObjectsV2RequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var PutObjectOutputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING },
  ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING }
});
var PutObjectRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING },
  ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING },
  ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING }
});

// ../../node_modules/@aws-sdk/protocol-http/dist-es/FieldPosition.js
var FieldPosition;
(function(FieldPosition4) {
  FieldPosition4[FieldPosition4["HEADER"] = 0] = "HEADER";
  FieldPosition4[FieldPosition4["TRAILER"] = 1] = "TRAILER";
})(FieldPosition || (FieldPosition = {}));

// ../../node_modules/@aws-sdk/protocol-http/dist-es/httpRequest.js
var HttpRequest = class {
  constructor(options) {
    this.method = options.method || "GET";
    this.hostname = options.hostname || "localhost";
    this.port = options.port;
    this.query = options.query || {};
    this.headers = options.headers || {};
    this.body = options.body;
    this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
    this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
  }
  static isInstance(request2) {
    if (!request2)
      return false;
    const req = request2;
    return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
  }
  clone() {
    const cloned = new HttpRequest({
      ...this,
      headers: { ...this.headers }
    });
    if (cloned.query)
      cloned.query = cloneQuery(cloned.query);
    return cloned;
  }
};
function cloneQuery(query) {
  return Object.keys(query).reduce((carry, paramName) => {
    const param = query[paramName];
    return {
      ...carry,
      [paramName]: Array.isArray(param) ? [...param] : param
    };
  }, {});
}

// ../../node_modules/@aws-sdk/protocol-http/dist-es/httpResponse.js
var HttpResponse = class {
  constructor(options) {
    this.statusCode = options.statusCode;
    this.headers = options.headers || {};
    this.body = options.body;
  }
  static isInstance(response) {
    if (!response)
      return false;
    const resp = response;
    return typeof resp.statusCode === "number" && typeof resp.headers === "object";
  }
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/protocols/Aws_restXml.js
var import_fast_xml_parser = __toESM(require_fxp());
var serializeAws_restXmlCopyObjectCommand = async (input, context) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers = map3({}, isSerializableHeaderValue, {
    "x-amz-acl": input.ACL,
    "cache-control": input.CacheControl,
    "x-amz-checksum-algorithm": input.ChecksumAlgorithm,
    "content-disposition": input.ContentDisposition,
    "content-encoding": input.ContentEncoding,
    "content-language": input.ContentLanguage,
    "content-type": input.ContentType,
    "x-amz-copy-source": input.CopySource,
    "x-amz-copy-source-if-match": input.CopySourceIfMatch,
    "x-amz-copy-source-if-modified-since": [
      () => isSerializableHeaderValue(input.CopySourceIfModifiedSince),
      () => dateToUtcString(input.CopySourceIfModifiedSince).toString()
    ],
    "x-amz-copy-source-if-none-match": input.CopySourceIfNoneMatch,
    "x-amz-copy-source-if-unmodified-since": [
      () => isSerializableHeaderValue(input.CopySourceIfUnmodifiedSince),
      () => dateToUtcString(input.CopySourceIfUnmodifiedSince).toString()
    ],
    expires: [() => isSerializableHeaderValue(input.Expires), () => dateToUtcString(input.Expires).toString()],
    "x-amz-grant-full-control": input.GrantFullControl,
    "x-amz-grant-read": input.GrantRead,
    "x-amz-grant-read-acp": input.GrantReadACP,
    "x-amz-grant-write-acp": input.GrantWriteACP,
    "x-amz-metadata-directive": input.MetadataDirective,
    "x-amz-tagging-directive": input.TaggingDirective,
    "x-amz-server-side-encryption": input.ServerSideEncryption,
    "x-amz-storage-class": input.StorageClass,
    "x-amz-website-redirect-location": input.WebsiteRedirectLocation,
    "x-amz-server-side-encryption-customer-algorithm": input.SSECustomerAlgorithm,
    "x-amz-server-side-encryption-customer-key": input.SSECustomerKey,
    "x-amz-server-side-encryption-customer-key-md5": input.SSECustomerKeyMD5,
    "x-amz-server-side-encryption-aws-kms-key-id": input.SSEKMSKeyId,
    "x-amz-server-side-encryption-context": input.SSEKMSEncryptionContext,
    "x-amz-server-side-encryption-bucket-key-enabled": [
      () => isSerializableHeaderValue(input.BucketKeyEnabled),
      () => input.BucketKeyEnabled.toString()
    ],
    "x-amz-copy-source-server-side-encryption-customer-algorithm": input.CopySourceSSECustomerAlgorithm,
    "x-amz-copy-source-server-side-encryption-customer-key": input.CopySourceSSECustomerKey,
    "x-amz-copy-source-server-side-encryption-customer-key-md5": input.CopySourceSSECustomerKeyMD5,
    "x-amz-request-payer": input.RequestPayer,
    "x-amz-tagging": input.Tagging,
    "x-amz-object-lock-mode": input.ObjectLockMode,
    "x-amz-object-lock-retain-until-date": [
      () => isSerializableHeaderValue(input.ObjectLockRetainUntilDate),
      () => (input.ObjectLockRetainUntilDate.toISOString().split(".")[0] + "Z").toString()
    ],
    "x-amz-object-lock-legal-hold": input.ObjectLockLegalHoldStatus,
    "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
    "x-amz-source-expected-bucket-owner": input.ExpectedSourceBucketOwner,
    ...input.Metadata !== void 0 && Object.keys(input.Metadata).reduce((acc, suffix) => {
      acc[`x-amz-meta-${suffix.toLowerCase()}`] = input.Metadata[suffix];
      return acc;
    }, {})
  });
  let resolvedPath2 = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}/{Key+}`;
  resolvedPath2 = resolvedPath(resolvedPath2, input, "Bucket", () => input.Bucket, "{Bucket}", false);
  resolvedPath2 = resolvedPath(resolvedPath2, input, "Key", () => input.Key, "{Key+}", true);
  const query = map3({
    "x-id": [, "CopyObject"]
  });
  let body;
  return new HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath2,
    query,
    body
  });
};
var serializeAws_restXmlDeleteObjectCommand = async (input, context) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers = map3({}, isSerializableHeaderValue, {
    "x-amz-mfa": input.MFA,
    "x-amz-request-payer": input.RequestPayer,
    "x-amz-bypass-governance-retention": [
      () => isSerializableHeaderValue(input.BypassGovernanceRetention),
      () => input.BypassGovernanceRetention.toString()
    ],
    "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
  });
  let resolvedPath2 = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}/{Key+}`;
  resolvedPath2 = resolvedPath(resolvedPath2, input, "Bucket", () => input.Bucket, "{Bucket}", false);
  resolvedPath2 = resolvedPath(resolvedPath2, input, "Key", () => input.Key, "{Key+}", true);
  const query = map3({
    "x-id": [, "DeleteObject"],
    versionId: [, input.VersionId]
  });
  let body;
  return new HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath2,
    query,
    body
  });
};
var serializeAws_restXmlGetObjectCommand = async (input, context) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers = map3({}, isSerializableHeaderValue, {
    "if-match": input.IfMatch,
    "if-modified-since": [
      () => isSerializableHeaderValue(input.IfModifiedSince),
      () => dateToUtcString(input.IfModifiedSince).toString()
    ],
    "if-none-match": input.IfNoneMatch,
    "if-unmodified-since": [
      () => isSerializableHeaderValue(input.IfUnmodifiedSince),
      () => dateToUtcString(input.IfUnmodifiedSince).toString()
    ],
    range: input.Range,
    "x-amz-server-side-encryption-customer-algorithm": input.SSECustomerAlgorithm,
    "x-amz-server-side-encryption-customer-key": input.SSECustomerKey,
    "x-amz-server-side-encryption-customer-key-md5": input.SSECustomerKeyMD5,
    "x-amz-request-payer": input.RequestPayer,
    "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
    "x-amz-checksum-mode": input.ChecksumMode
  });
  let resolvedPath2 = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}/{Key+}`;
  resolvedPath2 = resolvedPath(resolvedPath2, input, "Bucket", () => input.Bucket, "{Bucket}", false);
  resolvedPath2 = resolvedPath(resolvedPath2, input, "Key", () => input.Key, "{Key+}", true);
  const query = map3({
    "x-id": [, "GetObject"],
    "response-cache-control": [, input.ResponseCacheControl],
    "response-content-disposition": [, input.ResponseContentDisposition],
    "response-content-encoding": [, input.ResponseContentEncoding],
    "response-content-language": [, input.ResponseContentLanguage],
    "response-content-type": [, input.ResponseContentType],
    "response-expires": [
      () => input.ResponseExpires !== void 0,
      () => dateToUtcString(input.ResponseExpires).toString()
    ],
    versionId: [, input.VersionId],
    partNumber: [() => input.PartNumber !== void 0, () => input.PartNumber.toString()]
  });
  let body;
  return new HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath2,
    query,
    body
  });
};
var serializeAws_restXmlHeadObjectCommand = async (input, context) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers = map3({}, isSerializableHeaderValue, {
    "if-match": input.IfMatch,
    "if-modified-since": [
      () => isSerializableHeaderValue(input.IfModifiedSince),
      () => dateToUtcString(input.IfModifiedSince).toString()
    ],
    "if-none-match": input.IfNoneMatch,
    "if-unmodified-since": [
      () => isSerializableHeaderValue(input.IfUnmodifiedSince),
      () => dateToUtcString(input.IfUnmodifiedSince).toString()
    ],
    range: input.Range,
    "x-amz-server-side-encryption-customer-algorithm": input.SSECustomerAlgorithm,
    "x-amz-server-side-encryption-customer-key": input.SSECustomerKey,
    "x-amz-server-side-encryption-customer-key-md5": input.SSECustomerKeyMD5,
    "x-amz-request-payer": input.RequestPayer,
    "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
    "x-amz-checksum-mode": input.ChecksumMode
  });
  let resolvedPath2 = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}/{Key+}`;
  resolvedPath2 = resolvedPath(resolvedPath2, input, "Bucket", () => input.Bucket, "{Bucket}", false);
  resolvedPath2 = resolvedPath(resolvedPath2, input, "Key", () => input.Key, "{Key+}", true);
  const query = map3({
    versionId: [, input.VersionId],
    partNumber: [() => input.PartNumber !== void 0, () => input.PartNumber.toString()]
  });
  let body;
  return new HttpRequest({
    protocol,
    hostname,
    port,
    method: "HEAD",
    headers,
    path: resolvedPath2,
    query,
    body
  });
};
var serializeAws_restXmlListObjectsV2Command = async (input, context) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers = map3({}, isSerializableHeaderValue, {
    "x-amz-request-payer": input.RequestPayer,
    "x-amz-expected-bucket-owner": input.ExpectedBucketOwner
  });
  let resolvedPath2 = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}/`;
  resolvedPath2 = resolvedPath(resolvedPath2, input, "Bucket", () => input.Bucket, "{Bucket}", false);
  const query = map3({
    "list-type": [, "2"],
    delimiter: [, input.Delimiter],
    "encoding-type": [, input.EncodingType],
    "max-keys": [() => input.MaxKeys !== void 0, () => input.MaxKeys.toString()],
    prefix: [, input.Prefix],
    "continuation-token": [, input.ContinuationToken],
    "fetch-owner": [() => input.FetchOwner !== void 0, () => input.FetchOwner.toString()],
    "start-after": [, input.StartAfter]
  });
  let body;
  return new HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath2,
    query,
    body
  });
};
var serializeAws_restXmlPutObjectCommand = async (input, context) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers = map3({}, isSerializableHeaderValue, {
    "content-type": input.ContentType || "application/octet-stream",
    "x-amz-acl": input.ACL,
    "cache-control": input.CacheControl,
    "content-disposition": input.ContentDisposition,
    "content-encoding": input.ContentEncoding,
    "content-language": input.ContentLanguage,
    "content-length": [() => isSerializableHeaderValue(input.ContentLength), () => input.ContentLength.toString()],
    "content-md5": input.ContentMD5,
    "x-amz-sdk-checksum-algorithm": input.ChecksumAlgorithm,
    "x-amz-checksum-crc32": input.ChecksumCRC32,
    "x-amz-checksum-crc32c": input.ChecksumCRC32C,
    "x-amz-checksum-sha1": input.ChecksumSHA1,
    "x-amz-checksum-sha256": input.ChecksumSHA256,
    expires: [() => isSerializableHeaderValue(input.Expires), () => dateToUtcString(input.Expires).toString()],
    "x-amz-grant-full-control": input.GrantFullControl,
    "x-amz-grant-read": input.GrantRead,
    "x-amz-grant-read-acp": input.GrantReadACP,
    "x-amz-grant-write-acp": input.GrantWriteACP,
    "x-amz-server-side-encryption": input.ServerSideEncryption,
    "x-amz-storage-class": input.StorageClass,
    "x-amz-website-redirect-location": input.WebsiteRedirectLocation,
    "x-amz-server-side-encryption-customer-algorithm": input.SSECustomerAlgorithm,
    "x-amz-server-side-encryption-customer-key": input.SSECustomerKey,
    "x-amz-server-side-encryption-customer-key-md5": input.SSECustomerKeyMD5,
    "x-amz-server-side-encryption-aws-kms-key-id": input.SSEKMSKeyId,
    "x-amz-server-side-encryption-context": input.SSEKMSEncryptionContext,
    "x-amz-server-side-encryption-bucket-key-enabled": [
      () => isSerializableHeaderValue(input.BucketKeyEnabled),
      () => input.BucketKeyEnabled.toString()
    ],
    "x-amz-request-payer": input.RequestPayer,
    "x-amz-tagging": input.Tagging,
    "x-amz-object-lock-mode": input.ObjectLockMode,
    "x-amz-object-lock-retain-until-date": [
      () => isSerializableHeaderValue(input.ObjectLockRetainUntilDate),
      () => (input.ObjectLockRetainUntilDate.toISOString().split(".")[0] + "Z").toString()
    ],
    "x-amz-object-lock-legal-hold": input.ObjectLockLegalHoldStatus,
    "x-amz-expected-bucket-owner": input.ExpectedBucketOwner,
    ...input.Metadata !== void 0 && Object.keys(input.Metadata).reduce((acc, suffix) => {
      acc[`x-amz-meta-${suffix.toLowerCase()}`] = input.Metadata[suffix];
      return acc;
    }, {})
  });
  let resolvedPath2 = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}/{Key+}`;
  resolvedPath2 = resolvedPath(resolvedPath2, input, "Bucket", () => input.Bucket, "{Bucket}", false);
  resolvedPath2 = resolvedPath(resolvedPath2, input, "Key", () => input.Key, "{Key+}", true);
  const query = map3({
    "x-id": [, "PutObject"]
  });
  let body;
  if (input.Body !== void 0) {
    body = input.Body;
  }
  let contents;
  if (input.Body !== void 0) {
    contents = input.Body;
    body = contents;
  }
  return new HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath2,
    query,
    body
  });
};
var deserializeAws_restXmlCopyObjectCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restXmlCopyObjectCommandError(output, context);
  }
  const contents = map3({
    $metadata: deserializeMetadata2(output),
    Expiration: [, output.headers["x-amz-expiration"]],
    CopySourceVersionId: [, output.headers["x-amz-copy-source-version-id"]],
    VersionId: [, output.headers["x-amz-version-id"]],
    ServerSideEncryption: [, output.headers["x-amz-server-side-encryption"]],
    SSECustomerAlgorithm: [, output.headers["x-amz-server-side-encryption-customer-algorithm"]],
    SSECustomerKeyMD5: [, output.headers["x-amz-server-side-encryption-customer-key-md5"]],
    SSEKMSKeyId: [, output.headers["x-amz-server-side-encryption-aws-kms-key-id"]],
    SSEKMSEncryptionContext: [, output.headers["x-amz-server-side-encryption-context"]],
    BucketKeyEnabled: [
      () => void 0 !== output.headers["x-amz-server-side-encryption-bucket-key-enabled"],
      () => parseBoolean(output.headers["x-amz-server-side-encryption-bucket-key-enabled"])
    ],
    RequestCharged: [, output.headers["x-amz-request-charged"]]
  });
  const data = expectObject(await parseBody(output.body, context));
  contents.CopyObjectResult = deserializeAws_restXmlCopyObjectResult(data, context);
  return contents;
};
var deserializeAws_restXmlCopyObjectCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ObjectNotInActiveTierError":
    case "com.amazonaws.s3#ObjectNotInActiveTierError":
      throw await deserializeAws_restXmlObjectNotInActiveTierErrorResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: S3ServiceException,
        errorCode
      });
  }
};
var deserializeAws_restXmlDeleteObjectCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restXmlDeleteObjectCommandError(output, context);
  }
  const contents = map3({
    $metadata: deserializeMetadata2(output),
    DeleteMarker: [
      () => void 0 !== output.headers["x-amz-delete-marker"],
      () => parseBoolean(output.headers["x-amz-delete-marker"])
    ],
    VersionId: [, output.headers["x-amz-version-id"]],
    RequestCharged: [, output.headers["x-amz-request-charged"]]
  });
  await collectBody(output.body, context);
  return contents;
};
var deserializeAws_restXmlDeleteObjectCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  const parsedBody = parsedOutput.body;
  throwDefaultError({
    output,
    parsedBody,
    exceptionCtor: S3ServiceException,
    errorCode
  });
};
var deserializeAws_restXmlGetObjectCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restXmlGetObjectCommandError(output, context);
  }
  const contents = map3({
    $metadata: deserializeMetadata2(output),
    DeleteMarker: [
      () => void 0 !== output.headers["x-amz-delete-marker"],
      () => parseBoolean(output.headers["x-amz-delete-marker"])
    ],
    AcceptRanges: [, output.headers["accept-ranges"]],
    Expiration: [, output.headers["x-amz-expiration"]],
    Restore: [, output.headers["x-amz-restore"]],
    LastModified: [
      () => void 0 !== output.headers["last-modified"],
      () => expectNonNull(parseRfc7231DateTime(output.headers["last-modified"]))
    ],
    ContentLength: [
      () => void 0 !== output.headers["content-length"],
      () => strictParseLong(output.headers["content-length"])
    ],
    ETag: [, output.headers["etag"]],
    ChecksumCRC32: [, output.headers["x-amz-checksum-crc32"]],
    ChecksumCRC32C: [, output.headers["x-amz-checksum-crc32c"]],
    ChecksumSHA1: [, output.headers["x-amz-checksum-sha1"]],
    ChecksumSHA256: [, output.headers["x-amz-checksum-sha256"]],
    MissingMeta: [
      () => void 0 !== output.headers["x-amz-missing-meta"],
      () => strictParseInt32(output.headers["x-amz-missing-meta"])
    ],
    VersionId: [, output.headers["x-amz-version-id"]],
    CacheControl: [, output.headers["cache-control"]],
    ContentDisposition: [, output.headers["content-disposition"]],
    ContentEncoding: [, output.headers["content-encoding"]],
    ContentLanguage: [, output.headers["content-language"]],
    ContentRange: [, output.headers["content-range"]],
    ContentType: [, output.headers["content-type"]],
    Expires: [
      () => void 0 !== output.headers["expires"],
      () => expectNonNull(parseRfc7231DateTime(output.headers["expires"]))
    ],
    WebsiteRedirectLocation: [, output.headers["x-amz-website-redirect-location"]],
    ServerSideEncryption: [, output.headers["x-amz-server-side-encryption"]],
    SSECustomerAlgorithm: [, output.headers["x-amz-server-side-encryption-customer-algorithm"]],
    SSECustomerKeyMD5: [, output.headers["x-amz-server-side-encryption-customer-key-md5"]],
    SSEKMSKeyId: [, output.headers["x-amz-server-side-encryption-aws-kms-key-id"]],
    BucketKeyEnabled: [
      () => void 0 !== output.headers["x-amz-server-side-encryption-bucket-key-enabled"],
      () => parseBoolean(output.headers["x-amz-server-side-encryption-bucket-key-enabled"])
    ],
    StorageClass: [, output.headers["x-amz-storage-class"]],
    RequestCharged: [, output.headers["x-amz-request-charged"]],
    ReplicationStatus: [, output.headers["x-amz-replication-status"]],
    PartsCount: [
      () => void 0 !== output.headers["x-amz-mp-parts-count"],
      () => strictParseInt32(output.headers["x-amz-mp-parts-count"])
    ],
    TagCount: [
      () => void 0 !== output.headers["x-amz-tagging-count"],
      () => strictParseInt32(output.headers["x-amz-tagging-count"])
    ],
    ObjectLockMode: [, output.headers["x-amz-object-lock-mode"]],
    ObjectLockRetainUntilDate: [
      () => void 0 !== output.headers["x-amz-object-lock-retain-until-date"],
      () => expectNonNull(parseRfc3339DateTimeWithOffset(output.headers["x-amz-object-lock-retain-until-date"]))
    ],
    ObjectLockLegalHoldStatus: [, output.headers["x-amz-object-lock-legal-hold"]],
    Metadata: [
      ,
      Object.keys(output.headers).filter((header) => header.startsWith("x-amz-meta-")).reduce((acc, header) => {
        acc[header.substring(11)] = output.headers[header];
        return acc;
      }, {})
    ]
  });
  const data = output.body;
  context.sdkStreamMixin(data);
  contents.Body = data;
  return contents;
};
var deserializeAws_restXmlGetObjectCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidObjectState":
    case "com.amazonaws.s3#InvalidObjectState":
      throw await deserializeAws_restXmlInvalidObjectStateResponse(parsedOutput, context);
    case "NoSuchKey":
    case "com.amazonaws.s3#NoSuchKey":
      throw await deserializeAws_restXmlNoSuchKeyResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: S3ServiceException,
        errorCode
      });
  }
};
var deserializeAws_restXmlHeadObjectCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restXmlHeadObjectCommandError(output, context);
  }
  const contents = map3({
    $metadata: deserializeMetadata2(output),
    DeleteMarker: [
      () => void 0 !== output.headers["x-amz-delete-marker"],
      () => parseBoolean(output.headers["x-amz-delete-marker"])
    ],
    AcceptRanges: [, output.headers["accept-ranges"]],
    Expiration: [, output.headers["x-amz-expiration"]],
    Restore: [, output.headers["x-amz-restore"]],
    ArchiveStatus: [, output.headers["x-amz-archive-status"]],
    LastModified: [
      () => void 0 !== output.headers["last-modified"],
      () => expectNonNull(parseRfc7231DateTime(output.headers["last-modified"]))
    ],
    ContentLength: [
      () => void 0 !== output.headers["content-length"],
      () => strictParseLong(output.headers["content-length"])
    ],
    ChecksumCRC32: [, output.headers["x-amz-checksum-crc32"]],
    ChecksumCRC32C: [, output.headers["x-amz-checksum-crc32c"]],
    ChecksumSHA1: [, output.headers["x-amz-checksum-sha1"]],
    ChecksumSHA256: [, output.headers["x-amz-checksum-sha256"]],
    ETag: [, output.headers["etag"]],
    MissingMeta: [
      () => void 0 !== output.headers["x-amz-missing-meta"],
      () => strictParseInt32(output.headers["x-amz-missing-meta"])
    ],
    VersionId: [, output.headers["x-amz-version-id"]],
    CacheControl: [, output.headers["cache-control"]],
    ContentDisposition: [, output.headers["content-disposition"]],
    ContentEncoding: [, output.headers["content-encoding"]],
    ContentLanguage: [, output.headers["content-language"]],
    ContentType: [, output.headers["content-type"]],
    Expires: [
      () => void 0 !== output.headers["expires"],
      () => expectNonNull(parseRfc7231DateTime(output.headers["expires"]))
    ],
    WebsiteRedirectLocation: [, output.headers["x-amz-website-redirect-location"]],
    ServerSideEncryption: [, output.headers["x-amz-server-side-encryption"]],
    SSECustomerAlgorithm: [, output.headers["x-amz-server-side-encryption-customer-algorithm"]],
    SSECustomerKeyMD5: [, output.headers["x-amz-server-side-encryption-customer-key-md5"]],
    SSEKMSKeyId: [, output.headers["x-amz-server-side-encryption-aws-kms-key-id"]],
    BucketKeyEnabled: [
      () => void 0 !== output.headers["x-amz-server-side-encryption-bucket-key-enabled"],
      () => parseBoolean(output.headers["x-amz-server-side-encryption-bucket-key-enabled"])
    ],
    StorageClass: [, output.headers["x-amz-storage-class"]],
    RequestCharged: [, output.headers["x-amz-request-charged"]],
    ReplicationStatus: [, output.headers["x-amz-replication-status"]],
    PartsCount: [
      () => void 0 !== output.headers["x-amz-mp-parts-count"],
      () => strictParseInt32(output.headers["x-amz-mp-parts-count"])
    ],
    ObjectLockMode: [, output.headers["x-amz-object-lock-mode"]],
    ObjectLockRetainUntilDate: [
      () => void 0 !== output.headers["x-amz-object-lock-retain-until-date"],
      () => expectNonNull(parseRfc3339DateTimeWithOffset(output.headers["x-amz-object-lock-retain-until-date"]))
    ],
    ObjectLockLegalHoldStatus: [, output.headers["x-amz-object-lock-legal-hold"]],
    Metadata: [
      ,
      Object.keys(output.headers).filter((header) => header.startsWith("x-amz-meta-")).reduce((acc, header) => {
        acc[header.substring(11)] = output.headers[header];
        return acc;
      }, {})
    ]
  });
  await collectBody(output.body, context);
  return contents;
};
var deserializeAws_restXmlHeadObjectCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFound":
    case "com.amazonaws.s3#NotFound":
      throw await deserializeAws_restXmlNotFoundResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: S3ServiceException,
        errorCode
      });
  }
};
var deserializeAws_restXmlListObjectsV2Command = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restXmlListObjectsV2CommandError(output, context);
  }
  const contents = map3({
    $metadata: deserializeMetadata2(output)
  });
  const data = expectNonNull(expectObject(await parseBody(output.body, context)), "body");
  if (data.CommonPrefixes === "") {
    contents.CommonPrefixes = [];
  } else if (data["CommonPrefixes"] !== void 0) {
    contents.CommonPrefixes = deserializeAws_restXmlCommonPrefixList(getArrayIfSingleItem(data["CommonPrefixes"]), context);
  }
  if (data.Contents === "") {
    contents.Contents = [];
  } else if (data["Contents"] !== void 0) {
    contents.Contents = deserializeAws_restXmlObjectList(getArrayIfSingleItem(data["Contents"]), context);
  }
  if (data["ContinuationToken"] !== void 0) {
    contents.ContinuationToken = expectString(data["ContinuationToken"]);
  }
  if (data["Delimiter"] !== void 0) {
    contents.Delimiter = expectString(data["Delimiter"]);
  }
  if (data["EncodingType"] !== void 0) {
    contents.EncodingType = expectString(data["EncodingType"]);
  }
  if (data["IsTruncated"] !== void 0) {
    contents.IsTruncated = parseBoolean(data["IsTruncated"]);
  }
  if (data["KeyCount"] !== void 0) {
    contents.KeyCount = strictParseInt32(data["KeyCount"]);
  }
  if (data["MaxKeys"] !== void 0) {
    contents.MaxKeys = strictParseInt32(data["MaxKeys"]);
  }
  if (data["Name"] !== void 0) {
    contents.Name = expectString(data["Name"]);
  }
  if (data["NextContinuationToken"] !== void 0) {
    contents.NextContinuationToken = expectString(data["NextContinuationToken"]);
  }
  if (data["Prefix"] !== void 0) {
    contents.Prefix = expectString(data["Prefix"]);
  }
  if (data["StartAfter"] !== void 0) {
    contents.StartAfter = expectString(data["StartAfter"]);
  }
  return contents;
};
var deserializeAws_restXmlListObjectsV2CommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NoSuchBucket":
    case "com.amazonaws.s3#NoSuchBucket":
      throw await deserializeAws_restXmlNoSuchBucketResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: S3ServiceException,
        errorCode
      });
  }
};
var deserializeAws_restXmlPutObjectCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restXmlPutObjectCommandError(output, context);
  }
  const contents = map3({
    $metadata: deserializeMetadata2(output),
    Expiration: [, output.headers["x-amz-expiration"]],
    ETag: [, output.headers["etag"]],
    ChecksumCRC32: [, output.headers["x-amz-checksum-crc32"]],
    ChecksumCRC32C: [, output.headers["x-amz-checksum-crc32c"]],
    ChecksumSHA1: [, output.headers["x-amz-checksum-sha1"]],
    ChecksumSHA256: [, output.headers["x-amz-checksum-sha256"]],
    ServerSideEncryption: [, output.headers["x-amz-server-side-encryption"]],
    VersionId: [, output.headers["x-amz-version-id"]],
    SSECustomerAlgorithm: [, output.headers["x-amz-server-side-encryption-customer-algorithm"]],
    SSECustomerKeyMD5: [, output.headers["x-amz-server-side-encryption-customer-key-md5"]],
    SSEKMSKeyId: [, output.headers["x-amz-server-side-encryption-aws-kms-key-id"]],
    SSEKMSEncryptionContext: [, output.headers["x-amz-server-side-encryption-context"]],
    BucketKeyEnabled: [
      () => void 0 !== output.headers["x-amz-server-side-encryption-bucket-key-enabled"],
      () => parseBoolean(output.headers["x-amz-server-side-encryption-bucket-key-enabled"])
    ],
    RequestCharged: [, output.headers["x-amz-request-charged"]]
  });
  await collectBody(output.body, context);
  return contents;
};
var deserializeAws_restXmlPutObjectCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  const parsedBody = parsedOutput.body;
  throwDefaultError({
    output,
    parsedBody,
    exceptionCtor: S3ServiceException,
    errorCode
  });
};
var map3 = map2;
var deserializeAws_restXmlInvalidObjectStateResponse = async (parsedOutput, context) => {
  const contents = map3({});
  const data = parsedOutput.body;
  if (data["AccessTier"] !== void 0) {
    contents.AccessTier = expectString(data["AccessTier"]);
  }
  if (data["StorageClass"] !== void 0) {
    contents.StorageClass = expectString(data["StorageClass"]);
  }
  const exception = new InvalidObjectState({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var deserializeAws_restXmlNoSuchBucketResponse = async (parsedOutput, context) => {
  const contents = map3({});
  const data = parsedOutput.body;
  const exception = new NoSuchBucket({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var deserializeAws_restXmlNoSuchKeyResponse = async (parsedOutput, context) => {
  const contents = map3({});
  const data = parsedOutput.body;
  const exception = new NoSuchKey({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var deserializeAws_restXmlNotFoundResponse = async (parsedOutput, context) => {
  const contents = map3({});
  const data = parsedOutput.body;
  const exception = new NotFound({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var deserializeAws_restXmlObjectNotInActiveTierErrorResponse = async (parsedOutput, context) => {
  const contents = map3({});
  const data = parsedOutput.body;
  const exception = new ObjectNotInActiveTierError({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var deserializeAws_restXmlChecksumAlgorithmList = (output, context) => {
  return (output || []).filter((e10) => e10 != null).map((entry) => {
    return expectString(entry);
  });
};
var deserializeAws_restXmlCommonPrefix = (output, context) => {
  const contents = {
    Prefix: void 0
  };
  if (output["Prefix"] !== void 0) {
    contents.Prefix = expectString(output["Prefix"]);
  }
  return contents;
};
var deserializeAws_restXmlCommonPrefixList = (output, context) => {
  return (output || []).filter((e10) => e10 != null).map((entry) => {
    return deserializeAws_restXmlCommonPrefix(entry, context);
  });
};
var deserializeAws_restXmlCopyObjectResult = (output, context) => {
  const contents = {
    ETag: void 0,
    LastModified: void 0,
    ChecksumCRC32: void 0,
    ChecksumCRC32C: void 0,
    ChecksumSHA1: void 0,
    ChecksumSHA256: void 0
  };
  if (output["ETag"] !== void 0) {
    contents.ETag = expectString(output["ETag"]);
  }
  if (output["LastModified"] !== void 0) {
    contents.LastModified = expectNonNull(parseRfc3339DateTimeWithOffset(output["LastModified"]));
  }
  if (output["ChecksumCRC32"] !== void 0) {
    contents.ChecksumCRC32 = expectString(output["ChecksumCRC32"]);
  }
  if (output["ChecksumCRC32C"] !== void 0) {
    contents.ChecksumCRC32C = expectString(output["ChecksumCRC32C"]);
  }
  if (output["ChecksumSHA1"] !== void 0) {
    contents.ChecksumSHA1 = expectString(output["ChecksumSHA1"]);
  }
  if (output["ChecksumSHA256"] !== void 0) {
    contents.ChecksumSHA256 = expectString(output["ChecksumSHA256"]);
  }
  return contents;
};
var deserializeAws_restXml_Object = (output, context) => {
  const contents = {
    Key: void 0,
    LastModified: void 0,
    ETag: void 0,
    ChecksumAlgorithm: void 0,
    Size: void 0,
    StorageClass: void 0,
    Owner: void 0
  };
  if (output["Key"] !== void 0) {
    contents.Key = expectString(output["Key"]);
  }
  if (output["LastModified"] !== void 0) {
    contents.LastModified = expectNonNull(parseRfc3339DateTimeWithOffset(output["LastModified"]));
  }
  if (output["ETag"] !== void 0) {
    contents.ETag = expectString(output["ETag"]);
  }
  if (output.ChecksumAlgorithm === "") {
    contents.ChecksumAlgorithm = [];
  } else if (output["ChecksumAlgorithm"] !== void 0) {
    contents.ChecksumAlgorithm = deserializeAws_restXmlChecksumAlgorithmList(getArrayIfSingleItem(output["ChecksumAlgorithm"]), context);
  }
  if (output["Size"] !== void 0) {
    contents.Size = strictParseLong(output["Size"]);
  }
  if (output["StorageClass"] !== void 0) {
    contents.StorageClass = expectString(output["StorageClass"]);
  }
  if (output["Owner"] !== void 0) {
    contents.Owner = deserializeAws_restXmlOwner(output["Owner"], context);
  }
  return contents;
};
var deserializeAws_restXmlObjectList = (output, context) => {
  return (output || []).filter((e10) => e10 != null).map((entry) => {
    return deserializeAws_restXml_Object(entry, context);
  });
};
var deserializeAws_restXmlOwner = (output, context) => {
  const contents = {
    DisplayName: void 0,
    ID: void 0
  };
  if (output["DisplayName"] !== void 0) {
    contents.DisplayName = expectString(output["DisplayName"]);
  }
  if (output["ID"] !== void 0) {
    contents.ID = expectString(output["ID"]);
  }
  return contents;
};
var deserializeMetadata2 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
var collectBody = (streamBody = new Uint8Array(), context) => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
var collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
var isSerializableHeaderValue = (value) => value !== void 0 && value !== null && value !== "" && (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) && (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
var parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
  if (encoded.length) {
    const parser = new import_fast_xml_parser.XMLParser({
      attributeNamePrefix: "",
      htmlEntities: true,
      ignoreAttributes: false,
      ignoreDeclaration: true,
      parseTagValue: false,
      trimValues: false,
      tagValueProcessor: (_, val) => val.trim() === "" && val.includes("\n") ? "" : void 0
    });
    parser.addEntity("#xD", "\r");
    parser.addEntity("#10", "\n");
    const parsedObj = parser.parse(encoded);
    const textNodeName = "#text";
    const key = Object.keys(parsedObj)[0];
    const parsedObjToReturn = parsedObj[key];
    if (parsedObjToReturn[textNodeName]) {
      parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
      delete parsedObjToReturn[textNodeName];
    }
    return getValueFromTextNode(parsedObjToReturn);
  }
  return {};
});
var parseErrorBody = async (errorBody, context) => {
  const value = await parseBody(errorBody, context);
  if (value.Error) {
    value.Error.message = value.Error.message ?? value.Error.Message;
  }
  return value;
};
var loadRestXmlErrorCode = (output, data) => {
  if (data?.Code !== void 0) {
    return data.Code;
  }
  if (output.statusCode == 404) {
    return "NotFound";
  }
};

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/check-content-length-header.js
var CONTENT_LENGTH_HEADER = "content-length";
function checkContentLengthHeader() {
  return (next, context) => async (args) => {
    const { request: request2 } = args;
    if (HttpRequest.isInstance(request2)) {
      if (!request2.headers[CONTENT_LENGTH_HEADER]) {
        const message = `Are you using a Stream of unknown length as the Body of a PutObject request? Consider using Upload instead from @aws-sdk/lib-storage.`;
        if (typeof context?.logger?.warn === "function") {
          context.logger.warn(message);
        } else {
          console.warn(message);
        }
      }
    }
    return next({ ...args });
  };
}
var checkContentLengthHeaderMiddlewareOptions = {
  step: "finalizeRequest",
  tags: ["CHECK_CONTENT_LENGTH_HEADER"],
  name: "getCheckContentLengthHeaderPlugin",
  override: true
};
var getCheckContentLengthHeaderPlugin = (unused) => ({
  applyToStack: (clientStack) => {
    clientStack.add(checkContentLengthHeader(), checkContentLengthHeaderMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/configuration.js
var resolveS3Config = (input) => ({
  ...input,
  forcePathStyle: input.forcePathStyle ?? false,
  useAccelerateEndpoint: input.useAccelerateEndpoint ?? false,
  disableMultiregionAccessPoints: input.disableMultiregionAccessPoints ?? false
});

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/throw-200-exceptions.js
var throw200ExceptionsMiddleware = (config) => (next) => async (args) => {
  const result = await next(args);
  const { response } = result;
  if (!HttpResponse.isInstance(response))
    return result;
  const { statusCode, body } = response;
  if (statusCode < 200 || statusCode >= 300)
    return result;
  const bodyBytes = await collectBody2(body, config);
  const bodyString = await collectBodyString2(bodyBytes, config);
  if (bodyBytes.length === 0) {
    const err = new Error("S3 aborted request");
    err.name = "InternalError";
    throw err;
  }
  if (bodyString && bodyString.match("<Error>")) {
    response.statusCode = 400;
  }
  response.body = bodyBytes;
  return result;
};
var collectBody2 = (streamBody = new Uint8Array(), context) => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
var collectBodyString2 = (streamBody, context) => collectBody2(streamBody, context).then((body) => context.utf8Encoder(body));
var throw200ExceptionsMiddlewareOptions = {
  relation: "after",
  toMiddleware: "deserializerMiddleware",
  tags: ["THROW_200_EXCEPTIONS", "S3"],
  name: "throw200ExceptionsMiddleware",
  override: true
};
var getThrow200ExceptionsPlugin = (config) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(throw200ExceptionsMiddleware(config), throw200ExceptionsMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/util-arn-parser/dist-es/index.js
var validate = (str) => typeof str === "string" && str.indexOf("arn:") === 0 && str.split(":").length >= 6;

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/validate-bucket-name.js
function validateBucketNameMiddleware() {
  return (next) => async (args) => {
    const { input: { Bucket } } = args;
    if (typeof Bucket === "string" && !validate(Bucket) && Bucket.indexOf("/") >= 0) {
      const err = new Error(`Bucket name shouldn't contain '/', received '${Bucket}'`);
      err.name = "InvalidBucketName";
      throw err;
    }
    return next({ ...args });
  };
}
var validateBucketNameMiddlewareOptions = {
  step: "initialize",
  tags: ["VALIDATE_BUCKET_NAME"],
  name: "validateBucketNameMiddleware",
  override: true
};
var getValidateBucketNamePlugin = (unused) => ({
  applyToStack: (clientStack) => {
    clientStack.add(validateBucketNameMiddleware(), validateBucketNameMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/middleware-ssec/dist-es/index.js
function ssecMiddleware(options) {
  return (next) => async (args) => {
    let input = { ...args.input };
    const properties = [
      {
        target: "SSECustomerKey",
        hash: "SSECustomerKeyMD5"
      },
      {
        target: "CopySourceSSECustomerKey",
        hash: "CopySourceSSECustomerKeyMD5"
      }
    ];
    for (const prop of properties) {
      const value = input[prop.target];
      if (value) {
        const valueView = ArrayBuffer.isView(value) ? new Uint8Array(value.buffer, value.byteOffset, value.byteLength) : typeof value === "string" ? options.utf8Decoder(value) : new Uint8Array(value);
        const encoded = options.base64Encoder(valueView);
        const hash2 = new options.md5();
        hash2.update(valueView);
        input = {
          ...input,
          [prop.target]: encoded,
          [prop.hash]: options.base64Encoder(await hash2.digest())
        };
      }
    }
    return next({
      ...args,
      input
    });
  };
}
var ssecMiddlewareOptions = {
  name: "ssecMiddleware",
  step: "initialize",
  tags: ["SSE"],
  override: true
};
var getSsecPlugin = (config) => ({
  applyToStack: (clientStack) => {
    clientStack.add(ssecMiddleware(config), ssecMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/client-s3/dist-es/commands/CopyObjectCommand.js
var CopyObjectCommand = class extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      Bucket: { type: "contextParams", name: "Bucket" },
      ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
      UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
      DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
      Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, CopyObjectCommand.getEndpointParameterInstructions()));
    this.middlewareStack.use(getThrow200ExceptionsPlugin(configuration));
    this.middlewareStack.use(getSsecPlugin(configuration));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "S3Client";
    const commandName = "CopyObjectCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: CopyObjectRequestFilterSensitiveLog,
      outputFilterSensitiveLog: CopyObjectOutputFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_restXmlCopyObjectCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_restXmlCopyObjectCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteObjectCommand.js
var DeleteObjectCommand = class extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      Bucket: { type: "contextParams", name: "Bucket" },
      ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
      UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
      DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
      Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, DeleteObjectCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "S3Client";
    const commandName = "DeleteObjectCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: DeleteObjectRequestFilterSensitiveLog,
      outputFilterSensitiveLog: DeleteObjectOutputFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_restXmlDeleteObjectCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_restXmlDeleteObjectCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/constants.js
var ChecksumAlgorithm2;
(function(ChecksumAlgorithm3) {
  ChecksumAlgorithm3["MD5"] = "MD5";
  ChecksumAlgorithm3["CRC32"] = "CRC32";
  ChecksumAlgorithm3["CRC32C"] = "CRC32C";
  ChecksumAlgorithm3["SHA1"] = "SHA1";
  ChecksumAlgorithm3["SHA256"] = "SHA256";
})(ChecksumAlgorithm2 || (ChecksumAlgorithm2 = {}));
var ChecksumLocation;
(function(ChecksumLocation2) {
  ChecksumLocation2["HEADER"] = "header";
  ChecksumLocation2["TRAILER"] = "trailer";
})(ChecksumLocation || (ChecksumLocation = {}));

// ../../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/types.js
var CLIENT_SUPPORTED_ALGORITHMS = [
  ChecksumAlgorithm2.CRC32,
  ChecksumAlgorithm2.CRC32C,
  ChecksumAlgorithm2.SHA1,
  ChecksumAlgorithm2.SHA256
];
var PRIORITY_ORDER_ALGORITHMS = [
  ChecksumAlgorithm2.CRC32,
  ChecksumAlgorithm2.CRC32C,
  ChecksumAlgorithm2.SHA1,
  ChecksumAlgorithm2.SHA256
];

// ../../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumAlgorithmForRequest.js
var getChecksumAlgorithmForRequest = (input, { requestChecksumRequired, requestAlgorithmMember }) => {
  if (!requestAlgorithmMember || !input[requestAlgorithmMember]) {
    return requestChecksumRequired ? ChecksumAlgorithm2.MD5 : void 0;
  }
  const checksumAlgorithm = input[requestAlgorithmMember];
  if (!CLIENT_SUPPORTED_ALGORITHMS.includes(checksumAlgorithm)) {
    throw new Error(`The checksum algorithm "${checksumAlgorithm}" is not supported by the client. Select one of ${CLIENT_SUPPORTED_ALGORITHMS}.`);
  }
  return checksumAlgorithm;
};

// ../../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumLocationName.js
var getChecksumLocationName = (algorithm) => algorithm === ChecksumAlgorithm2.MD5 ? "content-md5" : `x-amz-checksum-${algorithm.toLowerCase()}`;

// ../../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/hasHeader.js
var hasHeader = (header, headers) => {
  const soughtHeader = header.toLowerCase();
  for (const headerName of Object.keys(headers)) {
    if (soughtHeader === headerName.toLowerCase()) {
      return true;
    }
  }
  return false;
};

// ../../node_modules/@aws-sdk/is-array-buffer/dist-es/index.js
var isArrayBuffer = (arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]";

// ../../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/isStreaming.js
var isStreaming = (body) => body !== void 0 && typeof body !== "string" && !ArrayBuffer.isView(body) && !isArrayBuffer(body);

// ../../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/selectChecksumAlgorithmFunction.js
var import_crc32 = __toESM(require_build2());
var import_crc32c = __toESM(require_build3());
var selectChecksumAlgorithmFunction = (checksumAlgorithm, config) => ({
  [ChecksumAlgorithm2.MD5]: config.md5,
  [ChecksumAlgorithm2.CRC32]: import_crc32.AwsCrc32,
  [ChecksumAlgorithm2.CRC32C]: import_crc32c.AwsCrc32c,
  [ChecksumAlgorithm2.SHA1]: config.sha1,
  [ChecksumAlgorithm2.SHA256]: config.sha256
})[checksumAlgorithm];

// ../../node_modules/@aws-sdk/util-buffer-from/dist-es/index.js
var import_buffer = require("buffer");
var fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
  if (!isArrayBuffer(input)) {
    throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
  }
  return import_buffer.Buffer.from(input, offset, length);
};
var fromString = (input, encoding) => {
  if (typeof input !== "string") {
    throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
  }
  return encoding ? import_buffer.Buffer.from(input, encoding) : import_buffer.Buffer.from(input);
};

// ../../node_modules/@aws-sdk/util-utf8/dist-es/fromUtf8.js
var fromUtf84 = (input) => {
  const buf = fromString(input, "utf8");
  return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};

// ../../node_modules/@aws-sdk/util-utf8/dist-es/toUint8Array.js
var toUint8Array = (data) => {
  if (typeof data === "string") {
    return fromUtf84(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
};

// ../../node_modules/@aws-sdk/util-utf8/dist-es/toUtf8.js
var toUtf84 = (input) => fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("utf8");

// ../../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/stringHasher.js
var stringHasher = (checksumAlgorithmFn, body) => {
  const hash2 = new checksumAlgorithmFn();
  hash2.update(toUint8Array(body || ""));
  return hash2.digest();
};

// ../../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksum.js
var getChecksum = async (body, { streamHasher, checksumAlgorithmFn, base64Encoder }) => {
  const digest = isStreaming(body) ? streamHasher(checksumAlgorithmFn, body) : stringHasher(checksumAlgorithmFn, body);
  return base64Encoder(await digest);
};

// ../../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumAlgorithmListForResponse.js
var getChecksumAlgorithmListForResponse = (responseAlgorithms = []) => {
  const validChecksumAlgorithms = [];
  for (const algorithm of PRIORITY_ORDER_ALGORITHMS) {
    if (!responseAlgorithms.includes(algorithm) || !CLIENT_SUPPORTED_ALGORITHMS.includes(algorithm)) {
      continue;
    }
    validChecksumAlgorithms.push(algorithm);
  }
  return validChecksumAlgorithms;
};

// ../../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/validateChecksumFromResponse.js
var validateChecksumFromResponse = async (response, { config, responseAlgorithms }) => {
  const checksumAlgorithms = getChecksumAlgorithmListForResponse(responseAlgorithms);
  const { body: responseBody, headers: responseHeaders } = response;
  for (const algorithm of checksumAlgorithms) {
    const responseHeader = getChecksumLocationName(algorithm);
    const checksumFromResponse = responseHeaders[responseHeader];
    if (checksumFromResponse) {
      const checksumAlgorithmFn = selectChecksumAlgorithmFunction(algorithm, config);
      const { streamHasher, base64Encoder } = config;
      const checksum = await getChecksum(responseBody, { streamHasher, checksumAlgorithmFn, base64Encoder });
      if (checksum === checksumFromResponse) {
        break;
      }
      throw new Error(`Checksum mismatch: expected "${checksum}" but received "${checksumFromResponse}" in response header "${responseHeader}".`);
    }
  }
};

// ../../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsMiddleware.js
var flexibleChecksumsMiddleware = (config, middlewareConfig) => (next) => async (args) => {
  if (!HttpRequest.isInstance(args.request)) {
    return next(args);
  }
  const { request: request2 } = args;
  const { body: requestBody, headers } = request2;
  const { base64Encoder, streamHasher } = config;
  const { input, requestChecksumRequired, requestAlgorithmMember } = middlewareConfig;
  const checksumAlgorithm = getChecksumAlgorithmForRequest(input, {
    requestChecksumRequired,
    requestAlgorithmMember
  });
  let updatedBody = requestBody;
  let updatedHeaders = headers;
  if (checksumAlgorithm) {
    const checksumLocationName = getChecksumLocationName(checksumAlgorithm);
    const checksumAlgorithmFn = selectChecksumAlgorithmFunction(checksumAlgorithm, config);
    if (isStreaming(requestBody)) {
      const { getAwsChunkedEncodingStream: getAwsChunkedEncodingStream2, bodyLengthChecker } = config;
      updatedBody = getAwsChunkedEncodingStream2(requestBody, {
        base64Encoder,
        bodyLengthChecker,
        checksumLocationName,
        checksumAlgorithmFn,
        streamHasher
      });
      updatedHeaders = {
        ...headers,
        "content-encoding": headers["content-encoding"] ? `${headers["content-encoding"]},aws-chunked` : "aws-chunked",
        "transfer-encoding": "chunked",
        "x-amz-decoded-content-length": headers["content-length"],
        "x-amz-content-sha256": "STREAMING-UNSIGNED-PAYLOAD-TRAILER",
        "x-amz-trailer": checksumLocationName
      };
      delete updatedHeaders["content-length"];
    } else if (!hasHeader(checksumLocationName, headers)) {
      const rawChecksum = await stringHasher(checksumAlgorithmFn, requestBody);
      updatedHeaders = {
        ...headers,
        [checksumLocationName]: base64Encoder(rawChecksum)
      };
    }
  }
  const result = await next({
    ...args,
    request: {
      ...request2,
      headers: updatedHeaders,
      body: updatedBody
    }
  });
  const { requestValidationModeMember, responseAlgorithms } = middlewareConfig;
  if (requestValidationModeMember && input[requestValidationModeMember] === "ENABLED") {
    validateChecksumFromResponse(result.response, {
      config,
      responseAlgorithms
    });
  }
  return result;
};

// ../../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getFlexibleChecksumsPlugin.js
var flexibleChecksumsMiddlewareOptions = {
  name: "flexibleChecksumsMiddleware",
  step: "build",
  tags: ["BODY_CHECKSUM"],
  override: true
};
var getFlexibleChecksumsPlugin = (config, middlewareConfig) => ({
  applyToStack: (clientStack) => {
    clientStack.add(flexibleChecksumsMiddleware(config, middlewareConfig), flexibleChecksumsMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectCommand.js
var GetObjectCommand = class extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      Bucket: { type: "contextParams", name: "Bucket" },
      ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
      UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
      DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
      Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, GetObjectCommand.getEndpointParameterInstructions()));
    this.middlewareStack.use(getSsecPlugin(configuration));
    this.middlewareStack.use(getFlexibleChecksumsPlugin(configuration, {
      input: this.input,
      requestChecksumRequired: false,
      requestValidationModeMember: "ChecksumMode",
      responseAlgorithms: ["CRC32", "CRC32C", "SHA256", "SHA1"]
    }));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "S3Client";
    const commandName = "GetObjectCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: GetObjectRequestFilterSensitiveLog,
      outputFilterSensitiveLog: GetObjectOutputFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_restXmlGetObjectCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_restXmlGetObjectCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/commands/HeadObjectCommand.js
var HeadObjectCommand = class extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      Bucket: { type: "contextParams", name: "Bucket" },
      ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
      UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
      DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
      Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, HeadObjectCommand.getEndpointParameterInstructions()));
    this.middlewareStack.use(getSsecPlugin(configuration));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "S3Client";
    const commandName = "HeadObjectCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: HeadObjectRequestFilterSensitiveLog,
      outputFilterSensitiveLog: HeadObjectOutputFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_restXmlHeadObjectCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_restXmlHeadObjectCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/commands/ListObjectsV2Command.js
var ListObjectsV2Command = class extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      Bucket: { type: "contextParams", name: "Bucket" },
      ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
      UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
      DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
      Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, ListObjectsV2Command.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "S3Client";
    const commandName = "ListObjectsV2Command";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: ListObjectsV2RequestFilterSensitiveLog,
      outputFilterSensitiveLog: ListObjectsV2OutputFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_restXmlListObjectsV2Command(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_restXmlListObjectsV2Command(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectCommand.js
var PutObjectCommand = class extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      Bucket: { type: "contextParams", name: "Bucket" },
      ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
      UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
      DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
      Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, PutObjectCommand.getEndpointParameterInstructions()));
    this.middlewareStack.use(getCheckContentLengthHeaderPlugin(configuration));
    this.middlewareStack.use(getSsecPlugin(configuration));
    this.middlewareStack.use(getFlexibleChecksumsPlugin(configuration, {
      input: this.input,
      requestAlgorithmMember: "ChecksumAlgorithm",
      requestChecksumRequired: false
    }));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "S3Client";
    const commandName = "PutObjectCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: PutObjectRequestFilterSensitiveLog,
      outputFilterSensitiveLog: PutObjectOutputFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_restXmlPutObjectCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_restXmlPutObjectCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/util-config-provider/dist-es/booleanSelector.js
var SelectorType;
(function(SelectorType2) {
  SelectorType2["ENV"] = "env";
  SelectorType2["CONFIG"] = "shared config entry";
})(SelectorType || (SelectorType = {}));
var booleanSelector = (obj, key, type) => {
  if (!(key in obj))
    return void 0;
  if (obj[key] === "true")
    return true;
  if (obj[key] === "false")
    return false;
  throw new Error(`Cannot load ${type} "${key}". Expected "true" or "false", got ${obj[key]}.`);
};

// ../../node_modules/@aws-sdk/config-resolver/dist-es/endpointsConfig/NodeUseDualstackEndpointConfigOptions.js
var ENV_USE_DUALSTACK_ENDPOINT = "AWS_USE_DUALSTACK_ENDPOINT";
var CONFIG_USE_DUALSTACK_ENDPOINT = "use_dualstack_endpoint";
var NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
  environmentVariableSelector: (env3) => booleanSelector(env3, ENV_USE_DUALSTACK_ENDPOINT, SelectorType.ENV),
  configFileSelector: (profile) => booleanSelector(profile, CONFIG_USE_DUALSTACK_ENDPOINT, SelectorType.CONFIG),
  default: false
};

// ../../node_modules/@aws-sdk/config-resolver/dist-es/endpointsConfig/NodeUseFipsEndpointConfigOptions.js
var ENV_USE_FIPS_ENDPOINT = "AWS_USE_FIPS_ENDPOINT";
var CONFIG_USE_FIPS_ENDPOINT = "use_fips_endpoint";
var NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
  environmentVariableSelector: (env3) => booleanSelector(env3, ENV_USE_FIPS_ENDPOINT, SelectorType.ENV),
  configFileSelector: (profile) => booleanSelector(profile, CONFIG_USE_FIPS_ENDPOINT, SelectorType.CONFIG),
  default: false
};

// ../../node_modules/@aws-sdk/config-resolver/dist-es/regionConfig/config.js
var REGION_ENV_NAME = "AWS_REGION";
var REGION_INI_NAME = "region";
var NODE_REGION_CONFIG_OPTIONS = {
  environmentVariableSelector: (env3) => env3[REGION_ENV_NAME],
  configFileSelector: (profile) => profile[REGION_INI_NAME],
  default: () => {
    throw new Error("Region is missing");
  }
};
var NODE_REGION_CONFIG_FILE_OPTIONS = {
  preferredFile: "credentials"
};

// ../../node_modules/@aws-sdk/config-resolver/dist-es/regionConfig/isFipsRegion.js
var isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));

// ../../node_modules/@aws-sdk/config-resolver/dist-es/regionConfig/getRealRegion.js
var getRealRegion = (region) => isFipsRegion(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region;

// ../../node_modules/@aws-sdk/config-resolver/dist-es/regionConfig/resolveRegionConfig.js
var resolveRegionConfig = (input) => {
  const { region, useFipsEndpoint } = input;
  if (!region) {
    throw new Error("Region is missing");
  }
  return {
    ...input,
    region: async () => {
      if (typeof region === "string") {
        return getRealRegion(region);
      }
      const providedRegion = await region();
      return getRealRegion(providedRegion);
    },
    useFipsEndpoint: async () => {
      const providedRegion = typeof region === "string" ? region : await region();
      if (isFipsRegion(providedRegion)) {
        return true;
      }
      return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
    }
  };
};

// ../../node_modules/@aws-sdk/eventstream-serde-config-resolver/dist-es/EventStreamSerdeConfig.js
var resolveEventStreamSerdeConfig = (input) => ({
  ...input,
  eventStreamMarshaller: input.eventStreamSerdeProvider(input)
});

// ../../node_modules/@aws-sdk/middleware-content-length/dist-es/index.js
var CONTENT_LENGTH_HEADER2 = "content-length";
function contentLengthMiddleware(bodyLengthChecker) {
  return (next) => async (args) => {
    const request2 = args.request;
    if (HttpRequest.isInstance(request2)) {
      const { body, headers } = request2;
      if (body && Object.keys(headers).map((str) => str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER2) === -1) {
        try {
          const length = bodyLengthChecker(body);
          request2.headers = {
            ...request2.headers,
            [CONTENT_LENGTH_HEADER2]: String(length)
          };
        } catch (error) {
        }
      }
    }
    return next({
      ...args,
      request: request2
    });
  };
}
var contentLengthMiddlewareOptions = {
  step: "build",
  tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
  name: "contentLengthMiddleware",
  override: true
};
var getContentLengthPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/middleware-expect-continue/dist-es/index.js
function addExpectContinueMiddleware(options) {
  return (next) => async (args) => {
    const { request: request2 } = args;
    if (HttpRequest.isInstance(request2) && request2.body && options.runtime === "node") {
      request2.headers = {
        ...request2.headers,
        Expect: "100-continue"
      };
    }
    return next({
      ...args,
      request: request2
    });
  };
}
var addExpectContinueMiddlewareOptions = {
  step: "build",
  tags: ["SET_EXPECT_HEADER", "EXPECT_HEADER"],
  name: "addExpectContinueMiddleware",
  override: true
};
var getAddExpectContinuePlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(addExpectContinueMiddleware(options), addExpectContinueMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/middleware-host-header/dist-es/index.js
function resolveHostHeaderConfig(input) {
  return input;
}
var hostHeaderMiddleware = (options) => (next) => async (args) => {
  if (!HttpRequest.isInstance(args.request))
    return next(args);
  const { request: request2 } = args;
  const { handlerProtocol = "" } = options.requestHandler.metadata || {};
  if (handlerProtocol.indexOf("h2") >= 0 && !request2.headers[":authority"]) {
    delete request2.headers["host"];
    request2.headers[":authority"] = "";
  } else if (!request2.headers["host"]) {
    request2.headers["host"] = request2.hostname;
  }
  return next(args);
};
var hostHeaderMiddlewareOptions = {
  name: "hostHeaderMiddleware",
  step: "build",
  priority: "low",
  tags: ["HOST"],
  override: true
};
var getHostHeaderPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/middleware-logger/dist-es/loggerMiddleware.js
var loggerMiddleware = () => (next, context) => async (args) => {
  const response = await next(args);
  const { clientName, commandName, logger: logger3, inputFilterSensitiveLog, outputFilterSensitiveLog, dynamoDbDocumentClientOptions = {} } = context;
  const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
  if (!logger3) {
    return response;
  }
  if (typeof logger3.info === "function") {
    const { $metadata, ...outputWithoutMetadata } = response.output;
    logger3.info({
      clientName,
      commandName,
      input: (overrideInputFilterSensitiveLog ?? inputFilterSensitiveLog)(args.input),
      output: (overrideOutputFilterSensitiveLog ?? outputFilterSensitiveLog)(outputWithoutMetadata),
      metadata: $metadata
    });
  }
  return response;
};
var loggerMiddlewareOptions = {
  name: "loggerMiddleware",
  tags: ["LOGGER"],
  step: "initialize",
  override: true
};
var getLoggerPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js
var TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
var ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
var ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
var recursionDetectionMiddleware = (options) => (next) => async (args) => {
  const { request: request2 } = args;
  if (!HttpRequest.isInstance(request2) || options.runtime !== "node" || request2.headers.hasOwnProperty(TRACE_ID_HEADER_NAME)) {
    return next(args);
  }
  const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
  const traceId = process.env[ENV_TRACE_ID];
  const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
  if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
    request2.headers[TRACE_ID_HEADER_NAME] = traceId;
  }
  return next({
    ...args,
    request: request2
  });
};
var addRecursionDetectionMiddlewareOptions = {
  step: "build",
  tags: ["RECURSION_DETECTION"],
  name: "recursionDetectionMiddleware",
  override: true,
  priority: "low"
};
var getRecursionDetectionPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(recursionDetectionMiddleware(options), addRecursionDetectionMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/util-retry/dist-es/config.js
var RETRY_MODES;
(function(RETRY_MODES2) {
  RETRY_MODES2["STANDARD"] = "standard";
  RETRY_MODES2["ADAPTIVE"] = "adaptive";
})(RETRY_MODES || (RETRY_MODES = {}));
var DEFAULT_MAX_ATTEMPTS = 3;
var DEFAULT_RETRY_MODE = "STANDARD";

// ../../node_modules/@aws-sdk/service-error-classification/dist-es/constants.js
var THROTTLING_ERROR_CODES = [
  "BandwidthLimitExceeded",
  "EC2ThrottledException",
  "LimitExceededException",
  "PriorRequestNotComplete",
  "ProvisionedThroughputExceededException",
  "RequestLimitExceeded",
  "RequestThrottled",
  "RequestThrottledException",
  "SlowDown",
  "ThrottledException",
  "Throttling",
  "ThrottlingException",
  "TooManyRequestsException",
  "TransactionInProgressException"
];
var TRANSIENT_ERROR_CODES = ["AbortError", "TimeoutError", "RequestTimeout", "RequestTimeoutException"];
var TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
var NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];

// ../../node_modules/@aws-sdk/service-error-classification/dist-es/index.js
var isThrottlingError = (error) => error.$metadata?.httpStatusCode === 429 || THROTTLING_ERROR_CODES.includes(error.name) || error.$retryable?.throttling == true;
var isTransientError = (error) => TRANSIENT_ERROR_CODES.includes(error.name) || NODEJS_TIMEOUT_ERROR_CODES.includes(error?.code || "") || TRANSIENT_ERROR_STATUS_CODES.includes(error.$metadata?.httpStatusCode || 0);
var isServerError = (error) => {
  if (error.$metadata?.httpStatusCode !== void 0) {
    const statusCode = error.$metadata.httpStatusCode;
    if (500 <= statusCode && statusCode <= 599 && !isTransientError(error)) {
      return true;
    }
    return false;
  }
  return false;
};

// ../../node_modules/@aws-sdk/util-retry/dist-es/DefaultRateLimiter.js
var DefaultRateLimiter = class {
  constructor(options) {
    this.currentCapacity = 0;
    this.enabled = false;
    this.lastMaxRate = 0;
    this.measuredTxRate = 0;
    this.requestCount = 0;
    this.lastTimestamp = 0;
    this.timeWindow = 0;
    this.beta = options?.beta ?? 0.7;
    this.minCapacity = options?.minCapacity ?? 1;
    this.minFillRate = options?.minFillRate ?? 0.5;
    this.scaleConstant = options?.scaleConstant ?? 0.4;
    this.smooth = options?.smooth ?? 0.8;
    const currentTimeInSeconds = this.getCurrentTimeInSeconds();
    this.lastThrottleTime = currentTimeInSeconds;
    this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
    this.fillRate = this.minFillRate;
    this.maxCapacity = this.minCapacity;
  }
  getCurrentTimeInSeconds() {
    return Date.now() / 1e3;
  }
  async getSendToken() {
    return this.acquireTokenBucket(1);
  }
  async acquireTokenBucket(amount) {
    if (!this.enabled) {
      return;
    }
    this.refillTokenBucket();
    if (amount > this.currentCapacity) {
      const delay = (amount - this.currentCapacity) / this.fillRate * 1e3;
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
    this.currentCapacity = this.currentCapacity - amount;
  }
  refillTokenBucket() {
    const timestamp = this.getCurrentTimeInSeconds();
    if (!this.lastTimestamp) {
      this.lastTimestamp = timestamp;
      return;
    }
    const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
    this.lastTimestamp = timestamp;
  }
  updateClientSendingRate(response) {
    let calculatedRate;
    this.updateMeasuredRate();
    if (isThrottlingError(response)) {
      const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
      this.lastMaxRate = rateToUse;
      this.calculateTimeWindow();
      this.lastThrottleTime = this.getCurrentTimeInSeconds();
      calculatedRate = this.cubicThrottle(rateToUse);
      this.enableTokenBucket();
    } else {
      this.calculateTimeWindow();
      calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
    }
    const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
    this.updateTokenBucketRate(newRate);
  }
  calculateTimeWindow() {
    this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
  }
  cubicThrottle(rateToUse) {
    return this.getPrecise(rateToUse * this.beta);
  }
  cubicSuccess(timestamp) {
    return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
  }
  enableTokenBucket() {
    this.enabled = true;
  }
  updateTokenBucketRate(newRate) {
    this.refillTokenBucket();
    this.fillRate = Math.max(newRate, this.minFillRate);
    this.maxCapacity = Math.max(newRate, this.minCapacity);
    this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
  }
  updateMeasuredRate() {
    const t6 = this.getCurrentTimeInSeconds();
    const timeBucket = Math.floor(t6 * 2) / 2;
    this.requestCount++;
    if (timeBucket > this.lastTxRateBucket) {
      const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
      this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
      this.requestCount = 0;
      this.lastTxRateBucket = timeBucket;
    }
  }
  getPrecise(num) {
    return parseFloat(num.toFixed(8));
  }
};

// ../../node_modules/@aws-sdk/util-retry/dist-es/constants.js
var DEFAULT_RETRY_DELAY_BASE = 100;
var MAXIMUM_RETRY_DELAY = 20 * 1e3;
var THROTTLING_RETRY_DELAY_BASE = 500;
var INITIAL_RETRY_TOKENS = 500;
var RETRY_COST = 5;
var TIMEOUT_RETRY_COST = 10;
var NO_RETRY_INCREMENT = 1;
var INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
var REQUEST_HEADER = "amz-sdk-request";

// ../../node_modules/@aws-sdk/util-retry/dist-es/defaultRetryBackoffStrategy.js
var getDefaultRetryBackoffStrategy = () => {
  let delayBase = DEFAULT_RETRY_DELAY_BASE;
  const computeNextBackoffDelay = (attempts) => {
    return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
  };
  const setDelayBase = (delay) => {
    delayBase = delay;
  };
  return {
    computeNextBackoffDelay,
    setDelayBase
  };
};

// ../../node_modules/@aws-sdk/util-retry/dist-es/defaultRetryToken.js
var getDefaultRetryToken = (initialRetryTokens, initialRetryDelay, initialRetryCount, options) => {
  const MAX_CAPACITY = initialRetryTokens;
  const retryCost = options?.retryCost ?? RETRY_COST;
  const timeoutRetryCost = options?.timeoutRetryCost ?? TIMEOUT_RETRY_COST;
  const retryBackoffStrategy = options?.retryBackoffStrategy ?? getDefaultRetryBackoffStrategy();
  let availableCapacity = initialRetryTokens;
  let retryDelay = Math.min(MAXIMUM_RETRY_DELAY, initialRetryDelay);
  let lastRetryCost = void 0;
  let retryCount = initialRetryCount ?? 0;
  const getCapacityAmount = (errorType) => errorType === "TRANSIENT" ? timeoutRetryCost : retryCost;
  const getRetryCount = () => retryCount;
  const getRetryDelay = () => retryDelay;
  const getLastRetryCost = () => lastRetryCost;
  const hasRetryTokens = (errorType) => getCapacityAmount(errorType) <= availableCapacity;
  const getRetryTokenCount = (errorInfo) => {
    const errorType = errorInfo.errorType;
    if (!hasRetryTokens(errorType)) {
      throw new Error("No retry token available");
    }
    const capacityAmount = getCapacityAmount(errorType);
    const delayBase = errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE;
    retryBackoffStrategy.setDelayBase(delayBase);
    const delayFromErrorType = retryBackoffStrategy.computeNextBackoffDelay(retryCount);
    if (errorInfo.retryAfterHint) {
      const delayFromRetryAfterHint = errorInfo.retryAfterHint.getTime() - Date.now();
      retryDelay = Math.max(delayFromRetryAfterHint || 0, delayFromErrorType);
    } else {
      retryDelay = delayFromErrorType;
    }
    retryCount++;
    lastRetryCost = capacityAmount;
    availableCapacity -= capacityAmount;
    return capacityAmount;
  };
  const releaseRetryTokens = (releaseAmount) => {
    availableCapacity += releaseAmount ?? NO_RETRY_INCREMENT;
    availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);
  };
  return {
    getRetryCount,
    getRetryDelay,
    getLastRetryCost,
    hasRetryTokens,
    getRetryTokenCount,
    releaseRetryTokens
  };
};

// ../../node_modules/@aws-sdk/util-retry/dist-es/StandardRetryStrategy.js
var StandardRetryStrategy = class {
  constructor(maxAttemptsProvider) {
    this.maxAttemptsProvider = maxAttemptsProvider;
    this.mode = RETRY_MODES.STANDARD;
    this.retryToken = getDefaultRetryToken(INITIAL_RETRY_TOKENS, DEFAULT_RETRY_DELAY_BASE);
    this.maxAttemptsProvider = maxAttemptsProvider;
  }
  async acquireInitialRetryToken(retryTokenScope) {
    return this.retryToken;
  }
  async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
    const maxAttempts = await this.getMaxAttempts();
    if (this.shouldRetry(tokenToRenew, errorInfo, maxAttempts)) {
      tokenToRenew.getRetryTokenCount(errorInfo);
      return tokenToRenew;
    }
    throw new Error("No retry token available");
  }
  recordSuccess(token) {
    this.retryToken.releaseRetryTokens(token.getLastRetryCost());
  }
  async getMaxAttempts() {
    let maxAttempts;
    try {
      return await this.maxAttemptsProvider();
    } catch (error) {
      console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);
      return DEFAULT_MAX_ATTEMPTS;
    }
  }
  shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
    const attempts = tokenToRenew.getRetryCount();
    return attempts < maxAttempts && tokenToRenew.hasRetryTokens(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);
  }
  isRetryableError(errorType) {
    return errorType === "THROTTLING" || errorType === "TRANSIENT";
  }
};

// ../../node_modules/@aws-sdk/util-retry/dist-es/AdaptiveRetryStrategy.js
var AdaptiveRetryStrategy = class {
  constructor(maxAttemptsProvider, options) {
    this.maxAttemptsProvider = maxAttemptsProvider;
    this.mode = RETRY_MODES.ADAPTIVE;
    const { rateLimiter } = options ?? {};
    this.rateLimiter = rateLimiter ?? new DefaultRateLimiter();
    this.standardRetryStrategy = new StandardRetryStrategy(maxAttemptsProvider);
  }
  async acquireInitialRetryToken(retryTokenScope) {
    await this.rateLimiter.getSendToken();
    return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
  }
  async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
    this.rateLimiter.updateClientSendingRate(errorInfo);
    return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
  }
  recordSuccess(token) {
    this.rateLimiter.updateClientSendingRate({});
    this.standardRetryStrategy.recordSuccess(token);
  }
};

// ../../node_modules/uuid/dist/esm-node/rng.js
var import_crypto = __toESM(require("crypto"));
var rnds8Pool = new Uint8Array(256);
var poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    import_crypto.default.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

// ../../node_modules/uuid/dist/esm-node/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// ../../node_modules/uuid/dist/esm-node/validate.js
function validate2(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate2;

// ../../node_modules/uuid/dist/esm-node/stringify.js
var byteToHex = [];
for (let i10 = 0; i10 < 256; ++i10) {
  byteToHex.push((i10 + 256).toString(16).substr(1));
}
function stringify(arr, offset = 0) {
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var stringify_default = stringify;

// ../../node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i10 = 0; i10 < 16; ++i10) {
      buf[offset + i10] = rnds[i10];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default = v4;

// ../../node_modules/@aws-sdk/middleware-retry/dist-es/util.js
var asSdkError = (error) => {
  if (error instanceof Error)
    return error;
  if (error instanceof Object)
    return Object.assign(new Error(), error);
  if (typeof error === "string")
    return new Error(error);
  return new Error(`AWS SDK error wrapper for ${error}`);
};

// ../../node_modules/@aws-sdk/middleware-retry/dist-es/configurations.js
var ENV_MAX_ATTEMPTS = "AWS_MAX_ATTEMPTS";
var CONFIG_MAX_ATTEMPTS = "max_attempts";
var NODE_MAX_ATTEMPT_CONFIG_OPTIONS = {
  environmentVariableSelector: (env3) => {
    const value = env3[ENV_MAX_ATTEMPTS];
    if (!value)
      return void 0;
    const maxAttempt = parseInt(value);
    if (Number.isNaN(maxAttempt)) {
      throw new Error(`Environment variable ${ENV_MAX_ATTEMPTS} mast be a number, got "${value}"`);
    }
    return maxAttempt;
  },
  configFileSelector: (profile) => {
    const value = profile[CONFIG_MAX_ATTEMPTS];
    if (!value)
      return void 0;
    const maxAttempt = parseInt(value);
    if (Number.isNaN(maxAttempt)) {
      throw new Error(`Shared config file entry ${CONFIG_MAX_ATTEMPTS} mast be a number, got "${value}"`);
    }
    return maxAttempt;
  },
  default: DEFAULT_MAX_ATTEMPTS
};
var resolveRetryConfig = (input) => {
  const { retryStrategy } = input;
  const maxAttempts = normalizeProvider(input.maxAttempts ?? DEFAULT_MAX_ATTEMPTS);
  return {
    ...input,
    maxAttempts,
    retryStrategy: async () => {
      if (retryStrategy) {
        return retryStrategy;
      }
      const retryMode = await normalizeProvider(input.retryMode)();
      if (retryMode === RETRY_MODES.ADAPTIVE) {
        return new AdaptiveRetryStrategy(maxAttempts);
      }
      return new StandardRetryStrategy(maxAttempts);
    }
  };
};
var ENV_RETRY_MODE = "AWS_RETRY_MODE";
var CONFIG_RETRY_MODE = "retry_mode";
var NODE_RETRY_MODE_CONFIG_OPTIONS = {
  environmentVariableSelector: (env3) => env3[ENV_RETRY_MODE],
  configFileSelector: (profile) => profile[CONFIG_RETRY_MODE],
  default: DEFAULT_RETRY_MODE
};

// ../../node_modules/@aws-sdk/middleware-retry/dist-es/retryMiddleware.js
var retryMiddleware = (options) => (next, context) => async (args) => {
  let retryStrategy = await options.retryStrategy();
  const maxAttempts = await options.maxAttempts();
  if (isRetryStrategyV2(retryStrategy)) {
    retryStrategy = retryStrategy;
    let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
    let lastError = new Error();
    let attempts = 0;
    let totalRetryDelay = 0;
    const { request: request2 } = args;
    if (HttpRequest.isInstance(request2)) {
      request2.headers[INVOCATION_ID_HEADER] = v4_default();
    }
    while (true) {
      try {
        if (HttpRequest.isInstance(request2)) {
          request2.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
        }
        const { response, output } = await next(args);
        retryStrategy.recordSuccess(retryToken);
        output.$metadata.attempts = attempts + 1;
        output.$metadata.totalRetryDelay = totalRetryDelay;
        return { response, output };
      } catch (e10) {
        const retryErrorInfo = getRetyErrorInto(e10);
        lastError = asSdkError(e10);
        try {
          retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
        } catch (refreshError) {
          if (!lastError.$metadata) {
            lastError.$metadata = {};
          }
          lastError.$metadata.attempts = attempts + 1;
          lastError.$metadata.totalRetryDelay = totalRetryDelay;
          throw lastError;
        }
        attempts = retryToken.getRetryCount();
        const delay = retryToken.getRetryDelay();
        totalRetryDelay += delay;
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
  } else {
    retryStrategy = retryStrategy;
    if (retryStrategy?.mode)
      context.userAgent = [...context.userAgent || [], ["cfg/retry-mode", retryStrategy.mode]];
    return retryStrategy.retry(next, args);
  }
};
var isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined";
var getRetyErrorInto = (error) => {
  const errorInfo = {
    errorType: getRetryErrorType(error)
  };
  const retryAfterHint = getRetryAfterHint(error.$response);
  if (retryAfterHint) {
    errorInfo.retryAfterHint = retryAfterHint;
  }
  return errorInfo;
};
var getRetryErrorType = (error) => {
  if (isThrottlingError(error))
    return "THROTTLING";
  if (isTransientError(error))
    return "TRANSIENT";
  if (isServerError(error))
    return "SERVER_ERROR";
  return "CLIENT_ERROR";
};
var retryMiddlewareOptions = {
  name: "retryMiddleware",
  tags: ["RETRY"],
  step: "finalizeRequest",
  priority: "high",
  override: true
};
var getRetryPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
  }
});
var getRetryAfterHint = (response) => {
  if (!HttpResponse.isInstance(response))
    return;
  const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
  if (!retryAfterHeaderName)
    return;
  const retryAfter = response.headers[retryAfterHeaderName];
  const retryAfterSeconds = Number(retryAfter);
  if (!Number.isNaN(retryAfterSeconds))
    return new Date(retryAfterSeconds * 1e3);
  const retryAfterDate = new Date(retryAfter);
  return retryAfterDate;
};

// ../../node_modules/@aws-sdk/property-provider/dist-es/ProviderError.js
var ProviderError = class extends Error {
  constructor(message, tryNextLink = true) {
    super(message);
    this.tryNextLink = tryNextLink;
    this.name = "ProviderError";
    Object.setPrototypeOf(this, ProviderError.prototype);
  }
  static from(error, tryNextLink = true) {
    return Object.assign(new this(error.message, tryNextLink), error);
  }
};

// ../../node_modules/@aws-sdk/property-provider/dist-es/CredentialsProviderError.js
var CredentialsProviderError = class extends ProviderError {
  constructor(message, tryNextLink = true) {
    super(message, tryNextLink);
    this.tryNextLink = tryNextLink;
    this.name = "CredentialsProviderError";
    Object.setPrototypeOf(this, CredentialsProviderError.prototype);
  }
};

// ../../node_modules/@aws-sdk/property-provider/dist-es/TokenProviderError.js
var TokenProviderError = class extends ProviderError {
  constructor(message, tryNextLink = true) {
    super(message, tryNextLink);
    this.tryNextLink = tryNextLink;
    this.name = "TokenProviderError";
    Object.setPrototypeOf(this, TokenProviderError.prototype);
  }
};

// ../../node_modules/@aws-sdk/property-provider/dist-es/chain.js
function chain(...providers) {
  return () => {
    let promise = Promise.reject(new ProviderError("No providers in chain"));
    for (const provider of providers) {
      promise = promise.catch((err) => {
        if (err?.tryNextLink) {
          return provider();
        }
        throw err;
      });
    }
    return promise;
  };
}

// ../../node_modules/@aws-sdk/property-provider/dist-es/fromStatic.js
var fromStatic = (staticValue) => () => Promise.resolve(staticValue);

// ../../node_modules/@aws-sdk/property-provider/dist-es/memoize.js
var memoize = (provider, isExpired, requiresRefresh) => {
  let resolved;
  let pending;
  let hasResult;
  let isConstant = false;
  const coalesceProvider = async () => {
    if (!pending) {
      pending = provider();
    }
    try {
      resolved = await pending;
      hasResult = true;
      isConstant = false;
    } finally {
      pending = void 0;
    }
    return resolved;
  };
  if (isExpired === void 0) {
    return async (options) => {
      if (!hasResult || options?.forceRefresh) {
        resolved = await coalesceProvider();
      }
      return resolved;
    };
  }
  return async (options) => {
    if (!hasResult || options?.forceRefresh) {
      resolved = await coalesceProvider();
    }
    if (isConstant) {
      return resolved;
    }
    if (requiresRefresh && !requiresRefresh(resolved)) {
      isConstant = true;
      return resolved;
    }
    if (isExpired(resolved)) {
      await coalesceProvider();
      return resolved;
    }
    return resolved;
  };
};

// ../../node_modules/@aws-sdk/util-hex-encoding/dist-es/index.js
var SHORT_TO_HEX = {};
var HEX_TO_SHORT = {};
for (let i10 = 0; i10 < 256; i10++) {
  let encodedByte = i10.toString(16).toLowerCase();
  if (encodedByte.length === 1) {
    encodedByte = `0${encodedByte}`;
  }
  SHORT_TO_HEX[i10] = encodedByte;
  HEX_TO_SHORT[encodedByte] = i10;
}
function fromHex(encoded) {
  if (encoded.length % 2 !== 0) {
    throw new Error("Hex encoded strings must have an even number length");
  }
  const out = new Uint8Array(encoded.length / 2);
  for (let i10 = 0; i10 < encoded.length; i10 += 2) {
    const encodedByte = encoded.slice(i10, i10 + 2).toLowerCase();
    if (encodedByte in HEX_TO_SHORT) {
      out[i10 / 2] = HEX_TO_SHORT[encodedByte];
    } else {
      throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
    }
  }
  return out;
}
function toHex(bytes) {
  let out = "";
  for (let i10 = 0; i10 < bytes.byteLength; i10++) {
    out += SHORT_TO_HEX[bytes[i10]];
  }
  return out;
}

// ../../node_modules/@aws-sdk/signature-v4/dist-es/constants.js
var ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
var CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
var AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
var SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
var EXPIRES_QUERY_PARAM = "X-Amz-Expires";
var SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
var TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
var AUTH_HEADER = "authorization";
var AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
var DATE_HEADER = "date";
var GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
var SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
var SHA256_HEADER = "x-amz-content-sha256";
var TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
var ALWAYS_UNSIGNABLE_HEADERS = {
  authorization: true,
  "cache-control": true,
  connection: true,
  expect: true,
  from: true,
  "keep-alive": true,
  "max-forwards": true,
  pragma: true,
  referer: true,
  te: true,
  trailer: true,
  "transfer-encoding": true,
  upgrade: true,
  "user-agent": true,
  "x-amzn-trace-id": true
};
var PROXY_HEADER_PATTERN = /^proxy-/;
var SEC_HEADER_PATTERN = /^sec-/;
var ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
var EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
var UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
var MAX_CACHE_SIZE = 50;
var KEY_TYPE_IDENTIFIER = "aws4_request";
var MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;

// ../../node_modules/@aws-sdk/signature-v4/dist-es/credentialDerivation.js
var signingKeyCache = {};
var cacheQueue = [];
var createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`;
var getSigningKey = async (sha256Constructor, credentials2, shortDate, region, service) => {
  const credsHash = await hmac2(sha256Constructor, credentials2.secretAccessKey, credentials2.accessKeyId);
  const cacheKey = `${shortDate}:${region}:${service}:${toHex(credsHash)}:${credentials2.sessionToken}`;
  if (cacheKey in signingKeyCache) {
    return signingKeyCache[cacheKey];
  }
  cacheQueue.push(cacheKey);
  while (cacheQueue.length > MAX_CACHE_SIZE) {
    delete signingKeyCache[cacheQueue.shift()];
  }
  let key = `AWS4${credentials2.secretAccessKey}`;
  for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {
    key = await hmac2(sha256Constructor, key, signable);
  }
  return signingKeyCache[cacheKey] = key;
};
var hmac2 = (ctor, secret, data) => {
  const hash2 = new ctor(secret);
  hash2.update(toUint8Array(data));
  return hash2.digest();
};

// ../../node_modules/@aws-sdk/signature-v4/dist-es/getCanonicalHeaders.js
var getCanonicalHeaders = ({ headers }, unsignableHeaders, signableHeaders) => {
  const canonical = {};
  for (const headerName of Object.keys(headers).sort()) {
    if (headers[headerName] == void 0) {
      continue;
    }
    const canonicalHeaderName = headerName.toLowerCase();
    if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || unsignableHeaders?.has(canonicalHeaderName) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
      if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
        continue;
      }
    }
    canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
  }
  return canonical;
};

// ../../node_modules/@aws-sdk/util-uri-escape/dist-es/escape-uri.js
var escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
var hexEncode = (c10) => `%${c10.charCodeAt(0).toString(16).toUpperCase()}`;

// ../../node_modules/@aws-sdk/signature-v4/dist-es/getCanonicalQuery.js
var getCanonicalQuery = ({ query = {} }) => {
  const keys = [];
  const serialized = {};
  for (const key of Object.keys(query).sort()) {
    if (key.toLowerCase() === SIGNATURE_HEADER) {
      continue;
    }
    keys.push(key);
    const value = query[key];
    if (typeof value === "string") {
      serialized[key] = `${escapeUri(key)}=${escapeUri(value)}`;
    } else if (Array.isArray(value)) {
      serialized[key] = value.slice(0).sort().reduce((encoded, value2) => encoded.concat([`${escapeUri(key)}=${escapeUri(value2)}`]), []).join("&");
    }
  }
  return keys.map((key) => serialized[key]).filter((serialized2) => serialized2).join("&");
};

// ../../node_modules/@aws-sdk/signature-v4/dist-es/getPayloadHash.js
var getPayloadHash = async ({ headers, body }, hashConstructor) => {
  for (const headerName of Object.keys(headers)) {
    if (headerName.toLowerCase() === SHA256_HEADER) {
      return headers[headerName];
    }
  }
  if (body == void 0) {
    return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
  } else if (typeof body === "string" || ArrayBuffer.isView(body) || isArrayBuffer(body)) {
    const hashCtor = new hashConstructor();
    hashCtor.update(toUint8Array(body));
    return toHex(await hashCtor.digest());
  }
  return UNSIGNED_PAYLOAD;
};

// ../../node_modules/@aws-sdk/signature-v4/dist-es/headerUtil.js
var hasHeader2 = (soughtHeader, headers) => {
  soughtHeader = soughtHeader.toLowerCase();
  for (const headerName of Object.keys(headers)) {
    if (soughtHeader === headerName.toLowerCase()) {
      return true;
    }
  }
  return false;
};

// ../../node_modules/@aws-sdk/signature-v4/dist-es/cloneRequest.js
var cloneRequest = ({ headers, query, ...rest }) => ({
  ...rest,
  headers: { ...headers },
  query: query ? cloneQuery2(query) : void 0
});
var cloneQuery2 = (query) => Object.keys(query).reduce((carry, paramName) => {
  const param = query[paramName];
  return {
    ...carry,
    [paramName]: Array.isArray(param) ? [...param] : param
  };
}, {});

// ../../node_modules/@aws-sdk/signature-v4/dist-es/moveHeadersToQuery.js
var moveHeadersToQuery = (request2, options = {}) => {
  const { headers, query = {} } = typeof request2.clone === "function" ? request2.clone() : cloneRequest(request2);
  for (const name of Object.keys(headers)) {
    const lname = name.toLowerCase();
    if (lname.slice(0, 6) === "x-amz-" && !options.unhoistableHeaders?.has(lname)) {
      query[name] = headers[name];
      delete headers[name];
    }
  }
  return {
    ...request2,
    headers,
    query
  };
};

// ../../node_modules/@aws-sdk/signature-v4/dist-es/prepareRequest.js
var prepareRequest = (request2) => {
  request2 = typeof request2.clone === "function" ? request2.clone() : cloneRequest(request2);
  for (const headerName of Object.keys(request2.headers)) {
    if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
      delete request2.headers[headerName];
    }
  }
  return request2;
};

// ../../node_modules/@aws-sdk/signature-v4/dist-es/utilDate.js
var iso8601 = (time) => toDate(time).toISOString().replace(/\.\d{3}Z$/, "Z");
var toDate = (time) => {
  if (typeof time === "number") {
    return new Date(time * 1e3);
  }
  if (typeof time === "string") {
    if (Number(time)) {
      return new Date(Number(time) * 1e3);
    }
    return new Date(time);
  }
  return time;
};

// ../../node_modules/@aws-sdk/signature-v4/dist-es/SignatureV4.js
var SignatureV4 = class {
  constructor({ applyChecksum, credentials: credentials2, region, service, sha256, uriEscapePath = true }) {
    this.service = service;
    this.sha256 = sha256;
    this.uriEscapePath = uriEscapePath;
    this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
    this.regionProvider = normalizeProvider(region);
    this.credentialProvider = normalizeProvider(credentials2);
  }
  async presign(originalRequest, options = {}) {
    const { signingDate = /* @__PURE__ */ new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService } = options;
    const credentials2 = await this.credentialProvider();
    this.validateResolvedCredentials(credentials2);
    const region = signingRegion ?? await this.regionProvider();
    const { longDate, shortDate } = formatDate(signingDate);
    if (expiresIn > MAX_PRESIGNED_TTL) {
      return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
    }
    const scope = createScope(shortDate, region, signingService ?? this.service);
    const request2 = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders });
    if (credentials2.sessionToken) {
      request2.query[TOKEN_QUERY_PARAM] = credentials2.sessionToken;
    }
    request2.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
    request2.query[CREDENTIAL_QUERY_PARAM] = `${credentials2.accessKeyId}/${scope}`;
    request2.query[AMZ_DATE_QUERY_PARAM] = longDate;
    request2.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
    const canonicalHeaders = getCanonicalHeaders(request2, unsignableHeaders, signableHeaders);
    request2.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
    request2.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials2, region, shortDate, signingService), this.createCanonicalRequest(request2, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));
    return request2;
  }
  async sign(toSign, options) {
    if (typeof toSign === "string") {
      return this.signString(toSign, options);
    } else if (toSign.headers && toSign.payload) {
      return this.signEvent(toSign, options);
    } else {
      return this.signRequest(toSign, options);
    }
  }
  async signEvent({ headers, payload }, { signingDate = /* @__PURE__ */ new Date(), priorSignature, signingRegion, signingService }) {
    const region = signingRegion ?? await this.regionProvider();
    const { shortDate, longDate } = formatDate(signingDate);
    const scope = createScope(shortDate, region, signingService ?? this.service);
    const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);
    const hash2 = new this.sha256();
    hash2.update(headers);
    const hashedHeaders = toHex(await hash2.digest());
    const stringToSign = [
      EVENT_ALGORITHM_IDENTIFIER,
      longDate,
      scope,
      priorSignature,
      hashedHeaders,
      hashedPayload
    ].join("\n");
    return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
  }
  async signString(stringToSign, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService } = {}) {
    const credentials2 = await this.credentialProvider();
    this.validateResolvedCredentials(credentials2);
    const region = signingRegion ?? await this.regionProvider();
    const { shortDate } = formatDate(signingDate);
    const hash2 = new this.sha256(await this.getSigningKey(credentials2, region, shortDate, signingService));
    hash2.update(toUint8Array(stringToSign));
    return toHex(await hash2.digest());
  }
  async signRequest(requestToSign, { signingDate = /* @__PURE__ */ new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService } = {}) {
    const credentials2 = await this.credentialProvider();
    this.validateResolvedCredentials(credentials2);
    const region = signingRegion ?? await this.regionProvider();
    const request2 = prepareRequest(requestToSign);
    const { longDate, shortDate } = formatDate(signingDate);
    const scope = createScope(shortDate, region, signingService ?? this.service);
    request2.headers[AMZ_DATE_HEADER] = longDate;
    if (credentials2.sessionToken) {
      request2.headers[TOKEN_HEADER] = credentials2.sessionToken;
    }
    const payloadHash = await getPayloadHash(request2, this.sha256);
    if (!hasHeader2(SHA256_HEADER, request2.headers) && this.applyChecksum) {
      request2.headers[SHA256_HEADER] = payloadHash;
    }
    const canonicalHeaders = getCanonicalHeaders(request2, unsignableHeaders, signableHeaders);
    const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials2, region, shortDate, signingService), this.createCanonicalRequest(request2, canonicalHeaders, payloadHash));
    request2.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} Credential=${credentials2.accessKeyId}/${scope}, SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, Signature=${signature}`;
    return request2;
  }
  createCanonicalRequest(request2, canonicalHeaders, payloadHash) {
    const sortedHeaders = Object.keys(canonicalHeaders).sort();
    return `${request2.method}
${this.getCanonicalPath(request2)}
${getCanonicalQuery(request2)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
  }
  async createStringToSign(longDate, credentialScope, canonicalRequest) {
    const hash2 = new this.sha256();
    hash2.update(toUint8Array(canonicalRequest));
    const hashedRequest = await hash2.digest();
    return `${ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${toHex(hashedRequest)}`;
  }
  getCanonicalPath({ path }) {
    if (this.uriEscapePath) {
      const normalizedPathSegments = [];
      for (const pathSegment of path.split("/")) {
        if (pathSegment?.length === 0)
          continue;
        if (pathSegment === ".")
          continue;
        if (pathSegment === "..") {
          normalizedPathSegments.pop();
        } else {
          normalizedPathSegments.push(pathSegment);
        }
      }
      const normalizedPath = `${path?.startsWith("/") ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && path?.endsWith("/") ? "/" : ""}`;
      const doubleEncoded = encodeURIComponent(normalizedPath);
      return doubleEncoded.replace(/%2F/g, "/");
    }
    return path;
  }
  async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
    const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
    const hash2 = new this.sha256(await keyPromise);
    hash2.update(toUint8Array(stringToSign));
    return toHex(await hash2.digest());
  }
  getSigningKey(credentials2, region, shortDate, service) {
    return getSigningKey(this.sha256, credentials2, shortDate, region, service || this.service);
  }
  validateResolvedCredentials(credentials2) {
    if (typeof credentials2 !== "object" || typeof credentials2.accessKeyId !== "string" || typeof credentials2.secretAccessKey !== "string") {
      throw new Error("Resolved credential object is not valid");
    }
  }
};
var formatDate = (now) => {
  const longDate = iso8601(now).replace(/[\-:]/g, "");
  return {
    longDate,
    shortDate: longDate.slice(0, 8)
  };
};
var getCanonicalHeaderList = (headers) => Object.keys(headers).sort().join(";");

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/configurations.js
var CREDENTIAL_EXPIRE_WINDOW = 3e5;
var resolveAwsAuthConfig = (input) => {
  const normalizedCreds = input.credentials ? normalizeCredentialProvider(input.credentials) : input.credentialDefaultProvider(input);
  const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256 } = input;
  let signer;
  if (input.signer) {
    signer = normalizeProvider(input.signer);
  } else if (input.regionInfoProvider) {
    signer = () => normalizeProvider(input.region)().then(async (region) => [
      await input.regionInfoProvider(region, {
        useFipsEndpoint: await input.useFipsEndpoint(),
        useDualstackEndpoint: await input.useDualstackEndpoint()
      }) || {},
      region
    ]).then(([regionInfo, region]) => {
      const { signingRegion, signingService } = regionInfo;
      input.signingRegion = input.signingRegion || signingRegion || region;
      input.signingName = input.signingName || signingService || input.serviceId;
      const params2 = {
        ...input,
        credentials: normalizedCreds,
        region: input.signingRegion,
        service: input.signingName,
        sha256,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = input.signerConstructor || SignatureV4;
      return new SignerCtor(params2);
    });
  } else {
    signer = async (authScheme) => {
      authScheme = Object.assign({}, {
        name: "sigv4",
        signingName: input.signingName || input.defaultSigningName,
        signingRegion: await normalizeProvider(input.region)(),
        properties: {}
      }, authScheme);
      const signingRegion = authScheme.signingRegion;
      const signingService = authScheme.signingName;
      input.signingRegion = input.signingRegion || signingRegion;
      input.signingName = input.signingName || signingService || input.serviceId;
      const params2 = {
        ...input,
        credentials: normalizedCreds,
        region: input.signingRegion,
        service: input.signingName,
        sha256,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = input.signerConstructor || SignatureV4;
      return new SignerCtor(params2);
    };
  }
  return {
    ...input,
    systemClockOffset,
    signingEscapePath,
    credentials: normalizedCreds,
    signer
  };
};
var normalizeCredentialProvider = (credentials2) => {
  if (typeof credentials2 === "function") {
    return memoize(credentials2, (credentials3) => credentials3.expiration !== void 0 && credentials3.expiration.getTime() - Date.now() < CREDENTIAL_EXPIRE_WINDOW, (credentials3) => credentials3.expiration !== void 0);
  }
  return normalizeProvider(credentials2);
};

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/utils/getSkewCorrectedDate.js
var getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/utils/isClockSkewed.js
var isClockSkewed = (clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 3e5;

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/utils/getUpdatedSystemClockOffset.js
var getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
  const clockTimeInMs = Date.parse(clockTime);
  if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {
    return clockTimeInMs - Date.now();
  }
  return currentSystemClockOffset;
};

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/middleware.js
var awsAuthMiddleware = (options) => (next, context) => async function(args) {
  if (!HttpRequest.isInstance(args.request))
    return next(args);
  const authScheme = context.endpointV2?.properties?.authSchemes?.[0];
  const multiRegionOverride = authScheme?.name === "sigv4a" ? authScheme?.signingRegionSet?.join(",") : void 0;
  const signer = await options.signer(authScheme);
  const output = await next({
    ...args,
    request: await signer.sign(args.request, {
      signingDate: getSkewCorrectedDate(options.systemClockOffset),
      signingRegion: multiRegionOverride || context["signing_region"],
      signingService: context["signing_service"]
    })
  }).catch((error) => {
    const serverTime = error.ServerTime ?? getDateHeader(error.$response);
    if (serverTime) {
      options.systemClockOffset = getUpdatedSystemClockOffset(serverTime, options.systemClockOffset);
    }
    throw error;
  });
  const dateHeader = getDateHeader(output.response);
  if (dateHeader) {
    options.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, options.systemClockOffset);
  }
  return output;
};
var getDateHeader = (response) => HttpResponse.isInstance(response) ? response.headers?.date ?? response.headers?.Date : void 0;
var awsAuthMiddlewareOptions = {
  name: "awsAuthMiddleware",
  tags: ["SIGNATURE", "AWSAUTH"],
  relation: "after",
  toMiddleware: "retryMiddleware",
  override: true
};
var getAwsAuthPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(awsAuthMiddleware(options), awsAuthMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/middleware-user-agent/dist-es/configurations.js
function resolveUserAgentConfig(input) {
  return {
    ...input,
    customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent
  };
}

// ../../node_modules/@aws-sdk/middleware-user-agent/dist-es/constants.js
var USER_AGENT = "user-agent";
var X_AMZ_USER_AGENT = "x-amz-user-agent";
var SPACE = " ";
var UA_ESCAPE_REGEX = /[^\!\#\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;

// ../../node_modules/@aws-sdk/middleware-user-agent/dist-es/user-agent-middleware.js
var userAgentMiddleware = (options) => (next, context) => async (args) => {
  const { request: request2 } = args;
  if (!HttpRequest.isInstance(request2))
    return next(args);
  const { headers } = request2;
  const userAgent = context?.userAgent?.map(escapeUserAgent) || [];
  const defaultUserAgent3 = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
  const customUserAgent = options?.customUserAgent?.map(escapeUserAgent) || [];
  const sdkUserAgentValue = [...defaultUserAgent3, ...userAgent, ...customUserAgent].join(SPACE);
  const normalUAValue = [
    ...defaultUserAgent3.filter((section) => section.startsWith("aws-sdk-")),
    ...customUserAgent
  ].join(SPACE);
  if (options.runtime !== "browser") {
    if (normalUAValue) {
      headers[X_AMZ_USER_AGENT] = headers[X_AMZ_USER_AGENT] ? `${headers[USER_AGENT]} ${normalUAValue}` : normalUAValue;
    }
    headers[USER_AGENT] = sdkUserAgentValue;
  } else {
    headers[X_AMZ_USER_AGENT] = sdkUserAgentValue;
  }
  return next({
    ...args,
    request: request2
  });
};
var escapeUserAgent = ([name, version]) => {
  const prefixSeparatorIndex = name.indexOf("/");
  const prefix = name.substring(0, prefixSeparatorIndex);
  let uaName = name.substring(prefixSeparatorIndex + 1);
  if (prefix === "api") {
    uaName = uaName.toLowerCase();
  }
  return [prefix, uaName, version].filter((item) => item && item.length > 0).map((item) => item?.replace(UA_ESCAPE_REGEX, "_")).join("/");
};
var getUserAgentMiddlewareOptions = {
  name: "getUserAgentMiddleware",
  step: "build",
  priority: "low",
  tags: ["SET_USER_AGENT", "USER_AGENT"],
  override: true
};
var getUserAgentPlugin = (config) => ({
  applyToStack: (clientStack) => {
    clientStack.add(userAgentMiddleware(config), getUserAgentMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/client-s3/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters = (options) => {
  return {
    ...options,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useAccelerateEndpoint: options.useAccelerateEndpoint ?? false,
    useGlobalEndpoint: options.useGlobalEndpoint ?? false,
    disableMultiregionAccessPoints: options.disableMultiregionAccessPoints ?? false,
    defaultSigningName: "s3"
  };
};

// ../../node_modules/@aws-sdk/client-s3/package.json
var package_default = {
  name: "@aws-sdk/client-s3",
  description: "AWS SDK for JavaScript S3 Client for Node.js, Browser and React Native",
  version: "3.272.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo s3",
    test: "yarn test:unit",
    "test:e2e": "ts-mocha test/**/*.ispec.ts && karma start karma.conf.js",
    "test:unit": "ts-mocha test/**/*.spec.ts"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha1-browser": "3.0.0",
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/client-sts": "3.272.0",
    "@aws-sdk/config-resolver": "3.272.0",
    "@aws-sdk/credential-provider-node": "3.272.0",
    "@aws-sdk/eventstream-serde-browser": "3.272.0",
    "@aws-sdk/eventstream-serde-config-resolver": "3.272.0",
    "@aws-sdk/eventstream-serde-node": "3.272.0",
    "@aws-sdk/fetch-http-handler": "3.272.0",
    "@aws-sdk/hash-blob-browser": "3.272.0",
    "@aws-sdk/hash-node": "3.272.0",
    "@aws-sdk/hash-stream-node": "3.272.0",
    "@aws-sdk/invalid-dependency": "3.272.0",
    "@aws-sdk/md5-js": "3.272.0",
    "@aws-sdk/middleware-bucket-endpoint": "3.272.0",
    "@aws-sdk/middleware-content-length": "3.272.0",
    "@aws-sdk/middleware-endpoint": "3.272.0",
    "@aws-sdk/middleware-expect-continue": "3.272.0",
    "@aws-sdk/middleware-flexible-checksums": "3.272.0",
    "@aws-sdk/middleware-host-header": "3.272.0",
    "@aws-sdk/middleware-location-constraint": "3.272.0",
    "@aws-sdk/middleware-logger": "3.272.0",
    "@aws-sdk/middleware-recursion-detection": "3.272.0",
    "@aws-sdk/middleware-retry": "3.272.0",
    "@aws-sdk/middleware-sdk-s3": "3.272.0",
    "@aws-sdk/middleware-serde": "3.272.0",
    "@aws-sdk/middleware-signing": "3.272.0",
    "@aws-sdk/middleware-ssec": "3.272.0",
    "@aws-sdk/middleware-stack": "3.272.0",
    "@aws-sdk/middleware-user-agent": "3.272.0",
    "@aws-sdk/node-config-provider": "3.272.0",
    "@aws-sdk/node-http-handler": "3.272.0",
    "@aws-sdk/protocol-http": "3.272.0",
    "@aws-sdk/signature-v4-multi-region": "3.272.0",
    "@aws-sdk/smithy-client": "3.272.0",
    "@aws-sdk/types": "3.272.0",
    "@aws-sdk/url-parser": "3.272.0",
    "@aws-sdk/util-base64": "3.208.0",
    "@aws-sdk/util-body-length-browser": "3.188.0",
    "@aws-sdk/util-body-length-node": "3.208.0",
    "@aws-sdk/util-defaults-mode-browser": "3.272.0",
    "@aws-sdk/util-defaults-mode-node": "3.272.0",
    "@aws-sdk/util-endpoints": "3.272.0",
    "@aws-sdk/util-retry": "3.272.0",
    "@aws-sdk/util-stream-browser": "3.272.0",
    "@aws-sdk/util-stream-node": "3.272.0",
    "@aws-sdk/util-user-agent-browser": "3.272.0",
    "@aws-sdk/util-user-agent-node": "3.272.0",
    "@aws-sdk/util-utf8": "3.254.0",
    "@aws-sdk/util-waiter": "3.272.0",
    "@aws-sdk/xml-builder": "3.201.0",
    "fast-xml-parser": "4.0.11",
    tslib: "^2.3.1"
  },
  devDependencies: {
    "@aws-sdk/service-client-documentation-generator": "3.208.0",
    "@tsconfig/node14": "1.0.3",
    "@types/chai": "^4.2.11",
    "@types/mocha": "^8.0.4",
    "@types/node": "^14.14.31",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.19.2",
    typescript: "~4.6.2"
  },
  overrides: {
    typedoc: {
      typescript: "~4.6.2"
    }
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-s3"
  }
};

// ../../node_modules/@aws-sdk/client-sts/dist-es/models/STSServiceException.js
var STSServiceException = class extends ServiceException {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, STSServiceException.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-sts/dist-es/models/models_0.js
var ExpiredTokenException = class extends STSServiceException {
  constructor(opts) {
    super({
      name: "ExpiredTokenException",
      $fault: "client",
      ...opts
    });
    this.name = "ExpiredTokenException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ExpiredTokenException.prototype);
  }
};
var MalformedPolicyDocumentException = class extends STSServiceException {
  constructor(opts) {
    super({
      name: "MalformedPolicyDocumentException",
      $fault: "client",
      ...opts
    });
    this.name = "MalformedPolicyDocumentException";
    this.$fault = "client";
    Object.setPrototypeOf(this, MalformedPolicyDocumentException.prototype);
  }
};
var PackedPolicyTooLargeException = class extends STSServiceException {
  constructor(opts) {
    super({
      name: "PackedPolicyTooLargeException",
      $fault: "client",
      ...opts
    });
    this.name = "PackedPolicyTooLargeException";
    this.$fault = "client";
    Object.setPrototypeOf(this, PackedPolicyTooLargeException.prototype);
  }
};
var RegionDisabledException = class extends STSServiceException {
  constructor(opts) {
    super({
      name: "RegionDisabledException",
      $fault: "client",
      ...opts
    });
    this.name = "RegionDisabledException";
    this.$fault = "client";
    Object.setPrototypeOf(this, RegionDisabledException.prototype);
  }
};
var IDPRejectedClaimException = class extends STSServiceException {
  constructor(opts) {
    super({
      name: "IDPRejectedClaimException",
      $fault: "client",
      ...opts
    });
    this.name = "IDPRejectedClaimException";
    this.$fault = "client";
    Object.setPrototypeOf(this, IDPRejectedClaimException.prototype);
  }
};
var InvalidIdentityTokenException = class extends STSServiceException {
  constructor(opts) {
    super({
      name: "InvalidIdentityTokenException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidIdentityTokenException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidIdentityTokenException.prototype);
  }
};
var IDPCommunicationErrorException = class extends STSServiceException {
  constructor(opts) {
    super({
      name: "IDPCommunicationErrorException",
      $fault: "client",
      ...opts
    });
    this.name = "IDPCommunicationErrorException";
    this.$fault = "client";
    Object.setPrototypeOf(this, IDPCommunicationErrorException.prototype);
  }
};
var AssumeRoleRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var AssumeRoleResponseFilterSensitiveLog = (obj) => ({
  ...obj
});
var AssumeRoleWithWebIdentityRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var AssumeRoleWithWebIdentityResponseFilterSensitiveLog = (obj) => ({
  ...obj
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/protocols/Aws_query.js
var import_fast_xml_parser2 = __toESM(require_fxp());
var serializeAws_queryAssumeRoleCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString({
    ...serializeAws_queryAssumeRoleRequest(input, context),
    Action: "AssumeRole",
    Version: "2011-06-15"
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var serializeAws_queryAssumeRoleWithWebIdentityCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString({
    ...serializeAws_queryAssumeRoleWithWebIdentityRequest(input, context),
    Action: "AssumeRoleWithWebIdentity",
    Version: "2011-06-15"
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var deserializeAws_queryAssumeRoleCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_queryAssumeRoleCommandError(output, context);
  }
  const data = await parseBody2(output.body, context);
  let contents = {};
  contents = deserializeAws_queryAssumeRoleResponse(data.AssumeRoleResult, context);
  const response = {
    $metadata: deserializeMetadata3(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_queryAssumeRoleCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody2(output.body, context)
  };
  const errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ExpiredTokenException":
    case "com.amazonaws.sts#ExpiredTokenException":
      throw await deserializeAws_queryExpiredTokenExceptionResponse(parsedOutput, context);
    case "MalformedPolicyDocument":
    case "com.amazonaws.sts#MalformedPolicyDocumentException":
      throw await deserializeAws_queryMalformedPolicyDocumentExceptionResponse(parsedOutput, context);
    case "PackedPolicyTooLarge":
    case "com.amazonaws.sts#PackedPolicyTooLargeException":
      throw await deserializeAws_queryPackedPolicyTooLargeExceptionResponse(parsedOutput, context);
    case "RegionDisabledException":
    case "com.amazonaws.sts#RegionDisabledException":
      throw await deserializeAws_queryRegionDisabledExceptionResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        exceptionCtor: STSServiceException,
        errorCode
      });
  }
};
var deserializeAws_queryAssumeRoleWithWebIdentityCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_queryAssumeRoleWithWebIdentityCommandError(output, context);
  }
  const data = await parseBody2(output.body, context);
  let contents = {};
  contents = deserializeAws_queryAssumeRoleWithWebIdentityResponse(data.AssumeRoleWithWebIdentityResult, context);
  const response = {
    $metadata: deserializeMetadata3(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_queryAssumeRoleWithWebIdentityCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody2(output.body, context)
  };
  const errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ExpiredTokenException":
    case "com.amazonaws.sts#ExpiredTokenException":
      throw await deserializeAws_queryExpiredTokenExceptionResponse(parsedOutput, context);
    case "IDPCommunicationError":
    case "com.amazonaws.sts#IDPCommunicationErrorException":
      throw await deserializeAws_queryIDPCommunicationErrorExceptionResponse(parsedOutput, context);
    case "IDPRejectedClaim":
    case "com.amazonaws.sts#IDPRejectedClaimException":
      throw await deserializeAws_queryIDPRejectedClaimExceptionResponse(parsedOutput, context);
    case "InvalidIdentityToken":
    case "com.amazonaws.sts#InvalidIdentityTokenException":
      throw await deserializeAws_queryInvalidIdentityTokenExceptionResponse(parsedOutput, context);
    case "MalformedPolicyDocument":
    case "com.amazonaws.sts#MalformedPolicyDocumentException":
      throw await deserializeAws_queryMalformedPolicyDocumentExceptionResponse(parsedOutput, context);
    case "PackedPolicyTooLarge":
    case "com.amazonaws.sts#PackedPolicyTooLargeException":
      throw await deserializeAws_queryPackedPolicyTooLargeExceptionResponse(parsedOutput, context);
    case "RegionDisabledException":
    case "com.amazonaws.sts#RegionDisabledException":
      throw await deserializeAws_queryRegionDisabledExceptionResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        exceptionCtor: STSServiceException,
        errorCode
      });
  }
};
var deserializeAws_queryExpiredTokenExceptionResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryExpiredTokenException(body.Error, context);
  const exception = new ExpiredTokenException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_queryIDPCommunicationErrorExceptionResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryIDPCommunicationErrorException(body.Error, context);
  const exception = new IDPCommunicationErrorException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_queryIDPRejectedClaimExceptionResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryIDPRejectedClaimException(body.Error, context);
  const exception = new IDPRejectedClaimException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_queryInvalidIdentityTokenExceptionResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryInvalidIdentityTokenException(body.Error, context);
  const exception = new InvalidIdentityTokenException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_queryMalformedPolicyDocumentExceptionResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryMalformedPolicyDocumentException(body.Error, context);
  const exception = new MalformedPolicyDocumentException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_queryPackedPolicyTooLargeExceptionResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryPackedPolicyTooLargeException(body.Error, context);
  const exception = new PackedPolicyTooLargeException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_queryRegionDisabledExceptionResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryRegionDisabledException(body.Error, context);
  const exception = new RegionDisabledException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var serializeAws_queryAssumeRoleRequest = (input, context) => {
  const entries = {};
  if (input.RoleArn != null) {
    entries["RoleArn"] = input.RoleArn;
  }
  if (input.RoleSessionName != null) {
    entries["RoleSessionName"] = input.RoleSessionName;
  }
  if (input.PolicyArns != null) {
    const memberEntries = serializeAws_querypolicyDescriptorListType(input.PolicyArns, context);
    if (input.PolicyArns?.length === 0) {
      entries.PolicyArns = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PolicyArns.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Policy != null) {
    entries["Policy"] = input.Policy;
  }
  if (input.DurationSeconds != null) {
    entries["DurationSeconds"] = input.DurationSeconds;
  }
  if (input.Tags != null) {
    const memberEntries = serializeAws_querytagListType(input.Tags, context);
    if (input.Tags?.length === 0) {
      entries.Tags = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Tags.${key}`;
      entries[loc] = value;
    });
  }
  if (input.TransitiveTagKeys != null) {
    const memberEntries = serializeAws_querytagKeyListType(input.TransitiveTagKeys, context);
    if (input.TransitiveTagKeys?.length === 0) {
      entries.TransitiveTagKeys = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TransitiveTagKeys.${key}`;
      entries[loc] = value;
    });
  }
  if (input.ExternalId != null) {
    entries["ExternalId"] = input.ExternalId;
  }
  if (input.SerialNumber != null) {
    entries["SerialNumber"] = input.SerialNumber;
  }
  if (input.TokenCode != null) {
    entries["TokenCode"] = input.TokenCode;
  }
  if (input.SourceIdentity != null) {
    entries["SourceIdentity"] = input.SourceIdentity;
  }
  return entries;
};
var serializeAws_queryAssumeRoleWithWebIdentityRequest = (input, context) => {
  const entries = {};
  if (input.RoleArn != null) {
    entries["RoleArn"] = input.RoleArn;
  }
  if (input.RoleSessionName != null) {
    entries["RoleSessionName"] = input.RoleSessionName;
  }
  if (input.WebIdentityToken != null) {
    entries["WebIdentityToken"] = input.WebIdentityToken;
  }
  if (input.ProviderId != null) {
    entries["ProviderId"] = input.ProviderId;
  }
  if (input.PolicyArns != null) {
    const memberEntries = serializeAws_querypolicyDescriptorListType(input.PolicyArns, context);
    if (input.PolicyArns?.length === 0) {
      entries.PolicyArns = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PolicyArns.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Policy != null) {
    entries["Policy"] = input.Policy;
  }
  if (input.DurationSeconds != null) {
    entries["DurationSeconds"] = input.DurationSeconds;
  }
  return entries;
};
var serializeAws_querypolicyDescriptorListType = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = serializeAws_queryPolicyDescriptorType(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var serializeAws_queryPolicyDescriptorType = (input, context) => {
  const entries = {};
  if (input.arn != null) {
    entries["arn"] = input.arn;
  }
  return entries;
};
var serializeAws_queryTag = (input, context) => {
  const entries = {};
  if (input.Key != null) {
    entries["Key"] = input.Key;
  }
  if (input.Value != null) {
    entries["Value"] = input.Value;
  }
  return entries;
};
var serializeAws_querytagKeyListType = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var serializeAws_querytagListType = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = serializeAws_queryTag(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var deserializeAws_queryAssumedRoleUser = (output, context) => {
  const contents = {
    AssumedRoleId: void 0,
    Arn: void 0
  };
  if (output["AssumedRoleId"] !== void 0) {
    contents.AssumedRoleId = expectString(output["AssumedRoleId"]);
  }
  if (output["Arn"] !== void 0) {
    contents.Arn = expectString(output["Arn"]);
  }
  return contents;
};
var deserializeAws_queryAssumeRoleResponse = (output, context) => {
  const contents = {
    Credentials: void 0,
    AssumedRoleUser: void 0,
    PackedPolicySize: void 0,
    SourceIdentity: void 0
  };
  if (output["Credentials"] !== void 0) {
    contents.Credentials = deserializeAws_queryCredentials(output["Credentials"], context);
  }
  if (output["AssumedRoleUser"] !== void 0) {
    contents.AssumedRoleUser = deserializeAws_queryAssumedRoleUser(output["AssumedRoleUser"], context);
  }
  if (output["PackedPolicySize"] !== void 0) {
    contents.PackedPolicySize = strictParseInt32(output["PackedPolicySize"]);
  }
  if (output["SourceIdentity"] !== void 0) {
    contents.SourceIdentity = expectString(output["SourceIdentity"]);
  }
  return contents;
};
var deserializeAws_queryAssumeRoleWithWebIdentityResponse = (output, context) => {
  const contents = {
    Credentials: void 0,
    SubjectFromWebIdentityToken: void 0,
    AssumedRoleUser: void 0,
    PackedPolicySize: void 0,
    Provider: void 0,
    Audience: void 0,
    SourceIdentity: void 0
  };
  if (output["Credentials"] !== void 0) {
    contents.Credentials = deserializeAws_queryCredentials(output["Credentials"], context);
  }
  if (output["SubjectFromWebIdentityToken"] !== void 0) {
    contents.SubjectFromWebIdentityToken = expectString(output["SubjectFromWebIdentityToken"]);
  }
  if (output["AssumedRoleUser"] !== void 0) {
    contents.AssumedRoleUser = deserializeAws_queryAssumedRoleUser(output["AssumedRoleUser"], context);
  }
  if (output["PackedPolicySize"] !== void 0) {
    contents.PackedPolicySize = strictParseInt32(output["PackedPolicySize"]);
  }
  if (output["Provider"] !== void 0) {
    contents.Provider = expectString(output["Provider"]);
  }
  if (output["Audience"] !== void 0) {
    contents.Audience = expectString(output["Audience"]);
  }
  if (output["SourceIdentity"] !== void 0) {
    contents.SourceIdentity = expectString(output["SourceIdentity"]);
  }
  return contents;
};
var deserializeAws_queryCredentials = (output, context) => {
  const contents = {
    AccessKeyId: void 0,
    SecretAccessKey: void 0,
    SessionToken: void 0,
    Expiration: void 0
  };
  if (output["AccessKeyId"] !== void 0) {
    contents.AccessKeyId = expectString(output["AccessKeyId"]);
  }
  if (output["SecretAccessKey"] !== void 0) {
    contents.SecretAccessKey = expectString(output["SecretAccessKey"]);
  }
  if (output["SessionToken"] !== void 0) {
    contents.SessionToken = expectString(output["SessionToken"]);
  }
  if (output["Expiration"] !== void 0) {
    contents.Expiration = expectNonNull(parseRfc3339DateTimeWithOffset(output["Expiration"]));
  }
  return contents;
};
var deserializeAws_queryExpiredTokenException = (output, context) => {
  const contents = {
    message: void 0
  };
  if (output["message"] !== void 0) {
    contents.message = expectString(output["message"]);
  }
  return contents;
};
var deserializeAws_queryIDPCommunicationErrorException = (output, context) => {
  const contents = {
    message: void 0
  };
  if (output["message"] !== void 0) {
    contents.message = expectString(output["message"]);
  }
  return contents;
};
var deserializeAws_queryIDPRejectedClaimException = (output, context) => {
  const contents = {
    message: void 0
  };
  if (output["message"] !== void 0) {
    contents.message = expectString(output["message"]);
  }
  return contents;
};
var deserializeAws_queryInvalidIdentityTokenException = (output, context) => {
  const contents = {
    message: void 0
  };
  if (output["message"] !== void 0) {
    contents.message = expectString(output["message"]);
  }
  return contents;
};
var deserializeAws_queryMalformedPolicyDocumentException = (output, context) => {
  const contents = {
    message: void 0
  };
  if (output["message"] !== void 0) {
    contents.message = expectString(output["message"]);
  }
  return contents;
};
var deserializeAws_queryPackedPolicyTooLargeException = (output, context) => {
  const contents = {
    message: void 0
  };
  if (output["message"] !== void 0) {
    contents.message = expectString(output["message"]);
  }
  return contents;
};
var deserializeAws_queryRegionDisabledException = (output, context) => {
  const contents = {
    message: void 0
  };
  if (output["message"] !== void 0) {
    contents.message = expectString(output["message"]);
  }
  return contents;
};
var deserializeMetadata3 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
var collectBody3 = (streamBody = new Uint8Array(), context) => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
var collectBodyString3 = (streamBody, context) => collectBody3(streamBody, context).then((body) => context.utf8Encoder(body));
var buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const contents = {
    protocol,
    hostname,
    port,
    method: "POST",
    path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
    headers
  };
  if (resolvedHostname !== void 0) {
    contents.hostname = resolvedHostname;
  }
  if (body !== void 0) {
    contents.body = body;
  }
  return new HttpRequest(contents);
};
var parseBody2 = (streamBody, context) => collectBodyString3(streamBody, context).then((encoded) => {
  if (encoded.length) {
    const parser = new import_fast_xml_parser2.XMLParser({
      attributeNamePrefix: "",
      htmlEntities: true,
      ignoreAttributes: false,
      ignoreDeclaration: true,
      parseTagValue: false,
      trimValues: false,
      tagValueProcessor: (_, val) => val.trim() === "" && val.includes("\n") ? "" : void 0
    });
    parser.addEntity("#xD", "\r");
    parser.addEntity("#10", "\n");
    const parsedObj = parser.parse(encoded);
    const textNodeName = "#text";
    const key = Object.keys(parsedObj)[0];
    const parsedObjToReturn = parsedObj[key];
    if (parsedObjToReturn[textNodeName]) {
      parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
      delete parsedObjToReturn[textNodeName];
    }
    return getValueFromTextNode(parsedObjToReturn);
  }
  return {};
});
var parseErrorBody2 = async (errorBody, context) => {
  const value = await parseBody2(errorBody, context);
  if (value.Error) {
    value.Error.message = value.Error.message ?? value.Error.Message;
  }
  return value;
};
var buildFormUrlencodedString = (formEntries) => Object.entries(formEntries).map(([key, value]) => extendedEncodeURIComponent(key) + "=" + extendedEncodeURIComponent(value)).join("&");
var loadQueryErrorCode = (output, data) => {
  if (data.Error?.Code !== void 0) {
    return data.Error.Code;
  }
  if (output.statusCode == 404) {
    return "NotFound";
  }
};

// ../../node_modules/@aws-sdk/client-sts/dist-es/commands/AssumeRoleCommand.js
var AssumeRoleCommand = class extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, AssumeRoleCommand.getEndpointParameterInstructions()));
    this.middlewareStack.use(getAwsAuthPlugin(configuration));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "STSClient";
    const commandName = "AssumeRoleCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: AssumeRoleRequestFilterSensitiveLog,
      outputFilterSensitiveLog: AssumeRoleResponseFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_queryAssumeRoleCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_queryAssumeRoleCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sts/dist-es/commands/AssumeRoleWithWebIdentityCommand.js
var AssumeRoleWithWebIdentityCommand = class extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, AssumeRoleWithWebIdentityCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "STSClient";
    const commandName = "AssumeRoleWithWebIdentityCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: AssumeRoleWithWebIdentityRequestFilterSensitiveLog,
      outputFilterSensitiveLog: AssumeRoleWithWebIdentityResponseFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_queryAssumeRoleWithWebIdentityCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_queryAssumeRoleWithWebIdentityCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/middleware-sdk-sts/dist-es/index.js
var resolveStsAuthConfig = (input, { stsClientCtor }) => resolveAwsAuthConfig({
  ...input,
  stsClientCtor
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters2 = (options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    useGlobalEndpoint: options.useGlobalEndpoint ?? false,
    defaultSigningName: "sts"
  };
};

// ../../node_modules/@aws-sdk/client-sts/package.json
var package_default2 = {
  name: "@aws-sdk/client-sts",
  description: "AWS SDK for JavaScript Sts Client for Node.js, Browser and React Native",
  version: "3.272.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo sts",
    test: "yarn test:unit",
    "test:unit": "jest"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/config-resolver": "3.272.0",
    "@aws-sdk/credential-provider-node": "3.272.0",
    "@aws-sdk/fetch-http-handler": "3.272.0",
    "@aws-sdk/hash-node": "3.272.0",
    "@aws-sdk/invalid-dependency": "3.272.0",
    "@aws-sdk/middleware-content-length": "3.272.0",
    "@aws-sdk/middleware-endpoint": "3.272.0",
    "@aws-sdk/middleware-host-header": "3.272.0",
    "@aws-sdk/middleware-logger": "3.272.0",
    "@aws-sdk/middleware-recursion-detection": "3.272.0",
    "@aws-sdk/middleware-retry": "3.272.0",
    "@aws-sdk/middleware-sdk-sts": "3.272.0",
    "@aws-sdk/middleware-serde": "3.272.0",
    "@aws-sdk/middleware-signing": "3.272.0",
    "@aws-sdk/middleware-stack": "3.272.0",
    "@aws-sdk/middleware-user-agent": "3.272.0",
    "@aws-sdk/node-config-provider": "3.272.0",
    "@aws-sdk/node-http-handler": "3.272.0",
    "@aws-sdk/protocol-http": "3.272.0",
    "@aws-sdk/smithy-client": "3.272.0",
    "@aws-sdk/types": "3.272.0",
    "@aws-sdk/url-parser": "3.272.0",
    "@aws-sdk/util-base64": "3.208.0",
    "@aws-sdk/util-body-length-browser": "3.188.0",
    "@aws-sdk/util-body-length-node": "3.208.0",
    "@aws-sdk/util-defaults-mode-browser": "3.272.0",
    "@aws-sdk/util-defaults-mode-node": "3.272.0",
    "@aws-sdk/util-endpoints": "3.272.0",
    "@aws-sdk/util-retry": "3.272.0",
    "@aws-sdk/util-user-agent-browser": "3.272.0",
    "@aws-sdk/util-user-agent-node": "3.272.0",
    "@aws-sdk/util-utf8": "3.254.0",
    "fast-xml-parser": "4.0.11",
    tslib: "^2.3.1"
  },
  devDependencies: {
    "@aws-sdk/service-client-documentation-generator": "3.208.0",
    "@tsconfig/node14": "1.0.3",
    "@types/node": "^14.14.31",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.19.2",
    typescript: "~4.6.2"
  },
  overrides: {
    typedoc: {
      typescript: "~4.6.2"
    }
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sts",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-sts"
  }
};

// ../../node_modules/@aws-sdk/client-sts/dist-es/defaultStsRoleAssumers.js
var ASSUME_ROLE_DEFAULT_REGION = "us-east-1";
var decorateDefaultRegion = (region) => {
  if (typeof region !== "function") {
    return region === void 0 ? ASSUME_ROLE_DEFAULT_REGION : region;
  }
  return async () => {
    try {
      return await region();
    } catch (e10) {
      return ASSUME_ROLE_DEFAULT_REGION;
    }
  };
};
var getDefaultRoleAssumer = (stsOptions, stsClientCtor) => {
  let stsClient;
  let closureSourceCreds;
  return async (sourceCreds, params2) => {
    closureSourceCreds = sourceCreds;
    if (!stsClient) {
      const { logger: logger3, region, requestHandler } = stsOptions;
      stsClient = new stsClientCtor({
        logger: logger3,
        credentialDefaultProvider: () => async () => closureSourceCreds,
        region: decorateDefaultRegion(region || stsOptions.region),
        ...requestHandler ? { requestHandler } : {}
      });
    }
    const { Credentials } = await stsClient.send(new AssumeRoleCommand(params2));
    if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
      throw new Error(`Invalid response from STS.assumeRole call with role ${params2.RoleArn}`);
    }
    return {
      accessKeyId: Credentials.AccessKeyId,
      secretAccessKey: Credentials.SecretAccessKey,
      sessionToken: Credentials.SessionToken,
      expiration: Credentials.Expiration
    };
  };
};
var getDefaultRoleAssumerWithWebIdentity = (stsOptions, stsClientCtor) => {
  let stsClient;
  return async (params2) => {
    if (!stsClient) {
      const { logger: logger3, region, requestHandler } = stsOptions;
      stsClient = new stsClientCtor({
        logger: logger3,
        region: decorateDefaultRegion(region || stsOptions.region),
        ...requestHandler ? { requestHandler } : {}
      });
    }
    const { Credentials } = await stsClient.send(new AssumeRoleWithWebIdentityCommand(params2));
    if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
      throw new Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${params2.RoleArn}`);
    }
    return {
      accessKeyId: Credentials.AccessKeyId,
      secretAccessKey: Credentials.SecretAccessKey,
      sessionToken: Credentials.SessionToken,
      expiration: Credentials.Expiration
    };
  };
};
var decorateDefaultCredentialProvider = (provider) => (input) => provider({
  roleAssumer: getDefaultRoleAssumer(input, input.stsClientCtor),
  roleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity(input, input.stsClientCtor),
  ...input
});

// ../../node_modules/@aws-sdk/credential-provider-env/dist-es/fromEnv.js
var ENV_KEY = "AWS_ACCESS_KEY_ID";
var ENV_SECRET = "AWS_SECRET_ACCESS_KEY";
var ENV_SESSION = "AWS_SESSION_TOKEN";
var ENV_EXPIRATION = "AWS_CREDENTIAL_EXPIRATION";
var fromEnv = () => async () => {
  const accessKeyId = process.env[ENV_KEY];
  const secretAccessKey = process.env[ENV_SECRET];
  const sessionToken = process.env[ENV_SESSION];
  const expiry = process.env[ENV_EXPIRATION];
  if (accessKeyId && secretAccessKey) {
    return {
      accessKeyId,
      secretAccessKey,
      ...sessionToken && { sessionToken },
      ...expiry && { expiration: new Date(expiry) }
    };
  }
  throw new CredentialsProviderError("Unable to find environment variable credentials.");
};

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getHomeDir.js
var import_os = require("os");
var import_path = require("path");
var getHomeDir = () => {
  const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${import_path.sep}` } = process.env;
  if (HOME)
    return HOME;
  if (USERPROFILE)
    return USERPROFILE;
  if (HOMEPATH)
    return `${HOMEDRIVE}${HOMEPATH}`;
  return (0, import_os.homedir)();
};

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getProfileName.js
var ENV_PROFILE = "AWS_PROFILE";
var DEFAULT_PROFILE = "default";
var getProfileName = (init) => init.profile || process.env[ENV_PROFILE] || DEFAULT_PROFILE;

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js
var import_crypto2 = require("crypto");
var import_path2 = require("path");
var getSSOTokenFilepath = (id) => {
  const hasher = (0, import_crypto2.createHash)("sha1");
  const cacheName = hasher.update(id).digest("hex");
  return (0, import_path2.join)(getHomeDir(), ".aws", "sso", "cache", `${cacheName}.json`);
};

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js
var import_fs2 = require("fs");
var { readFile } = import_fs2.promises;
var getSSOTokenFromFile = async (id) => {
  const ssoTokenFilepath = getSSOTokenFilepath(id);
  const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
  return JSON.parse(ssoTokenText);
};

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getConfigFilepath.js
var import_path3 = require("path");
var ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
var getConfigFilepath = () => process.env[ENV_CONFIG_PATH] || (0, import_path3.join)(getHomeDir(), ".aws", "config");

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getCredentialsFilepath.js
var import_path4 = require("path");
var ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
var getCredentialsFilepath = () => process.env[ENV_CREDENTIALS_PATH] || (0, import_path4.join)(getHomeDir(), ".aws", "credentials");

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getProfileData.js
var profileKeyRegex = /^profile\s(["'])?([^\1]+)\1$/;
var getProfileData = (data) => Object.entries(data).filter(([key]) => profileKeyRegex.test(key)).reduce((acc, [key, value]) => ({ ...acc, [profileKeyRegex.exec(key)[2]]: value }), {
  ...data.default && { default: data.default }
});

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/parseIni.js
var profileNameBlockList = ["__proto__", "profile __proto__"];
var parseIni = (iniData) => {
  const map9 = {};
  let currentSection;
  for (let line of iniData.split(/\r?\n/)) {
    line = line.split(/(^|\s)[;#]/)[0].trim();
    const isSection = line[0] === "[" && line[line.length - 1] === "]";
    if (isSection) {
      currentSection = line.substring(1, line.length - 1);
      if (profileNameBlockList.includes(currentSection)) {
        throw new Error(`Found invalid profile name "${currentSection}"`);
      }
    } else if (currentSection) {
      const indexOfEqualsSign = line.indexOf("=");
      const start = 0;
      const end = line.length - 1;
      const isAssignment = indexOfEqualsSign !== -1 && indexOfEqualsSign !== start && indexOfEqualsSign !== end;
      if (isAssignment) {
        const [name, value] = [
          line.substring(0, indexOfEqualsSign).trim(),
          line.substring(indexOfEqualsSign + 1).trim()
        ];
        map9[currentSection] = map9[currentSection] || {};
        map9[currentSection][name] = value;
      }
    }
  }
  return map9;
};

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/slurpFile.js
var import_fs3 = require("fs");
var { readFile: readFile2 } = import_fs3.promises;
var filePromisesHash = {};
var slurpFile = (path) => {
  if (!filePromisesHash[path]) {
    filePromisesHash[path] = readFile2(path, "utf8");
  }
  return filePromisesHash[path];
};

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/loadSharedConfigFiles.js
var swallowError = () => ({});
var loadSharedConfigFiles = async (init = {}) => {
  const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath() } = init;
  const parsedFiles = await Promise.all([
    slurpFile(configFilepath).then(parseIni).then(getProfileData).catch(swallowError),
    slurpFile(filepath).then(parseIni).catch(swallowError)
  ]);
  return {
    configFile: parsedFiles[0],
    credentialsFile: parsedFiles[1]
  };
};

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getSsoSessionData.js
var ssoSessionKeyRegex = /^sso-session\s(["'])?([^\1]+)\1$/;
var getSsoSessionData = (data) => Object.entries(data).filter(([key]) => ssoSessionKeyRegex.test(key)).reduce((acc, [key, value]) => ({ ...acc, [ssoSessionKeyRegex.exec(key)[2]]: value }), {});

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/loadSsoSessionData.js
var swallowError2 = () => ({});
var loadSsoSessionData = async (init = {}) => slurpFile(init.configFilepath ?? getConfigFilepath()).then(parseIni).then(getSsoSessionData).catch(swallowError2);

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/parseKnownFiles.js
var parseKnownFiles = async (init) => {
  const parsedFiles = await loadSharedConfigFiles(init);
  return {
    ...parsedFiles.configFile,
    ...parsedFiles.credentialsFile
  };
};

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/fromContainerMetadata.js
var import_url = require("url");

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/remoteProvider/httpRequest.js
var import_buffer2 = require("buffer");
var import_http = require("http");
function httpRequest(options) {
  return new Promise((resolve, reject) => {
    const req = (0, import_http.request)({
      method: "GET",
      ...options,
      hostname: options.hostname?.replace(/^\[(.+)\]$/, "$1")
    });
    req.on("error", (err) => {
      reject(Object.assign(new ProviderError("Unable to connect to instance metadata service"), err));
      req.destroy();
    });
    req.on("timeout", () => {
      reject(new ProviderError("TimeoutError from instance metadata service"));
      req.destroy();
    });
    req.on("response", (res) => {
      const { statusCode = 400 } = res;
      if (statusCode < 200 || 300 <= statusCode) {
        reject(Object.assign(new ProviderError("Error response received from instance metadata service"), { statusCode }));
        req.destroy();
      }
      const chunks = [];
      res.on("data", (chunk2) => {
        chunks.push(chunk2);
      });
      res.on("end", () => {
        resolve(import_buffer2.Buffer.concat(chunks));
        req.destroy();
      });
    });
    req.end();
  });
}

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/remoteProvider/ImdsCredentials.js
var isImdsCredentials = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.AccessKeyId === "string" && typeof arg.SecretAccessKey === "string" && typeof arg.Token === "string" && typeof arg.Expiration === "string";
var fromImdsCredentials = (creds) => ({
  accessKeyId: creds.AccessKeyId,
  secretAccessKey: creds.SecretAccessKey,
  sessionToken: creds.Token,
  expiration: new Date(creds.Expiration)
});

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/remoteProvider/RemoteProviderInit.js
var DEFAULT_TIMEOUT = 1e3;
var DEFAULT_MAX_RETRIES = 0;
var providerConfigFromInit = ({ maxRetries = DEFAULT_MAX_RETRIES, timeout = DEFAULT_TIMEOUT }) => ({ maxRetries, timeout });

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/remoteProvider/retry.js
var retry = (toRetry, maxRetries) => {
  let promise = toRetry();
  for (let i10 = 0; i10 < maxRetries; i10++) {
    promise = promise.catch(toRetry);
  }
  return promise;
};

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/fromContainerMetadata.js
var ENV_CMDS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
var ENV_CMDS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
var ENV_CMDS_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
var fromContainerMetadata = (init = {}) => {
  const { timeout, maxRetries } = providerConfigFromInit(init);
  return () => retry(async () => {
    const requestOptions = await getCmdsUri();
    const credsResponse = JSON.parse(await requestFromEcsImds(timeout, requestOptions));
    if (!isImdsCredentials(credsResponse)) {
      throw new CredentialsProviderError("Invalid response received from instance metadata service.");
    }
    return fromImdsCredentials(credsResponse);
  }, maxRetries);
};
var requestFromEcsImds = async (timeout, options) => {
  if (process.env[ENV_CMDS_AUTH_TOKEN]) {
    options.headers = {
      ...options.headers,
      Authorization: process.env[ENV_CMDS_AUTH_TOKEN]
    };
  }
  const buffer = await httpRequest({
    ...options,
    timeout
  });
  return buffer.toString();
};
var CMDS_IP = "169.254.170.2";
var GREENGRASS_HOSTS = {
  localhost: true,
  "127.0.0.1": true
};
var GREENGRASS_PROTOCOLS = {
  "http:": true,
  "https:": true
};
var getCmdsUri = async () => {
  if (process.env[ENV_CMDS_RELATIVE_URI]) {
    return {
      hostname: CMDS_IP,
      path: process.env[ENV_CMDS_RELATIVE_URI]
    };
  }
  if (process.env[ENV_CMDS_FULL_URI]) {
    const parsed = (0, import_url.parse)(process.env[ENV_CMDS_FULL_URI]);
    if (!parsed.hostname || !(parsed.hostname in GREENGRASS_HOSTS)) {
      throw new CredentialsProviderError(`${parsed.hostname} is not a valid container metadata service hostname`, false);
    }
    if (!parsed.protocol || !(parsed.protocol in GREENGRASS_PROTOCOLS)) {
      throw new CredentialsProviderError(`${parsed.protocol} is not a valid container metadata service protocol`, false);
    }
    return {
      ...parsed,
      port: parsed.port ? parseInt(parsed.port, 10) : void 0
    };
  }
  throw new CredentialsProviderError(`The container metadata credential provider cannot be used unless the ${ENV_CMDS_RELATIVE_URI} or ${ENV_CMDS_FULL_URI} environment variable is set`, false);
};

// ../../node_modules/@aws-sdk/node-config-provider/dist-es/fromEnv.js
var fromEnv2 = (envVarSelector) => async () => {
  try {
    const config = envVarSelector(process.env);
    if (config === void 0) {
      throw new Error();
    }
    return config;
  } catch (e10) {
    throw new CredentialsProviderError(e10.message || `Cannot load config from environment variables with getter: ${envVarSelector}`);
  }
};

// ../../node_modules/@aws-sdk/node-config-provider/dist-es/fromSharedConfigFiles.js
var fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init } = {}) => async () => {
  const profile = getProfileName(init);
  const { configFile, credentialsFile } = await loadSharedConfigFiles(init);
  const profileFromCredentials = credentialsFile[profile] || {};
  const profileFromConfig = configFile[profile] || {};
  const mergedProfile = preferredFile === "config" ? { ...profileFromCredentials, ...profileFromConfig } : { ...profileFromConfig, ...profileFromCredentials };
  try {
    const configValue = configSelector(mergedProfile);
    if (configValue === void 0) {
      throw new Error();
    }
    return configValue;
  } catch (e10) {
    throw new CredentialsProviderError(e10.message || `Cannot load config for profile ${profile} in SDK configuration files with getter: ${configSelector}`);
  }
};

// ../../node_modules/@aws-sdk/node-config-provider/dist-es/fromStatic.js
var isFunction = (func) => typeof func === "function";
var fromStatic2 = (defaultValue) => isFunction(defaultValue) ? async () => await defaultValue() : fromStatic(defaultValue);

// ../../node_modules/@aws-sdk/node-config-provider/dist-es/configLoader.js
var loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => memoize(chain(fromEnv2(environmentVariableSelector), fromSharedConfigFiles(configFileSelector, configuration), fromStatic2(defaultValue)));

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/config/Endpoint.js
var Endpoint;
(function(Endpoint2) {
  Endpoint2["IPv4"] = "http://169.254.169.254";
  Endpoint2["IPv6"] = "http://[fd00:ec2::254]";
})(Endpoint || (Endpoint = {}));

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/config/EndpointConfigOptions.js
var ENV_ENDPOINT_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT";
var CONFIG_ENDPOINT_NAME = "ec2_metadata_service_endpoint";
var ENDPOINT_CONFIG_OPTIONS = {
  environmentVariableSelector: (env3) => env3[ENV_ENDPOINT_NAME],
  configFileSelector: (profile) => profile[CONFIG_ENDPOINT_NAME],
  default: void 0
};

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/config/EndpointMode.js
var EndpointMode;
(function(EndpointMode2) {
  EndpointMode2["IPv4"] = "IPv4";
  EndpointMode2["IPv6"] = "IPv6";
})(EndpointMode || (EndpointMode = {}));

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/config/EndpointModeConfigOptions.js
var ENV_ENDPOINT_MODE_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE";
var CONFIG_ENDPOINT_MODE_NAME = "ec2_metadata_service_endpoint_mode";
var ENDPOINT_MODE_CONFIG_OPTIONS = {
  environmentVariableSelector: (env3) => env3[ENV_ENDPOINT_MODE_NAME],
  configFileSelector: (profile) => profile[CONFIG_ENDPOINT_MODE_NAME],
  default: EndpointMode.IPv4
};

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/utils/getInstanceMetadataEndpoint.js
var getInstanceMetadataEndpoint = async () => parseUrl(await getFromEndpointConfig() || await getFromEndpointModeConfig());
var getFromEndpointConfig = async () => loadConfig(ENDPOINT_CONFIG_OPTIONS)();
var getFromEndpointModeConfig = async () => {
  const endpointMode = await loadConfig(ENDPOINT_MODE_CONFIG_OPTIONS)();
  switch (endpointMode) {
    case EndpointMode.IPv4:
      return Endpoint.IPv4;
    case EndpointMode.IPv6:
      return Endpoint.IPv6;
    default:
      throw new Error(`Unsupported endpoint mode: ${endpointMode}. Select from ${Object.values(EndpointMode)}`);
  }
};

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/utils/getExtendedInstanceMetadataCredentials.js
var STATIC_STABILITY_REFRESH_INTERVAL_SECONDS = 5 * 60;
var STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS = 5 * 60;
var STATIC_STABILITY_DOC_URL = "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html";
var getExtendedInstanceMetadataCredentials = (credentials2, logger3) => {
  const refreshInterval = STATIC_STABILITY_REFRESH_INTERVAL_SECONDS + Math.floor(Math.random() * STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS);
  const newExpiration = new Date(Date.now() + refreshInterval * 1e3);
  logger3.warn("Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(newExpiration)}.\nFor more information, please visit: " + STATIC_STABILITY_DOC_URL);
  const originalExpiration = credentials2.originalExpiration ?? credentials2.expiration;
  return {
    ...credentials2,
    ...originalExpiration ? { originalExpiration } : {},
    expiration: newExpiration
  };
};

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/utils/staticStabilityProvider.js
var staticStabilityProvider = (provider, options = {}) => {
  const logger3 = options?.logger || console;
  let pastCredentials;
  return async () => {
    let credentials2;
    try {
      credentials2 = await provider();
      if (credentials2.expiration && credentials2.expiration.getTime() < Date.now()) {
        credentials2 = getExtendedInstanceMetadataCredentials(credentials2, logger3);
      }
    } catch (e10) {
      if (pastCredentials) {
        logger3.warn("Credential renew failed: ", e10);
        credentials2 = getExtendedInstanceMetadataCredentials(pastCredentials, logger3);
      } else {
        throw e10;
      }
    }
    pastCredentials = credentials2;
    return credentials2;
  };
};

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/fromInstanceMetadata.js
var IMDS_PATH = "/latest/meta-data/iam/security-credentials/";
var IMDS_TOKEN_PATH = "/latest/api/token";
var fromInstanceMetadata = (init = {}) => staticStabilityProvider(getInstanceImdsProvider(init), { logger: init.logger });
var getInstanceImdsProvider = (init) => {
  let disableFetchToken = false;
  const { timeout, maxRetries } = providerConfigFromInit(init);
  const getCredentials = async (maxRetries2, options) => {
    const profile = (await retry(async () => {
      let profile2;
      try {
        profile2 = await getProfile(options);
      } catch (err) {
        if (err.statusCode === 401) {
          disableFetchToken = false;
        }
        throw err;
      }
      return profile2;
    }, maxRetries2)).trim();
    return retry(async () => {
      let creds;
      try {
        creds = await getCredentialsFromProfile(profile, options);
      } catch (err) {
        if (err.statusCode === 401) {
          disableFetchToken = false;
        }
        throw err;
      }
      return creds;
    }, maxRetries2);
  };
  return async () => {
    const endpoint = await getInstanceMetadataEndpoint();
    if (disableFetchToken) {
      return getCredentials(maxRetries, { ...endpoint, timeout });
    } else {
      let token;
      try {
        token = (await getMetadataToken({ ...endpoint, timeout })).toString();
      } catch (error) {
        if (error?.statusCode === 400) {
          throw Object.assign(error, {
            message: "EC2 Metadata token request returned error"
          });
        } else if (error.message === "TimeoutError" || [403, 404, 405].includes(error.statusCode)) {
          disableFetchToken = true;
        }
        return getCredentials(maxRetries, { ...endpoint, timeout });
      }
      return getCredentials(maxRetries, {
        ...endpoint,
        headers: {
          "x-aws-ec2-metadata-token": token
        },
        timeout
      });
    }
  };
};
var getMetadataToken = async (options) => httpRequest({
  ...options,
  path: IMDS_TOKEN_PATH,
  method: "PUT",
  headers: {
    "x-aws-ec2-metadata-token-ttl-seconds": "21600"
  }
});
var getProfile = async (options) => (await httpRequest({ ...options, path: IMDS_PATH })).toString();
var getCredentialsFromProfile = async (profile, options) => {
  const credsResponse = JSON.parse((await httpRequest({
    ...options,
    path: IMDS_PATH + profile
  })).toString());
  if (!isImdsCredentials(credsResponse)) {
    throw new CredentialsProviderError("Invalid response received from instance metadata service.");
  }
  return fromImdsCredentials(credsResponse);
};

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveCredentialSource.js
var resolveCredentialSource = (credentialSource, profileName) => {
  const sourceProvidersMap = {
    EcsContainer: fromContainerMetadata,
    Ec2InstanceMetadata: fromInstanceMetadata,
    Environment: fromEnv
  };
  if (credentialSource in sourceProvidersMap) {
    return sourceProvidersMap[credentialSource]();
  } else {
    throw new CredentialsProviderError(`Unsupported credential source in profile ${profileName}. Got ${credentialSource}, expected EcsContainer or Ec2InstanceMetadata or Environment.`);
  }
};

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveAssumeRoleCredentials.js
var isAssumeRoleProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1 && ["undefined", "string"].indexOf(typeof arg.external_id) > -1 && ["undefined", "string"].indexOf(typeof arg.mfa_serial) > -1 && (isAssumeRoleWithSourceProfile(arg) || isAssumeRoleWithProviderProfile(arg));
var isAssumeRoleWithSourceProfile = (arg) => typeof arg.source_profile === "string" && typeof arg.credential_source === "undefined";
var isAssumeRoleWithProviderProfile = (arg) => typeof arg.credential_source === "string" && typeof arg.source_profile === "undefined";
var resolveAssumeRoleCredentials = async (profileName, profiles, options, visitedProfiles = {}) => {
  const data = profiles[profileName];
  if (!options.roleAssumer) {
    throw new CredentialsProviderError(`Profile ${profileName} requires a role to be assumed, but no role assumption callback was provided.`, false);
  }
  const { source_profile } = data;
  if (source_profile && source_profile in visitedProfiles) {
    throw new CredentialsProviderError(`Detected a cycle attempting to resolve credentials for profile ${getProfileName(options)}. Profiles visited: ` + Object.keys(visitedProfiles).join(", "), false);
  }
  const sourceCredsProvider = source_profile ? resolveProfileData(source_profile, profiles, options, {
    ...visitedProfiles,
    [source_profile]: true
  }) : resolveCredentialSource(data.credential_source, profileName)();
  const params2 = {
    RoleArn: data.role_arn,
    RoleSessionName: data.role_session_name || `aws-sdk-js-${Date.now()}`,
    ExternalId: data.external_id
  };
  const { mfa_serial } = data;
  if (mfa_serial) {
    if (!options.mfaCodeProvider) {
      throw new CredentialsProviderError(`Profile ${profileName} requires multi-factor authentication, but no MFA code callback was provided.`, false);
    }
    params2.SerialNumber = mfa_serial;
    params2.TokenCode = await options.mfaCodeProvider(mfa_serial);
  }
  const sourceCreds = await sourceCredsProvider;
  return options.roleAssumer(sourceCreds, params2);
};

// ../../node_modules/@aws-sdk/credential-provider-process/dist-es/resolveProcessCredentials.js
var import_child_process = require("child_process");
var import_util3 = require("util");

// ../../node_modules/@aws-sdk/credential-provider-process/dist-es/getValidatedProcessCredentials.js
var getValidatedProcessCredentials = (profileName, data) => {
  if (data.Version !== 1) {
    throw Error(`Profile ${profileName} credential_process did not return Version 1.`);
  }
  if (data.AccessKeyId === void 0 || data.SecretAccessKey === void 0) {
    throw Error(`Profile ${profileName} credential_process returned invalid credentials.`);
  }
  if (data.Expiration) {
    const currentTime = /* @__PURE__ */ new Date();
    const expireTime = new Date(data.Expiration);
    if (expireTime < currentTime) {
      throw Error(`Profile ${profileName} credential_process returned expired credentials.`);
    }
  }
  return {
    accessKeyId: data.AccessKeyId,
    secretAccessKey: data.SecretAccessKey,
    ...data.SessionToken && { sessionToken: data.SessionToken },
    ...data.Expiration && { expiration: new Date(data.Expiration) }
  };
};

// ../../node_modules/@aws-sdk/credential-provider-process/dist-es/resolveProcessCredentials.js
var resolveProcessCredentials = async (profileName, profiles) => {
  const profile = profiles[profileName];
  if (profiles[profileName]) {
    const credentialProcess = profile["credential_process"];
    if (credentialProcess !== void 0) {
      const execPromise = (0, import_util3.promisify)(import_child_process.exec);
      try {
        const { stdout } = await execPromise(credentialProcess);
        let data;
        try {
          data = JSON.parse(stdout.trim());
        } catch {
          throw Error(`Profile ${profileName} credential_process returned invalid JSON.`);
        }
        return getValidatedProcessCredentials(profileName, data);
      } catch (error) {
        throw new CredentialsProviderError(error.message);
      }
    } else {
      throw new CredentialsProviderError(`Profile ${profileName} did not contain credential_process.`);
    }
  } else {
    throw new CredentialsProviderError(`Profile ${profileName} could not be found in shared credentials file.`);
  }
};

// ../../node_modules/@aws-sdk/credential-provider-process/dist-es/fromProcess.js
var fromProcess = (init = {}) => async () => {
  const profiles = await parseKnownFiles(init);
  return resolveProcessCredentials(getProfileName(init), profiles);
};

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveProcessCredentials.js
var isProcessProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.credential_process === "string";
var resolveProcessCredentials2 = async (options, profile) => fromProcess({
  ...options,
  profile
})();

// ../../node_modules/@aws-sdk/credential-provider-sso/dist-es/isSsoProfile.js
var isSsoProfile = (arg) => arg && (typeof arg.sso_start_url === "string" || typeof arg.sso_account_id === "string" || typeof arg.sso_session === "string" || typeof arg.sso_region === "string" || typeof arg.sso_role_name === "string");

// ../../node_modules/@aws-sdk/client-sso/dist-es/models/SSOServiceException.js
var SSOServiceException = class extends ServiceException {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, SSOServiceException.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-sso/dist-es/models/models_0.js
var InvalidRequestException = class extends SSOServiceException {
  constructor(opts) {
    super({
      name: "InvalidRequestException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidRequestException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidRequestException.prototype);
  }
};
var ResourceNotFoundException = class extends SSOServiceException {
  constructor(opts) {
    super({
      name: "ResourceNotFoundException",
      $fault: "client",
      ...opts
    });
    this.name = "ResourceNotFoundException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
  }
};
var TooManyRequestsException = class extends SSOServiceException {
  constructor(opts) {
    super({
      name: "TooManyRequestsException",
      $fault: "client",
      ...opts
    });
    this.name = "TooManyRequestsException";
    this.$fault = "client";
    Object.setPrototypeOf(this, TooManyRequestsException.prototype);
  }
};
var UnauthorizedException = class extends SSOServiceException {
  constructor(opts) {
    super({
      name: "UnauthorizedException",
      $fault: "client",
      ...opts
    });
    this.name = "UnauthorizedException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UnauthorizedException.prototype);
  }
};
var GetRoleCredentialsRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.accessToken && { accessToken: SENSITIVE_STRING }
});
var RoleCredentialsFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.secretAccessKey && { secretAccessKey: SENSITIVE_STRING },
  ...obj.sessionToken && { sessionToken: SENSITIVE_STRING }
});
var GetRoleCredentialsResponseFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.roleCredentials && { roleCredentials: RoleCredentialsFilterSensitiveLog(obj.roleCredentials) }
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/protocols/Aws_restJson1.js
var serializeAws_restJson1GetRoleCredentialsCommand = async (input, context) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers = map4({}, isSerializableHeaderValue2, {
    "x-amz-sso_bearer_token": input.accessToken
  });
  const resolvedPath2 = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}/federation/credentials`;
  const query = map4({
    role_name: [, expectNonNull(input.roleName, `roleName`)],
    account_id: [, expectNonNull(input.accountId, `accountId`)]
  });
  let body;
  return new HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath2,
    query,
    body
  });
};
var deserializeAws_restJson1GetRoleCredentialsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetRoleCredentialsCommandError(output, context);
  }
  const contents = map4({
    $metadata: deserializeMetadata4(output)
  });
  const data = expectNonNull(expectObject(await parseBody3(output.body, context)), "body");
  if (data.roleCredentials != null) {
    contents.roleCredentials = deserializeAws_restJson1RoleCredentials(data.roleCredentials, context);
  }
  return contents;
};
var deserializeAws_restJson1GetRoleCredentialsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody3(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.sso#InvalidRequestException":
      throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.sso#ResourceNotFoundException":
      throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
    case "TooManyRequestsException":
    case "com.amazonaws.sso#TooManyRequestsException":
      throw await deserializeAws_restJson1TooManyRequestsExceptionResponse(parsedOutput, context);
    case "UnauthorizedException":
    case "com.amazonaws.sso#UnauthorizedException":
      throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: SSOServiceException,
        errorCode
      });
  }
};
var map4 = map2;
var deserializeAws_restJson1InvalidRequestExceptionResponse = async (parsedOutput, context) => {
  const contents = map4({});
  const data = parsedOutput.body;
  if (data.message != null) {
    contents.message = expectString(data.message);
  }
  const exception = new InvalidRequestException({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var deserializeAws_restJson1ResourceNotFoundExceptionResponse = async (parsedOutput, context) => {
  const contents = map4({});
  const data = parsedOutput.body;
  if (data.message != null) {
    contents.message = expectString(data.message);
  }
  const exception = new ResourceNotFoundException({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var deserializeAws_restJson1TooManyRequestsExceptionResponse = async (parsedOutput, context) => {
  const contents = map4({});
  const data = parsedOutput.body;
  if (data.message != null) {
    contents.message = expectString(data.message);
  }
  const exception = new TooManyRequestsException({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var deserializeAws_restJson1UnauthorizedExceptionResponse = async (parsedOutput, context) => {
  const contents = map4({});
  const data = parsedOutput.body;
  if (data.message != null) {
    contents.message = expectString(data.message);
  }
  const exception = new UnauthorizedException({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var deserializeAws_restJson1RoleCredentials = (output, context) => {
  return {
    accessKeyId: expectString(output.accessKeyId),
    expiration: expectLong(output.expiration),
    secretAccessKey: expectString(output.secretAccessKey),
    sessionToken: expectString(output.sessionToken)
  };
};
var deserializeMetadata4 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
var collectBody4 = (streamBody = new Uint8Array(), context) => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
var collectBodyString4 = (streamBody, context) => collectBody4(streamBody, context).then((body) => context.utf8Encoder(body));
var isSerializableHeaderValue2 = (value) => value !== void 0 && value !== null && value !== "" && (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) && (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
var parseBody3 = (streamBody, context) => collectBodyString4(streamBody, context).then((encoded) => {
  if (encoded.length) {
    return JSON.parse(encoded);
  }
  return {};
});
var parseErrorBody3 = async (errorBody, context) => {
  const value = await parseBody3(errorBody, context);
  value.message = value.message ?? value.Message;
  return value;
};
var loadRestJsonErrorCode = (output, data) => {
  const findKey = (object2, key) => Object.keys(object2).find((k10) => k10.toLowerCase() === key.toLowerCase());
  const sanitizeErrorCode = (rawValue) => {
    let cleanValue = rawValue;
    if (typeof cleanValue === "number") {
      cleanValue = cleanValue.toString();
    }
    if (cleanValue.indexOf(",") >= 0) {
      cleanValue = cleanValue.split(",")[0];
    }
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  };
  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== void 0) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }
  if (data.code !== void 0) {
    return sanitizeErrorCode(data.code);
  }
  if (data["__type"] !== void 0) {
    return sanitizeErrorCode(data["__type"]);
  }
};

// ../../node_modules/@aws-sdk/client-sso/dist-es/commands/GetRoleCredentialsCommand.js
var GetRoleCredentialsCommand = class extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, GetRoleCredentialsCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SSOClient";
    const commandName = "GetRoleCredentialsCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: GetRoleCredentialsRequestFilterSensitiveLog,
      outputFilterSensitiveLog: GetRoleCredentialsResponseFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_restJson1GetRoleCredentialsCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_restJson1GetRoleCredentialsCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sso/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters3 = (options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "awsssoportal"
  };
};

// ../../node_modules/@aws-sdk/client-sso/package.json
var package_default3 = {
  name: "@aws-sdk/client-sso",
  description: "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
  version: "3.272.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo sso"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/config-resolver": "3.272.0",
    "@aws-sdk/fetch-http-handler": "3.272.0",
    "@aws-sdk/hash-node": "3.272.0",
    "@aws-sdk/invalid-dependency": "3.272.0",
    "@aws-sdk/middleware-content-length": "3.272.0",
    "@aws-sdk/middleware-endpoint": "3.272.0",
    "@aws-sdk/middleware-host-header": "3.272.0",
    "@aws-sdk/middleware-logger": "3.272.0",
    "@aws-sdk/middleware-recursion-detection": "3.272.0",
    "@aws-sdk/middleware-retry": "3.272.0",
    "@aws-sdk/middleware-serde": "3.272.0",
    "@aws-sdk/middleware-stack": "3.272.0",
    "@aws-sdk/middleware-user-agent": "3.272.0",
    "@aws-sdk/node-config-provider": "3.272.0",
    "@aws-sdk/node-http-handler": "3.272.0",
    "@aws-sdk/protocol-http": "3.272.0",
    "@aws-sdk/smithy-client": "3.272.0",
    "@aws-sdk/types": "3.272.0",
    "@aws-sdk/url-parser": "3.272.0",
    "@aws-sdk/util-base64": "3.208.0",
    "@aws-sdk/util-body-length-browser": "3.188.0",
    "@aws-sdk/util-body-length-node": "3.208.0",
    "@aws-sdk/util-defaults-mode-browser": "3.272.0",
    "@aws-sdk/util-defaults-mode-node": "3.272.0",
    "@aws-sdk/util-endpoints": "3.272.0",
    "@aws-sdk/util-retry": "3.272.0",
    "@aws-sdk/util-user-agent-browser": "3.272.0",
    "@aws-sdk/util-user-agent-node": "3.272.0",
    "@aws-sdk/util-utf8": "3.254.0",
    tslib: "^2.3.1"
  },
  devDependencies: {
    "@aws-sdk/service-client-documentation-generator": "3.208.0",
    "@tsconfig/node14": "1.0.3",
    "@types/node": "^14.14.31",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.19.2",
    typescript: "~4.6.2"
  },
  overrides: {
    typedoc: {
      typescript: "~4.6.2"
    }
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-sso"
  }
};

// ../../node_modules/@aws-sdk/hash-node/dist-es/index.js
var import_buffer3 = require("buffer");
var import_crypto3 = require("crypto");
var Hash = class {
  constructor(algorithmIdentifier, secret) {
    this.algorithmIdentifier = algorithmIdentifier;
    this.secret = secret;
    this.reset();
  }
  update(toHash, encoding) {
    this.hash.update(toUint8Array(castSourceData(toHash, encoding)));
  }
  digest() {
    return Promise.resolve(this.hash.digest());
  }
  reset() {
    this.hash = this.secret ? (0, import_crypto3.createHmac)(this.algorithmIdentifier, castSourceData(this.secret)) : (0, import_crypto3.createHash)(this.algorithmIdentifier);
  }
};
function castSourceData(toCast, encoding) {
  if (import_buffer3.Buffer.isBuffer(toCast)) {
    return toCast;
  }
  if (typeof toCast === "string") {
    return fromString(toCast, encoding);
  }
  if (ArrayBuffer.isView(toCast)) {
    return fromArrayBuffer(toCast.buffer, toCast.byteOffset, toCast.byteLength);
  }
  return fromArrayBuffer(toCast);
}

// ../../node_modules/@aws-sdk/querystring-builder/dist-es/index.js
function buildQueryString(query) {
  const parts = [];
  for (let key of Object.keys(query).sort()) {
    const value = query[key];
    key = escapeUri(key);
    if (Array.isArray(value)) {
      for (let i10 = 0, iLen = value.length; i10 < iLen; i10++) {
        parts.push(`${key}=${escapeUri(value[i10])}`);
      }
    } else {
      let qsEntry = key;
      if (value || typeof value === "string") {
        qsEntry += `=${escapeUri(value)}`;
      }
      parts.push(qsEntry);
    }
  }
  return parts.join("&");
}

// ../../node_modules/@aws-sdk/node-http-handler/dist-es/node-http-handler.js
var import_http2 = require("http");
var import_https = require("https");

// ../../node_modules/@aws-sdk/node-http-handler/dist-es/constants.js
var NODEJS_TIMEOUT_ERROR_CODES2 = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];

// ../../node_modules/@aws-sdk/node-http-handler/dist-es/get-transformed-headers.js
var getTransformedHeaders = (headers) => {
  const transformedHeaders = {};
  for (const name of Object.keys(headers)) {
    const headerValues = headers[name];
    transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
  }
  return transformedHeaders;
};

// ../../node_modules/@aws-sdk/node-http-handler/dist-es/set-connection-timeout.js
var setConnectionTimeout = (request2, reject, timeoutInMs = 0) => {
  if (!timeoutInMs) {
    return;
  }
  request2.on("socket", (socket) => {
    if (socket.connecting) {
      const timeoutId = setTimeout(() => {
        request2.destroy();
        reject(Object.assign(new Error(`Socket timed out without establishing a connection within ${timeoutInMs} ms`), {
          name: "TimeoutError"
        }));
      }, timeoutInMs);
      socket.on("connect", () => {
        clearTimeout(timeoutId);
      });
    }
  });
};

// ../../node_modules/@aws-sdk/node-http-handler/dist-es/set-socket-timeout.js
var setSocketTimeout = (request2, reject, timeoutInMs = 0) => {
  request2.setTimeout(timeoutInMs, () => {
    request2.destroy();
    reject(Object.assign(new Error(`Connection timed out after ${timeoutInMs} ms`), { name: "TimeoutError" }));
  });
};

// ../../node_modules/@aws-sdk/node-http-handler/dist-es/write-request-body.js
var import_stream = require("stream");
function writeRequestBody(httpRequest2, request2) {
  const expect = request2.headers["Expect"] || request2.headers["expect"];
  if (expect === "100-continue") {
    httpRequest2.on("continue", () => {
      writeBody(httpRequest2, request2.body);
    });
  } else {
    writeBody(httpRequest2, request2.body);
  }
}
function writeBody(httpRequest2, body) {
  if (body instanceof import_stream.Readable) {
    body.pipe(httpRequest2);
  } else if (body) {
    httpRequest2.end(Buffer.from(body));
  } else {
    httpRequest2.end();
  }
}

// ../../node_modules/@aws-sdk/node-http-handler/dist-es/node-http-handler.js
var NodeHttpHandler = class {
  constructor(options) {
    this.metadata = { handlerProtocol: "http/1.1" };
    this.configProvider = new Promise((resolve, reject) => {
      if (typeof options === "function") {
        options().then((_options) => {
          resolve(this.resolveDefaultConfig(_options));
        }).catch(reject);
      } else {
        resolve(this.resolveDefaultConfig(options));
      }
    });
  }
  resolveDefaultConfig(options) {
    const { connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
    const keepAlive = true;
    const maxSockets = 50;
    return {
      connectionTimeout,
      socketTimeout,
      httpAgent: httpAgent || new import_http2.Agent({ keepAlive, maxSockets }),
      httpsAgent: httpsAgent || new import_https.Agent({ keepAlive, maxSockets })
    };
  }
  destroy() {
    this.config?.httpAgent?.destroy();
    this.config?.httpsAgent?.destroy();
  }
  async handle(request2, { abortSignal } = {}) {
    if (!this.config) {
      this.config = await this.configProvider;
    }
    return new Promise((resolve, reject) => {
      if (!this.config) {
        throw new Error("Node HTTP request handler config is not resolved");
      }
      if (abortSignal?.aborted) {
        const abortError = new Error("Request aborted");
        abortError.name = "AbortError";
        reject(abortError);
        return;
      }
      const isSSL = request2.protocol === "https:";
      const queryString = buildQueryString(request2.query || {});
      const nodeHttpsOptions = {
        headers: request2.headers,
        host: request2.hostname,
        method: request2.method,
        path: queryString ? `${request2.path}?${queryString}` : request2.path,
        port: request2.port,
        agent: isSSL ? this.config.httpsAgent : this.config.httpAgent
      };
      const requestFunc = isSSL ? import_https.request : import_http2.request;
      const req = requestFunc(nodeHttpsOptions, (res) => {
        const httpResponse = new HttpResponse({
          statusCode: res.statusCode || -1,
          headers: getTransformedHeaders(res.headers),
          body: res
        });
        resolve({ response: httpResponse });
      });
      req.on("error", (err) => {
        if (NODEJS_TIMEOUT_ERROR_CODES2.includes(err.code)) {
          reject(Object.assign(err, { name: "TimeoutError" }));
        } else {
          reject(err);
        }
      });
      setConnectionTimeout(req, reject, this.config.connectionTimeout);
      setSocketTimeout(req, reject, this.config.socketTimeout);
      if (abortSignal) {
        abortSignal.onabort = () => {
          req.abort();
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          reject(abortError);
        };
      }
      writeRequestBody(req, request2);
    });
  }
};

// ../../node_modules/@aws-sdk/node-http-handler/dist-es/stream-collector/collector.js
var import_stream2 = require("stream");
var Collector = class extends import_stream2.Writable {
  constructor() {
    super(...arguments);
    this.bufferedBytes = [];
  }
  _write(chunk2, encoding, callback) {
    this.bufferedBytes.push(chunk2);
    callback();
  }
};

// ../../node_modules/@aws-sdk/node-http-handler/dist-es/stream-collector/index.js
var streamCollector = (stream) => new Promise((resolve, reject) => {
  const collector = new Collector();
  stream.pipe(collector);
  stream.on("error", (err) => {
    collector.end();
    reject(err);
  });
  collector.on("error", reject);
  collector.on("finish", function() {
    const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
    resolve(bytes);
  });
});

// ../../node_modules/@aws-sdk/util-body-length-node/dist-es/calculateBodyLength.js
var import_fs4 = require("fs");
var calculateBodyLength = (body) => {
  if (!body) {
    return 0;
  }
  if (typeof body === "string") {
    return Buffer.from(body).length;
  } else if (typeof body.byteLength === "number") {
    return body.byteLength;
  } else if (typeof body.size === "number") {
    return body.size;
  } else if (typeof body.path === "string" || Buffer.isBuffer(body.path)) {
    return (0, import_fs4.lstatSync)(body.path).size;
  } else if (typeof body.fd === "number") {
    return (0, import_fs4.fstatSync)(body.fd).size;
  }
  throw new Error(`Body Length computation failed for ${body}`);
};

// ../../node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js
var import_os2 = require("os");
var import_process = require("process");

// ../../node_modules/@aws-sdk/util-user-agent-node/dist-es/is-crt-available.js
var isCrtAvailable = () => {
  try {
    if (typeof require === "function" && typeof module !== "undefined" && module.require && require("aws-crt")) {
      return ["md/crt-avail"];
    }
    return null;
  } catch (e10) {
    return null;
  }
};

// ../../node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js
var UA_APP_ID_ENV_NAME = "AWS_SDK_UA_APP_ID";
var UA_APP_ID_INI_NAME = "sdk-ua-app-id";
var defaultUserAgent = ({ serviceId, clientVersion }) => {
  const sections = [
    ["aws-sdk-js", clientVersion],
    [`os/${(0, import_os2.platform)()}`, (0, import_os2.release)()],
    ["lang/js"],
    ["md/nodejs", `${import_process.versions.node}`]
  ];
  const crtAvailable = isCrtAvailable();
  if (crtAvailable) {
    sections.push(crtAvailable);
  }
  if (serviceId) {
    sections.push([`api/${serviceId}`, clientVersion]);
  }
  if (import_process.env.AWS_EXECUTION_ENV) {
    sections.push([`exec-env/${import_process.env.AWS_EXECUTION_ENV}`]);
  }
  const appIdPromise = loadConfig({
    environmentVariableSelector: (env3) => env3[UA_APP_ID_ENV_NAME],
    configFileSelector: (profile) => profile[UA_APP_ID_INI_NAME],
    default: void 0
  })();
  let resolvedUserAgent = void 0;
  return async () => {
    if (!resolvedUserAgent) {
      const appId = await appIdPromise;
      resolvedUserAgent = appId ? [...sections, [`app/${appId}`]] : [...sections];
    }
    return resolvedUserAgent;
  };
};

// ../../node_modules/@aws-sdk/util-base64/dist-es/fromBase64.js
var BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
var fromBase64 = (input) => {
  if (input.length * 3 % 4 !== 0) {
    throw new TypeError(`Incorrect padding on base64 string.`);
  }
  if (!BASE64_REGEX.exec(input)) {
    throw new TypeError(`Invalid base64 string.`);
  }
  const buffer = fromString(input, "base64");
  return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
};

// ../../node_modules/@aws-sdk/util-base64/dist-es/toBase64.js
var toBase64 = (input) => fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("base64");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partitions.json
var partitions_default = {
  partitions: [{
    id: "aws",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      name: "aws",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^(us|eu|ap|sa|ca|me|af)\\-\\w+\\-\\d+$",
    regions: {
      "af-south-1": {
        description: "Africa (Cape Town)"
      },
      "ap-east-1": {
        description: "Asia Pacific (Hong Kong)"
      },
      "ap-northeast-1": {
        description: "Asia Pacific (Tokyo)"
      },
      "ap-northeast-2": {
        description: "Asia Pacific (Seoul)"
      },
      "ap-northeast-3": {
        description: "Asia Pacific (Osaka)"
      },
      "ap-south-1": {
        description: "Asia Pacific (Mumbai)"
      },
      "ap-south-2": {
        description: "Asia Pacific (Hyderabad)"
      },
      "ap-southeast-1": {
        description: "Asia Pacific (Singapore)"
      },
      "ap-southeast-2": {
        description: "Asia Pacific (Sydney)"
      },
      "ap-southeast-3": {
        description: "Asia Pacific (Jakarta)"
      },
      "ap-southeast-4": {
        description: "Asia Pacific (Melbourne)"
      },
      "aws-global": {
        description: "AWS Standard global region"
      },
      "ca-central-1": {
        description: "Canada (Central)"
      },
      "eu-central-1": {
        description: "Europe (Frankfurt)"
      },
      "eu-central-2": {
        description: "Europe (Zurich)"
      },
      "eu-north-1": {
        description: "Europe (Stockholm)"
      },
      "eu-south-1": {
        description: "Europe (Milan)"
      },
      "eu-south-2": {
        description: "Europe (Spain)"
      },
      "eu-west-1": {
        description: "Europe (Ireland)"
      },
      "eu-west-2": {
        description: "Europe (London)"
      },
      "eu-west-3": {
        description: "Europe (Paris)"
      },
      "me-central-1": {
        description: "Middle East (UAE)"
      },
      "me-south-1": {
        description: "Middle East (Bahrain)"
      },
      "sa-east-1": {
        description: "South America (Sao Paulo)"
      },
      "us-east-1": {
        description: "US East (N. Virginia)"
      },
      "us-east-2": {
        description: "US East (Ohio)"
      },
      "us-west-1": {
        description: "US West (N. California)"
      },
      "us-west-2": {
        description: "US West (Oregon)"
      }
    }
  }, {
    id: "aws-cn",
    outputs: {
      dnsSuffix: "amazonaws.com.cn",
      dualStackDnsSuffix: "api.amazonwebservices.com.cn",
      name: "aws-cn",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^cn\\-\\w+\\-\\d+$",
    regions: {
      "aws-cn-global": {
        description: "AWS China global region"
      },
      "cn-north-1": {
        description: "China (Beijing)"
      },
      "cn-northwest-1": {
        description: "China (Ningxia)"
      }
    }
  }, {
    id: "aws-us-gov",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      name: "aws-us-gov",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
    regions: {
      "aws-us-gov-global": {
        description: "AWS GovCloud (US) global region"
      },
      "us-gov-east-1": {
        description: "AWS GovCloud (US-East)"
      },
      "us-gov-west-1": {
        description: "AWS GovCloud (US-West)"
      }
    }
  }, {
    id: "aws-iso",
    outputs: {
      dnsSuffix: "c2s.ic.gov",
      dualStackDnsSuffix: "c2s.ic.gov",
      name: "aws-iso",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-global": {
        description: "AWS ISO (US) global region"
      },
      "us-iso-east-1": {
        description: "US ISO East"
      },
      "us-iso-west-1": {
        description: "US ISO WEST"
      }
    }
  }, {
    id: "aws-iso-b",
    outputs: {
      dnsSuffix: "sc2s.sgov.gov",
      dualStackDnsSuffix: "sc2s.sgov.gov",
      name: "aws-iso-b",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-b-global": {
        description: "AWS ISOB (US) global region"
      },
      "us-isob-east-1": {
        description: "US ISOB East (Ohio)"
      }
    }
  }],
  version: "1.1"
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partition.js
var { partitions } = partitions_default;
var DEFAULT_PARTITION = partitions.find((partition2) => partition2.id === "aws");
var partition = (value) => {
  for (const partition2 of partitions) {
    const { regions, outputs } = partition2;
    for (const [region, regionData] of Object.entries(regions)) {
      if (region === value) {
        return {
          ...outputs,
          ...regionData
        };
      }
    }
  }
  for (const partition2 of partitions) {
    const { regionRegex, outputs } = partition2;
    if (new RegExp(regionRegex).test(value)) {
      return {
        ...outputs
      };
    }
  }
  if (!DEFAULT_PARTITION) {
    throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
  }
  return {
    ...DEFAULT_PARTITION.outputs
  };
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/debug/debugId.js
var debugId = "endpoints";

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/debug/toDebugString.js
function toDebugString(input) {
  if (typeof input !== "object" || input == null) {
    return input;
  }
  if ("ref" in input) {
    return `$${toDebugString(input.ref)}`;
  }
  if ("fn" in input) {
    return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
  }
  return JSON.stringify(input, null, 2);
}

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointError.js
var EndpointError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "EndpointError";
  }
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/index.js
var lib_exports = {};
__export(lib_exports, {
  aws: () => aws_exports,
  booleanEquals: () => booleanEquals,
  getAttr: () => getAttr,
  isSet: () => isSet,
  isValidHostLabel: () => isValidHostLabel,
  not: () => not,
  parseURL: () => parseURL,
  stringEquals: () => stringEquals,
  substring: () => substring,
  uriEncode: () => uriEncode
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/index.js
var aws_exports = {};
__export(aws_exports, {
  isVirtualHostableS3Bucket: () => isVirtualHostableS3Bucket,
  parseArn: () => parseArn,
  partition: () => partition
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/isIpAddress.js
var IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
var isIpAddress = (value) => IP_V4_REGEX.test(value) || value.startsWith("[") && value.endsWith("]");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/isValidHostLabel.js
var VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
var isValidHostLabel = (value, allowSubDomains = false) => {
  if (!allowSubDomains) {
    return VALID_HOST_LABEL_REGEX.test(value);
  }
  const labels = value.split(".");
  for (const label of labels) {
    if (!isValidHostLabel(label)) {
      return false;
    }
  }
  return true;
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/isVirtualHostableS3Bucket.js
var isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {
  if (allowSubDomains) {
    for (const label of value.split(".")) {
      if (!isVirtualHostableS3Bucket(label)) {
        return false;
      }
    }
    return true;
  }
  if (!isValidHostLabel(value)) {
    return false;
  }
  if (value.length < 3 || value.length > 63) {
    return false;
  }
  if (value !== value.toLowerCase()) {
    return false;
  }
  if (isIpAddress(value)) {
    return false;
  }
  return true;
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/parseArn.js
var parseArn = (value) => {
  const segments = value.split(":");
  if (segments.length < 6)
    return null;
  const [arn, partition2, service, region, accountId, ...resourceId] = segments;
  if (arn !== "arn" || partition2 === "" || service === "" || resourceId[0] === "")
    return null;
  return {
    partition: partition2,
    service,
    region,
    accountId,
    resourceId: resourceId[0].includes("/") ? resourceId[0].split("/") : resourceId
  };
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/booleanEquals.js
var booleanEquals = (value1, value2) => value1 === value2;

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/getAttrPathList.js
var getAttrPathList = (path) => {
  const parts = path.split(".");
  const pathList = [];
  for (const part of parts) {
    const squareBracketIndex = part.indexOf("[");
    if (squareBracketIndex !== -1) {
      if (part.indexOf("]") !== part.length - 1) {
        throw new EndpointError(`Path: '${path}' does not end with ']'`);
      }
      const arrayIndex = part.slice(squareBracketIndex + 1, -1);
      if (Number.isNaN(parseInt(arrayIndex))) {
        throw new EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
      }
      if (squareBracketIndex !== 0) {
        pathList.push(part.slice(0, squareBracketIndex));
      }
      pathList.push(arrayIndex);
    } else {
      pathList.push(part);
    }
  }
  return pathList;
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/getAttr.js
var getAttr = (value, path) => getAttrPathList(path).reduce((acc, index) => {
  if (typeof acc !== "object") {
    throw new EndpointError(`Index '${index}' in '${path}' not found in '${JSON.stringify(value)}'`);
  } else if (Array.isArray(acc)) {
    return acc[parseInt(index)];
  }
  return acc[index];
}, value);

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/isSet.js
var isSet = (value) => value != null;

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/not.js
var not = (value) => !value;

// ../../node_modules/@aws-sdk/types/dist-es/auth.js
var HttpAuthLocation;
(function(HttpAuthLocation2) {
  HttpAuthLocation2["HEADER"] = "header";
  HttpAuthLocation2["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

// ../../node_modules/@aws-sdk/types/dist-es/dns.js
var HostAddressType;
(function(HostAddressType2) {
  HostAddressType2["AAAA"] = "AAAA";
  HostAddressType2["A"] = "A";
})(HostAddressType || (HostAddressType = {}));

// ../../node_modules/@aws-sdk/types/dist-es/endpoint.js
var EndpointURLScheme;
(function(EndpointURLScheme2) {
  EndpointURLScheme2["HTTP"] = "http";
  EndpointURLScheme2["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/parseURL.js
var DEFAULT_PORTS = {
  [EndpointURLScheme.HTTP]: 80,
  [EndpointURLScheme.HTTPS]: 443
};
var parseURL = (value) => {
  const whatwgURL = (() => {
    try {
      if (value instanceof URL) {
        return value;
      }
      if (typeof value === "object" && "hostname" in value) {
        const { hostname: hostname2, port, protocol: protocol2 = "", path = "", query = {} } = value;
        const url = new URL(`${protocol2}//${hostname2}${port ? `:${port}` : ""}${path}`);
        url.search = Object.entries(query).map(([k10, v7]) => `${k10}=${v7}`).join("&");
        return url;
      }
      return new URL(value);
    } catch (error) {
      return null;
    }
  })();
  if (!whatwgURL) {
    console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
    return null;
  }
  const urlString = whatwgURL.href;
  const { host, hostname, pathname, protocol, search } = whatwgURL;
  if (search) {
    return null;
  }
  const scheme = protocol.slice(0, -1);
  if (!Object.values(EndpointURLScheme).includes(scheme)) {
    return null;
  }
  const isIp = isIpAddress(hostname);
  const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) || typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`);
  const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
  return {
    scheme,
    authority,
    path: pathname,
    normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
    isIp
  };
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/stringEquals.js
var stringEquals = (value1, value2) => value1 === value2;

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/substring.js
var substring = (input, start, stop, reverse) => {
  if (start >= stop || input.length < stop) {
    return null;
  }
  if (!reverse) {
    return input.substring(start, stop);
  }
  return input.substring(input.length - stop, input.length - start);
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/uriEncode.js
var uriEncode = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c10) => `%${c10.charCodeAt(0).toString(16).toUpperCase()}`);

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateTemplate.js
var evaluateTemplate = (template, options) => {
  const evaluatedTemplateArr = [];
  const templateContext = {
    ...options.endpointParams,
    ...options.referenceRecord
  };
  let currentIndex = 0;
  while (currentIndex < template.length) {
    const openingBraceIndex = template.indexOf("{", currentIndex);
    if (openingBraceIndex === -1) {
      evaluatedTemplateArr.push(template.slice(currentIndex));
      break;
    }
    evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
    const closingBraceIndex = template.indexOf("}", openingBraceIndex);
    if (closingBraceIndex === -1) {
      evaluatedTemplateArr.push(template.slice(openingBraceIndex));
      break;
    }
    if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
      evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
      currentIndex = closingBraceIndex + 2;
    }
    const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
    if (parameterName.includes("#")) {
      const [refName, attrName] = parameterName.split("#");
      evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));
    } else {
      evaluatedTemplateArr.push(templateContext[parameterName]);
    }
    currentIndex = closingBraceIndex + 1;
  }
  return evaluatedTemplateArr.join("");
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/getReferenceValue.js
var getReferenceValue = ({ ref }, options) => {
  const referenceRecord = {
    ...options.endpointParams,
    ...options.referenceRecord
  };
  return referenceRecord[ref];
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateExpression.js
var evaluateExpression = (obj, keyName, options) => {
  if (typeof obj === "string") {
    return evaluateTemplate(obj, options);
  } else if (obj["fn"]) {
    return callFunction(obj, options);
  } else if (obj["ref"]) {
    return getReferenceValue(obj, options);
  }
  throw new EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/callFunction.js
var callFunction = ({ fn, argv }, options) => {
  const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : evaluateExpression(arg, "arg", options));
  return fn.split(".").reduce((acc, key) => acc[key], lib_exports)(...evaluatedArgs);
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateCondition.js
var evaluateCondition = ({ assign, ...fnArgs }, options) => {
  if (assign && assign in options.referenceRecord) {
    throw new EndpointError(`'${assign}' is already defined in Reference Record.`);
  }
  const value = callFunction(fnArgs, options);
  options.logger?.debug?.(debugId, `evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);
  return {
    result: value === "" ? true : !!value,
    ...assign != null && { toAssign: { name: assign, value } }
  };
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateConditions.js
var evaluateConditions = (conditions = [], options) => {
  const conditionsReferenceRecord = {};
  for (const condition of conditions) {
    const { result, toAssign } = evaluateCondition(condition, {
      ...options,
      referenceRecord: {
        ...options.referenceRecord,
        ...conditionsReferenceRecord
      }
    });
    if (!result) {
      return { result };
    }
    if (toAssign) {
      conditionsReferenceRecord[toAssign.name] = toAssign.value;
      options.logger?.debug?.(debugId, `assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);
    }
  }
  return { result: true, referenceRecord: conditionsReferenceRecord };
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointHeaders.js
var getEndpointHeaders = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
  ...acc,
  [headerKey]: headerVal.map((headerValEntry) => {
    const processedExpr = evaluateExpression(headerValEntry, "Header value entry", options);
    if (typeof processedExpr !== "string") {
      throw new EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
    }
    return processedExpr;
  })
}), {});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointProperty.js
var getEndpointProperty = (property, options) => {
  if (Array.isArray(property)) {
    return property.map((propertyEntry) => getEndpointProperty(propertyEntry, options));
  }
  switch (typeof property) {
    case "string":
      return evaluateTemplate(property, options);
    case "object":
      if (property === null) {
        throw new EndpointError(`Unexpected endpoint property: ${property}`);
      }
      return getEndpointProperties(property, options);
    case "boolean":
      return property;
    default:
      throw new EndpointError(`Unexpected endpoint property type: ${typeof property}`);
  }
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointProperties.js
var getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
  ...acc,
  [propertyKey]: getEndpointProperty(propertyVal, options)
}), {});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointUrl.js
var getEndpointUrl = (endpointUrl, options) => {
  const expression = evaluateExpression(endpointUrl, "Endpoint URL", options);
  if (typeof expression === "string") {
    try {
      return new URL(expression);
    } catch (error) {
      console.error(`Failed to construct URL with ${expression}`, error);
      throw error;
    }
  }
  throw new EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateEndpointRule.js
var evaluateEndpointRule = (endpointRule, options) => {
  const { conditions, endpoint } = endpointRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  const endpointRuleOptions = {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  };
  const { url, properties, headers } = endpoint;
  options.logger?.debug?.(debugId, `Resolving endpoint from template: ${toDebugString(endpoint)}`);
  return {
    ...headers != void 0 && {
      headers: getEndpointHeaders(headers, endpointRuleOptions)
    },
    ...properties != void 0 && {
      properties: getEndpointProperties(properties, endpointRuleOptions)
    },
    url: getEndpointUrl(url, endpointRuleOptions)
  };
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateErrorRule.js
var evaluateErrorRule = (errorRule, options) => {
  const { conditions, error } = errorRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  throw new EndpointError(evaluateExpression(error, "Error", {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  }));
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateTreeRule.js
var evaluateTreeRule = (treeRule, options) => {
  const { conditions, rules } = treeRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  return evaluateRules(rules, {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  });
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateRules.js
var evaluateRules = (rules, options) => {
  for (const rule of rules) {
    if (rule.type === "endpoint") {
      const endpointOrUndefined = evaluateEndpointRule(rule, options);
      if (endpointOrUndefined) {
        return endpointOrUndefined;
      }
    } else if (rule.type === "error") {
      evaluateErrorRule(rule, options);
    } else if (rule.type === "tree") {
      const endpointOrUndefined = evaluateTreeRule(rule, options);
      if (endpointOrUndefined) {
        return endpointOrUndefined;
      }
    } else {
      throw new EndpointError(`Unknown endpoint rule: ${rule}`);
    }
  }
  throw new EndpointError(`Rules evaluation failed`);
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/resolveEndpoint.js
var resolveEndpoint = (ruleSetObject, options) => {
  const { endpointParams, logger: logger3 } = options;
  const { parameters, rules } = ruleSetObject;
  options.logger?.debug?.(debugId, `Initial EndpointParams: ${toDebugString(endpointParams)}`);
  const paramsWithDefault = Object.entries(parameters).filter(([, v7]) => v7.default != null).map(([k10, v7]) => [k10, v7.default]);
  if (paramsWithDefault.length > 0) {
    for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
      endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
    }
  }
  const requiredParams = Object.entries(parameters).filter(([, v7]) => v7.required).map(([k10]) => k10);
  for (const requiredParam of requiredParams) {
    if (endpointParams[requiredParam] == null) {
      throw new EndpointError(`Missing required parameter: '${requiredParam}'`);
    }
  }
  const endpoint = evaluateRules(rules, { endpointParams, logger: logger3, referenceRecord: {} });
  if (options.endpointParams?.Endpoint) {
    try {
      const givenEndpoint = new URL(options.endpointParams.Endpoint);
      const { protocol, port } = givenEndpoint;
      endpoint.url.protocol = protocol;
      endpoint.url.port = port;
    } catch (e10) {
    }
  }
  options.logger?.debug?.(debugId, `Resolved endpoint: ${toDebugString(endpoint)}`);
  return endpoint;
};

// ../../node_modules/@aws-sdk/client-sso/dist-es/endpoint/ruleset.js
var p = "required";
var q = "fn";
var r = "argv";
var s = "ref";
var a = "PartitionResult";
var b = "tree";
var c = "error";
var d = "endpoint";
var e = { [p]: false, "type": "String" };
var f = { [p]: true, "default": false, "type": "Boolean" };
var g = { [s]: "Endpoint" };
var h = { [q]: "booleanEquals", [r]: [{ [s]: "UseFIPS" }, true] };
var i = { [q]: "booleanEquals", [r]: [{ [s]: "UseDualStack" }, true] };
var j = {};
var k = { [q]: "booleanEquals", [r]: [true, { [q]: "getAttr", [r]: [{ [s]: a }, "supportsFIPS"] }] };
var l = { [q]: "booleanEquals", [r]: [true, { [q]: "getAttr", [r]: [{ [s]: a }, "supportsDualStack"] }] };
var m = [g];
var n = [h];
var o = [i];
var _data = { version: "1.0", parameters: { Region: e, UseDualStack: f, UseFIPS: f, Endpoint: e }, rules: [{ conditions: [{ [q]: "aws.partition", [r]: [{ [s]: "Region" }], assign: a }], type: b, rules: [{ conditions: [{ [q]: "isSet", [r]: m }, { [q]: "parseURL", [r]: m, assign: "url" }], type: b, rules: [{ conditions: n, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c }, { type: b, rules: [{ conditions: o, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c }, { endpoint: { url: g, properties: j, headers: j }, type: d }] }] }, { conditions: [h, i], type: b, rules: [{ conditions: [k, l], type: b, rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j, headers: j }, type: d }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c }] }, { conditions: n, type: b, rules: [{ conditions: [k], type: b, rules: [{ type: b, rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}", properties: j, headers: j }, type: d }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c }] }, { conditions: o, type: b, rules: [{ conditions: [l], type: b, rules: [{ endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j, headers: j }, type: d }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c }] }, { endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}", properties: j, headers: j }, type: d }] }] };
var ruleSet = _data;

// ../../node_modules/@aws-sdk/client-sso/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver = (endpointParams, context = {}) => {
  return resolveEndpoint(ruleSet, {
    endpointParams,
    logger: context.logger
  });
};

// ../../node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.shared.js
var getRuntimeConfig = (config) => ({
  apiVersion: "2019-06-10",
  base64Decoder: config?.base64Decoder ?? fromBase64,
  base64Encoder: config?.base64Encoder ?? toBase64,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver,
  logger: config?.logger ?? new NoOpLogger(),
  serviceId: config?.serviceId ?? "SSO",
  urlParser: config?.urlParser ?? parseUrl,
  utf8Decoder: config?.utf8Decoder ?? fromUtf84,
  utf8Encoder: config?.utf8Encoder ?? toUtf84
});

// ../../node_modules/@aws-sdk/util-defaults-mode-node/dist-es/constants.js
var AWS_EXECUTION_ENV = "AWS_EXECUTION_ENV";
var AWS_REGION_ENV = "AWS_REGION";
var AWS_DEFAULT_REGION_ENV = "AWS_DEFAULT_REGION";
var ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
var DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];
var IMDS_REGION_PATH = "/latest/meta-data/placement/region";

// ../../node_modules/@aws-sdk/util-defaults-mode-node/dist-es/defaultsModeConfig.js
var AWS_DEFAULTS_MODE_ENV = "AWS_DEFAULTS_MODE";
var AWS_DEFAULTS_MODE_CONFIG = "defaults_mode";
var NODE_DEFAULTS_MODE_CONFIG_OPTIONS = {
  environmentVariableSelector: (env3) => {
    return env3[AWS_DEFAULTS_MODE_ENV];
  },
  configFileSelector: (profile) => {
    return profile[AWS_DEFAULTS_MODE_CONFIG];
  },
  default: "legacy"
};

// ../../node_modules/@aws-sdk/util-defaults-mode-node/dist-es/resolveDefaultsModeConfig.js
var resolveDefaultsModeConfig = ({ region = loadConfig(NODE_REGION_CONFIG_OPTIONS), defaultsMode = loadConfig(NODE_DEFAULTS_MODE_CONFIG_OPTIONS) } = {}) => memoize(async () => {
  const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
  switch (mode?.toLowerCase()) {
    case "auto":
      return resolveNodeDefaultsModeAuto(region);
    case "in-region":
    case "cross-region":
    case "mobile":
    case "standard":
    case "legacy":
      return Promise.resolve(mode?.toLocaleLowerCase());
    case void 0:
      return Promise.resolve("legacy");
    default:
      throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
  }
});
var resolveNodeDefaultsModeAuto = async (clientRegion) => {
  if (clientRegion) {
    const resolvedRegion = typeof clientRegion === "function" ? await clientRegion() : clientRegion;
    const inferredRegion = await inferPhysicalRegion();
    if (!inferredRegion) {
      return "standard";
    }
    if (resolvedRegion === inferredRegion) {
      return "in-region";
    } else {
      return "cross-region";
    }
  }
  return "standard";
};
var inferPhysicalRegion = async () => {
  if (process.env[AWS_EXECUTION_ENV] && (process.env[AWS_REGION_ENV] || process.env[AWS_DEFAULT_REGION_ENV])) {
    return process.env[AWS_REGION_ENV] ?? process.env[AWS_DEFAULT_REGION_ENV];
  }
  if (!process.env[ENV_IMDS_DISABLED]) {
    try {
      const endpoint = await getInstanceMetadataEndpoint();
      return (await httpRequest({ ...endpoint, path: IMDS_REGION_PATH })).toString();
    } catch (e10) {
    }
  }
};

// ../../node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.js
var getRuntimeConfig2 = (config) => {
  emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = resolveDefaultsModeConfig(config);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent({ serviceId: clientSharedValues.serviceId, clientVersion: package_default3.version }),
    maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
    region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
  };
};

// ../../node_modules/@aws-sdk/client-sso/dist-es/SSOClient.js
var SSOClient = class extends Client {
  constructor(configuration) {
    const _config_0 = getRuntimeConfig2(configuration);
    const _config_1 = resolveClientEndpointParameters3(_config_0);
    const _config_2 = resolveRegionConfig(_config_1);
    const _config_3 = resolveEndpointConfig(_config_2);
    const _config_4 = resolveRetryConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig(_config_4);
    const _config_6 = resolveUserAgentConfig(_config_5);
    super(_config_6);
    this.config = _config_6;
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
    this.middlewareStack.use(getUserAgentPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../../node_modules/@aws-sdk/token-providers/dist-es/constants.js
var EXPIRE_WINDOW_MS = 5 * 60 * 1e3;
var REFRESH_MESSAGE = `To refresh this SSO session run 'aws sso login' with the corresponding profile.`;

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/models/SSOOIDCServiceException.js
var SSOOIDCServiceException = class extends ServiceException {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, SSOOIDCServiceException.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/models/models_0.js
var AccessDeniedException = class extends SSOOIDCServiceException {
  constructor(opts) {
    super({
      name: "AccessDeniedException",
      $fault: "client",
      ...opts
    });
    this.name = "AccessDeniedException";
    this.$fault = "client";
    Object.setPrototypeOf(this, AccessDeniedException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var AuthorizationPendingException = class extends SSOOIDCServiceException {
  constructor(opts) {
    super({
      name: "AuthorizationPendingException",
      $fault: "client",
      ...opts
    });
    this.name = "AuthorizationPendingException";
    this.$fault = "client";
    Object.setPrototypeOf(this, AuthorizationPendingException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var ExpiredTokenException2 = class extends SSOOIDCServiceException {
  constructor(opts) {
    super({
      name: "ExpiredTokenException",
      $fault: "client",
      ...opts
    });
    this.name = "ExpiredTokenException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ExpiredTokenException2.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InternalServerException = class extends SSOOIDCServiceException {
  constructor(opts) {
    super({
      name: "InternalServerException",
      $fault: "server",
      ...opts
    });
    this.name = "InternalServerException";
    this.$fault = "server";
    Object.setPrototypeOf(this, InternalServerException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InvalidClientException = class extends SSOOIDCServiceException {
  constructor(opts) {
    super({
      name: "InvalidClientException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidClientException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidClientException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InvalidGrantException = class extends SSOOIDCServiceException {
  constructor(opts) {
    super({
      name: "InvalidGrantException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidGrantException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidGrantException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InvalidRequestException2 = class extends SSOOIDCServiceException {
  constructor(opts) {
    super({
      name: "InvalidRequestException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidRequestException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidRequestException2.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InvalidScopeException = class extends SSOOIDCServiceException {
  constructor(opts) {
    super({
      name: "InvalidScopeException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidScopeException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidScopeException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var SlowDownException = class extends SSOOIDCServiceException {
  constructor(opts) {
    super({
      name: "SlowDownException",
      $fault: "client",
      ...opts
    });
    this.name = "SlowDownException";
    this.$fault = "client";
    Object.setPrototypeOf(this, SlowDownException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var UnauthorizedClientException = class extends SSOOIDCServiceException {
  constructor(opts) {
    super({
      name: "UnauthorizedClientException",
      $fault: "client",
      ...opts
    });
    this.name = "UnauthorizedClientException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UnauthorizedClientException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var UnsupportedGrantTypeException = class extends SSOOIDCServiceException {
  constructor(opts) {
    super({
      name: "UnsupportedGrantTypeException",
      $fault: "client",
      ...opts
    });
    this.name = "UnsupportedGrantTypeException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UnsupportedGrantTypeException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var CreateTokenRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var CreateTokenResponseFilterSensitiveLog = (obj) => ({
  ...obj
});

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/protocols/Aws_restJson1.js
var serializeAws_restJson1CreateTokenCommand = async (input, context) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers = {
    "content-type": "application/json"
  };
  const resolvedPath2 = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}/token`;
  let body;
  body = JSON.stringify({
    ...input.clientId != null && { clientId: input.clientId },
    ...input.clientSecret != null && { clientSecret: input.clientSecret },
    ...input.code != null && { code: input.code },
    ...input.deviceCode != null && { deviceCode: input.deviceCode },
    ...input.grantType != null && { grantType: input.grantType },
    ...input.redirectUri != null && { redirectUri: input.redirectUri },
    ...input.refreshToken != null && { refreshToken: input.refreshToken },
    ...input.scope != null && { scope: serializeAws_restJson1Scopes(input.scope, context) }
  });
  return new HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath2,
    body
  });
};
var deserializeAws_restJson1CreateTokenCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateTokenCommandError(output, context);
  }
  const contents = map5({
    $metadata: deserializeMetadata5(output)
  });
  const data = expectNonNull(expectObject(await parseBody4(output.body, context)), "body");
  if (data.accessToken != null) {
    contents.accessToken = expectString(data.accessToken);
  }
  if (data.expiresIn != null) {
    contents.expiresIn = expectInt32(data.expiresIn);
  }
  if (data.idToken != null) {
    contents.idToken = expectString(data.idToken);
  }
  if (data.refreshToken != null) {
    contents.refreshToken = expectString(data.refreshToken);
  }
  if (data.tokenType != null) {
    contents.tokenType = expectString(data.tokenType);
  }
  return contents;
};
var deserializeAws_restJson1CreateTokenCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody4(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode2(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.ssooidc#AccessDeniedException":
      throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
    case "AuthorizationPendingException":
    case "com.amazonaws.ssooidc#AuthorizationPendingException":
      throw await deserializeAws_restJson1AuthorizationPendingExceptionResponse(parsedOutput, context);
    case "ExpiredTokenException":
    case "com.amazonaws.ssooidc#ExpiredTokenException":
      throw await deserializeAws_restJson1ExpiredTokenExceptionResponse(parsedOutput, context);
    case "InternalServerException":
    case "com.amazonaws.ssooidc#InternalServerException":
      throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
    case "InvalidClientException":
    case "com.amazonaws.ssooidc#InvalidClientException":
      throw await deserializeAws_restJson1InvalidClientExceptionResponse(parsedOutput, context);
    case "InvalidGrantException":
    case "com.amazonaws.ssooidc#InvalidGrantException":
      throw await deserializeAws_restJson1InvalidGrantExceptionResponse(parsedOutput, context);
    case "InvalidRequestException":
    case "com.amazonaws.ssooidc#InvalidRequestException":
      throw await deserializeAws_restJson1InvalidRequestExceptionResponse2(parsedOutput, context);
    case "InvalidScopeException":
    case "com.amazonaws.ssooidc#InvalidScopeException":
      throw await deserializeAws_restJson1InvalidScopeExceptionResponse(parsedOutput, context);
    case "SlowDownException":
    case "com.amazonaws.ssooidc#SlowDownException":
      throw await deserializeAws_restJson1SlowDownExceptionResponse(parsedOutput, context);
    case "UnauthorizedClientException":
    case "com.amazonaws.ssooidc#UnauthorizedClientException":
      throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
    case "UnsupportedGrantTypeException":
    case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
      throw await deserializeAws_restJson1UnsupportedGrantTypeExceptionResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: SSOOIDCServiceException,
        errorCode
      });
  }
};
var map5 = map2;
var deserializeAws_restJson1AccessDeniedExceptionResponse = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  if (data.error != null) {
    contents.error = expectString(data.error);
  }
  if (data.error_description != null) {
    contents.error_description = expectString(data.error_description);
  }
  const exception = new AccessDeniedException({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var deserializeAws_restJson1AuthorizationPendingExceptionResponse = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  if (data.error != null) {
    contents.error = expectString(data.error);
  }
  if (data.error_description != null) {
    contents.error_description = expectString(data.error_description);
  }
  const exception = new AuthorizationPendingException({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var deserializeAws_restJson1ExpiredTokenExceptionResponse = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  if (data.error != null) {
    contents.error = expectString(data.error);
  }
  if (data.error_description != null) {
    contents.error_description = expectString(data.error_description);
  }
  const exception = new ExpiredTokenException2({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var deserializeAws_restJson1InternalServerExceptionResponse = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  if (data.error != null) {
    contents.error = expectString(data.error);
  }
  if (data.error_description != null) {
    contents.error_description = expectString(data.error_description);
  }
  const exception = new InternalServerException({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var deserializeAws_restJson1InvalidClientExceptionResponse = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  if (data.error != null) {
    contents.error = expectString(data.error);
  }
  if (data.error_description != null) {
    contents.error_description = expectString(data.error_description);
  }
  const exception = new InvalidClientException({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var deserializeAws_restJson1InvalidGrantExceptionResponse = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  if (data.error != null) {
    contents.error = expectString(data.error);
  }
  if (data.error_description != null) {
    contents.error_description = expectString(data.error_description);
  }
  const exception = new InvalidGrantException({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var deserializeAws_restJson1InvalidRequestExceptionResponse2 = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  if (data.error != null) {
    contents.error = expectString(data.error);
  }
  if (data.error_description != null) {
    contents.error_description = expectString(data.error_description);
  }
  const exception = new InvalidRequestException2({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var deserializeAws_restJson1InvalidScopeExceptionResponse = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  if (data.error != null) {
    contents.error = expectString(data.error);
  }
  if (data.error_description != null) {
    contents.error_description = expectString(data.error_description);
  }
  const exception = new InvalidScopeException({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var deserializeAws_restJson1SlowDownExceptionResponse = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  if (data.error != null) {
    contents.error = expectString(data.error);
  }
  if (data.error_description != null) {
    contents.error_description = expectString(data.error_description);
  }
  const exception = new SlowDownException({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var deserializeAws_restJson1UnauthorizedClientExceptionResponse = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  if (data.error != null) {
    contents.error = expectString(data.error);
  }
  if (data.error_description != null) {
    contents.error_description = expectString(data.error_description);
  }
  const exception = new UnauthorizedClientException({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var deserializeAws_restJson1UnsupportedGrantTypeExceptionResponse = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  if (data.error != null) {
    contents.error = expectString(data.error);
  }
  if (data.error_description != null) {
    contents.error_description = expectString(data.error_description);
  }
  const exception = new UnsupportedGrantTypeException({
    $metadata: deserializeMetadata5(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var serializeAws_restJson1Scopes = (input, context) => {
  return input.filter((e10) => e10 != null).map((entry) => {
    return entry;
  });
};
var deserializeMetadata5 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
var collectBody5 = (streamBody = new Uint8Array(), context) => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
var collectBodyString5 = (streamBody, context) => collectBody5(streamBody, context).then((body) => context.utf8Encoder(body));
var parseBody4 = (streamBody, context) => collectBodyString5(streamBody, context).then((encoded) => {
  if (encoded.length) {
    return JSON.parse(encoded);
  }
  return {};
});
var parseErrorBody4 = async (errorBody, context) => {
  const value = await parseBody4(errorBody, context);
  value.message = value.message ?? value.Message;
  return value;
};
var loadRestJsonErrorCode2 = (output, data) => {
  const findKey = (object2, key) => Object.keys(object2).find((k10) => k10.toLowerCase() === key.toLowerCase());
  const sanitizeErrorCode = (rawValue) => {
    let cleanValue = rawValue;
    if (typeof cleanValue === "number") {
      cleanValue = cleanValue.toString();
    }
    if (cleanValue.indexOf(",") >= 0) {
      cleanValue = cleanValue.split(",")[0];
    }
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  };
  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== void 0) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }
  if (data.code !== void 0) {
    return sanitizeErrorCode(data.code);
  }
  if (data["__type"] !== void 0) {
    return sanitizeErrorCode(data["__type"]);
  }
};

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/commands/CreateTokenCommand.js
var CreateTokenCommand = class extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, CreateTokenCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SSOOIDCClient";
    const commandName = "CreateTokenCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: CreateTokenRequestFilterSensitiveLog,
      outputFilterSensitiveLog: CreateTokenResponseFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_restJson1CreateTokenCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_restJson1CreateTokenCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters4 = (options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "awsssooidc"
  };
};

// ../../node_modules/@aws-sdk/client-sso-oidc/package.json
var package_default4 = {
  name: "@aws-sdk/client-sso-oidc",
  description: "AWS SDK for JavaScript Sso Oidc Client for Node.js, Browser and React Native",
  version: "3.272.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo sso-oidc"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/config-resolver": "3.272.0",
    "@aws-sdk/fetch-http-handler": "3.272.0",
    "@aws-sdk/hash-node": "3.272.0",
    "@aws-sdk/invalid-dependency": "3.272.0",
    "@aws-sdk/middleware-content-length": "3.272.0",
    "@aws-sdk/middleware-endpoint": "3.272.0",
    "@aws-sdk/middleware-host-header": "3.272.0",
    "@aws-sdk/middleware-logger": "3.272.0",
    "@aws-sdk/middleware-recursion-detection": "3.272.0",
    "@aws-sdk/middleware-retry": "3.272.0",
    "@aws-sdk/middleware-serde": "3.272.0",
    "@aws-sdk/middleware-stack": "3.272.0",
    "@aws-sdk/middleware-user-agent": "3.272.0",
    "@aws-sdk/node-config-provider": "3.272.0",
    "@aws-sdk/node-http-handler": "3.272.0",
    "@aws-sdk/protocol-http": "3.272.0",
    "@aws-sdk/smithy-client": "3.272.0",
    "@aws-sdk/types": "3.272.0",
    "@aws-sdk/url-parser": "3.272.0",
    "@aws-sdk/util-base64": "3.208.0",
    "@aws-sdk/util-body-length-browser": "3.188.0",
    "@aws-sdk/util-body-length-node": "3.208.0",
    "@aws-sdk/util-defaults-mode-browser": "3.272.0",
    "@aws-sdk/util-defaults-mode-node": "3.272.0",
    "@aws-sdk/util-endpoints": "3.272.0",
    "@aws-sdk/util-retry": "3.272.0",
    "@aws-sdk/util-user-agent-browser": "3.272.0",
    "@aws-sdk/util-user-agent-node": "3.272.0",
    "@aws-sdk/util-utf8": "3.254.0",
    tslib: "^2.3.1"
  },
  devDependencies: {
    "@aws-sdk/service-client-documentation-generator": "3.208.0",
    "@tsconfig/node14": "1.0.3",
    "@types/node": "^14.14.31",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.19.2",
    typescript: "~4.6.2"
  },
  overrides: {
    typedoc: {
      typescript: "~4.6.2"
    }
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso-oidc",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-sso-oidc"
  }
};

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/ruleset.js
var p2 = "required";
var q2 = "fn";
var r2 = "argv";
var s2 = "ref";
var a2 = "PartitionResult";
var b2 = "tree";
var c2 = "error";
var d2 = "endpoint";
var e2 = { [p2]: false, "type": "String" };
var f2 = { [p2]: true, "default": false, "type": "Boolean" };
var g2 = { [s2]: "Endpoint" };
var h2 = { [q2]: "booleanEquals", [r2]: [{ [s2]: "UseFIPS" }, true] };
var i2 = { [q2]: "booleanEquals", [r2]: [{ [s2]: "UseDualStack" }, true] };
var j2 = {};
var k2 = { [q2]: "booleanEquals", [r2]: [true, { [q2]: "getAttr", [r2]: [{ [s2]: a2 }, "supportsFIPS"] }] };
var l2 = { [q2]: "booleanEquals", [r2]: [true, { [q2]: "getAttr", [r2]: [{ [s2]: a2 }, "supportsDualStack"] }] };
var m2 = [g2];
var n2 = [h2];
var o2 = [i2];
var _data2 = { version: "1.0", parameters: { Region: e2, UseDualStack: f2, UseFIPS: f2, Endpoint: e2 }, rules: [{ conditions: [{ [q2]: "aws.partition", [r2]: [{ [s2]: "Region" }], assign: a2 }], type: b2, rules: [{ conditions: [{ [q2]: "isSet", [r2]: m2 }, { [q2]: "parseURL", [r2]: m2, assign: "url" }], type: b2, rules: [{ conditions: n2, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c2 }, { type: b2, rules: [{ conditions: o2, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c2 }, { endpoint: { url: g2, properties: j2, headers: j2 }, type: d2 }] }] }, { conditions: [h2, i2], type: b2, rules: [{ conditions: [k2, l2], type: b2, rules: [{ endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j2, headers: j2 }, type: d2 }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c2 }] }, { conditions: n2, type: b2, rules: [{ conditions: [k2], type: b2, rules: [{ type: b2, rules: [{ endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}", properties: j2, headers: j2 }, type: d2 }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c2 }] }, { conditions: o2, type: b2, rules: [{ conditions: [l2], type: b2, rules: [{ endpoint: { url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j2, headers: j2 }, type: d2 }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c2 }] }, { endpoint: { url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}", properties: j2, headers: j2 }, type: d2 }] }] };
var ruleSet2 = _data2;

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver2 = (endpointParams, context = {}) => {
  return resolveEndpoint(ruleSet2, {
    endpointParams,
    logger: context.logger
  });
};

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/runtimeConfig.shared.js
var getRuntimeConfig3 = (config) => ({
  apiVersion: "2019-06-10",
  base64Decoder: config?.base64Decoder ?? fromBase64,
  base64Encoder: config?.base64Encoder ?? toBase64,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver2,
  logger: config?.logger ?? new NoOpLogger(),
  serviceId: config?.serviceId ?? "SSO OIDC",
  urlParser: config?.urlParser ?? parseUrl,
  utf8Decoder: config?.utf8Decoder ?? fromUtf84,
  utf8Encoder: config?.utf8Encoder ?? toUtf84
});

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/runtimeConfig.js
var getRuntimeConfig4 = (config) => {
  emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = resolveDefaultsModeConfig(config);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig3(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent({ serviceId: clientSharedValues.serviceId, clientVersion: package_default4.version }),
    maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
    region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
  };
};

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/SSOOIDCClient.js
var SSOOIDCClient = class extends Client {
  constructor(configuration) {
    const _config_0 = getRuntimeConfig4(configuration);
    const _config_1 = resolveClientEndpointParameters4(_config_0);
    const _config_2 = resolveRegionConfig(_config_1);
    const _config_3 = resolveEndpointConfig(_config_2);
    const _config_4 = resolveRetryConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig(_config_4);
    const _config_6 = resolveUserAgentConfig(_config_5);
    super(_config_6);
    this.config = _config_6;
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
    this.middlewareStack.use(getUserAgentPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../../node_modules/@aws-sdk/token-providers/dist-es/getSsoOidcClient.js
var ssoOidcClientsHash = {};
var getSsoOidcClient = (ssoRegion) => {
  if (ssoOidcClientsHash[ssoRegion]) {
    return ssoOidcClientsHash[ssoRegion];
  }
  const ssoOidcClient = new SSOOIDCClient({ region: ssoRegion });
  ssoOidcClientsHash[ssoRegion] = ssoOidcClient;
  return ssoOidcClient;
};

// ../../node_modules/@aws-sdk/token-providers/dist-es/getNewSsoOidcToken.js
var getNewSsoOidcToken = (ssoToken, ssoRegion) => {
  const ssoOidcClient = getSsoOidcClient(ssoRegion);
  return ssoOidcClient.send(new CreateTokenCommand({
    clientId: ssoToken.clientId,
    clientSecret: ssoToken.clientSecret,
    refreshToken: ssoToken.refreshToken,
    grantType: "refresh_token"
  }));
};

// ../../node_modules/@aws-sdk/token-providers/dist-es/validateTokenExpiry.js
var validateTokenExpiry = (token) => {
  if (token.expiration && token.expiration.getTime() < Date.now()) {
    throw new TokenProviderError(`Token is expired. ${REFRESH_MESSAGE}`, false);
  }
};

// ../../node_modules/@aws-sdk/token-providers/dist-es/validateTokenKey.js
var validateTokenKey = (key, value, forRefresh = false) => {
  if (typeof value === "undefined") {
    throw new TokenProviderError(`Value not present for '${key}' in SSO Token${forRefresh ? ". Cannot refresh" : ""}. ${REFRESH_MESSAGE}`, false);
  }
};

// ../../node_modules/@aws-sdk/token-providers/dist-es/writeSSOTokenToFile.js
var import_fs5 = require("fs");
var { writeFile } = import_fs5.promises;
var writeSSOTokenToFile = (id, ssoToken) => {
  const tokenFilepath = getSSOTokenFilepath(id);
  const tokenString = JSON.stringify(ssoToken, null, 2);
  return writeFile(tokenFilepath, tokenString);
};

// ../../node_modules/@aws-sdk/token-providers/dist-es/fromSso.js
var lastRefreshAttemptTime = /* @__PURE__ */ new Date(0);
var fromSso = (init = {}) => async () => {
  const profiles = await parseKnownFiles(init);
  const profileName = getProfileName(init);
  const profile = profiles[profileName];
  if (!profile) {
    throw new TokenProviderError(`Profile '${profileName}' could not be found in shared credentials file.`, false);
  } else if (!profile["sso_session"]) {
    throw new TokenProviderError(`Profile '${profileName}' is missing required property 'sso_session'.`);
  }
  const ssoSessionName = profile["sso_session"];
  const ssoSessions = await loadSsoSessionData(init);
  const ssoSession = ssoSessions[ssoSessionName];
  if (!ssoSession) {
    throw new TokenProviderError(`Sso session '${ssoSessionName}' could not be found in shared credentials file.`, false);
  }
  for (const ssoSessionRequiredKey of ["sso_start_url", "sso_region"]) {
    if (!ssoSession[ssoSessionRequiredKey]) {
      throw new TokenProviderError(`Sso session '${ssoSessionName}' is missing required property '${ssoSessionRequiredKey}'.`, false);
    }
  }
  const ssoStartUrl = ssoSession["sso_start_url"];
  const ssoRegion = ssoSession["sso_region"];
  let ssoToken;
  try {
    ssoToken = await getSSOTokenFromFile(ssoSessionName);
  } catch (e10) {
    throw new TokenProviderError(`The SSO session token associated with profile=${profileName} was not found or is invalid. ${REFRESH_MESSAGE}`, false);
  }
  validateTokenKey("accessToken", ssoToken.accessToken);
  validateTokenKey("expiresAt", ssoToken.expiresAt);
  const { accessToken, expiresAt } = ssoToken;
  const existingToken = { token: accessToken, expiration: new Date(expiresAt) };
  if (existingToken.expiration.getTime() - Date.now() > EXPIRE_WINDOW_MS) {
    return existingToken;
  }
  if (Date.now() - lastRefreshAttemptTime.getTime() < 30 * 1e3) {
    validateTokenExpiry(existingToken);
    return existingToken;
  }
  validateTokenKey("clientId", ssoToken.clientId, true);
  validateTokenKey("clientSecret", ssoToken.clientSecret, true);
  validateTokenKey("refreshToken", ssoToken.refreshToken, true);
  try {
    lastRefreshAttemptTime.setTime(Date.now());
    const newSsoOidcToken = await getNewSsoOidcToken(ssoToken, ssoRegion);
    validateTokenKey("accessToken", newSsoOidcToken.accessToken);
    validateTokenKey("expiresIn", newSsoOidcToken.expiresIn);
    const newTokenExpiration = new Date(Date.now() + newSsoOidcToken.expiresIn * 1e3);
    try {
      await writeSSOTokenToFile(ssoSessionName, {
        ...ssoToken,
        accessToken: newSsoOidcToken.accessToken,
        expiresAt: newTokenExpiration.toISOString(),
        refreshToken: newSsoOidcToken.refreshToken
      });
    } catch (error) {
    }
    return {
      token: newSsoOidcToken.accessToken,
      expiration: newTokenExpiration
    };
  } catch (error) {
    validateTokenExpiry(existingToken);
    return existingToken;
  }
};

// ../../node_modules/@aws-sdk/credential-provider-sso/dist-es/resolveSSOCredentials.js
var EXPIRE_WINDOW_MS2 = 15 * 60 * 1e3;
var SHOULD_FAIL_CREDENTIAL_CHAIN = false;
var resolveSSOCredentials = async ({ ssoStartUrl, ssoSession, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, profile }) => {
  let token;
  const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;
  if (ssoSession) {
    try {
      const _token = await fromSso({ profile })();
      token = {
        accessToken: _token.token,
        expiresAt: new Date(_token.expiration).toISOString()
      };
    } catch (e10) {
      throw new CredentialsProviderError(e10.message, SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
  } else {
    try {
      token = await getSSOTokenFromFile(ssoStartUrl);
    } catch (e10) {
      throw new CredentialsProviderError(`The SSO session associated with this profile is invalid. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
  }
  if (new Date(token.expiresAt).getTime() - Date.now() <= EXPIRE_WINDOW_MS2) {
    throw new CredentialsProviderError(`The SSO session associated with this profile has expired. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);
  }
  const { accessToken } = token;
  const sso = ssoClient || new SSOClient({ region: ssoRegion });
  let ssoResp;
  try {
    ssoResp = await sso.send(new GetRoleCredentialsCommand({
      accountId: ssoAccountId,
      roleName: ssoRoleName,
      accessToken
    }));
  } catch (e10) {
    throw CredentialsProviderError.from(e10, SHOULD_FAIL_CREDENTIAL_CHAIN);
  }
  const { roleCredentials: { accessKeyId, secretAccessKey, sessionToken, expiration } = {} } = ssoResp;
  if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {
    throw new CredentialsProviderError("SSO returns an invalid temporary credential.", SHOULD_FAIL_CREDENTIAL_CHAIN);
  }
  return { accessKeyId, secretAccessKey, sessionToken, expiration: new Date(expiration) };
};

// ../../node_modules/@aws-sdk/credential-provider-sso/dist-es/validateSsoProfile.js
var validateSsoProfile = (profile) => {
  const { sso_start_url, sso_account_id, sso_region, sso_role_name } = profile;
  if (!sso_start_url || !sso_account_id || !sso_region || !sso_role_name) {
    throw new CredentialsProviderError(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(profile).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, false);
  }
  return profile;
};

// ../../node_modules/@aws-sdk/credential-provider-sso/dist-es/fromSSO.js
var fromSSO = (init = {}) => async () => {
  const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, ssoSession } = init;
  const profileName = getProfileName(init);
  if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
    const profiles = await parseKnownFiles(init);
    const profile = profiles[profileName];
    if (!profile) {
      throw new CredentialsProviderError(`Profile ${profileName} was not found.`);
    }
    if (!isSsoProfile(profile)) {
      throw new CredentialsProviderError(`Profile ${profileName} is not configured with SSO credentials.`);
    }
    if (profile?.sso_session) {
      const ssoSessions = await loadSsoSessionData(init);
      const session = ssoSessions[profile.sso_session];
      const conflictMsg = ` configurations in profile ${profileName} and sso-session ${profile.sso_session}`;
      if (ssoRegion && ssoRegion !== session.sso_region) {
        throw new CredentialsProviderError(`Conflicting SSO region` + conflictMsg, false);
      }
      if (ssoStartUrl && ssoStartUrl !== session.sso_start_url) {
        throw new CredentialsProviderError(`Conflicting SSO start_url` + conflictMsg, false);
      }
      profile.sso_region = session.sso_region;
      profile.sso_start_url = session.sso_start_url;
    }
    const { sso_start_url, sso_account_id, sso_region, sso_role_name, sso_session } = validateSsoProfile(profile);
    return resolveSSOCredentials({
      ssoStartUrl: sso_start_url,
      ssoSession: sso_session,
      ssoAccountId: sso_account_id,
      ssoRegion: sso_region,
      ssoRoleName: sso_role_name,
      ssoClient,
      profile: profileName
    });
  } else if (!ssoStartUrl || !ssoAccountId || !ssoRegion || !ssoRoleName) {
    throw new CredentialsProviderError('Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"');
  } else {
    return resolveSSOCredentials({
      ssoStartUrl,
      ssoSession,
      ssoAccountId,
      ssoRegion,
      ssoRoleName,
      ssoClient,
      profile: profileName
    });
  }
};

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveSsoCredentials.js
var resolveSsoCredentials = (data) => {
  const { sso_start_url, sso_account_id, sso_session, sso_region, sso_role_name } = validateSsoProfile(data);
  return fromSSO({
    ssoStartUrl: sso_start_url,
    ssoAccountId: sso_account_id,
    ssoSession: sso_session,
    ssoRegion: sso_region,
    ssoRoleName: sso_role_name
  })();
};

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveStaticCredentials.js
var isStaticCredsProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.aws_access_key_id === "string" && typeof arg.aws_secret_access_key === "string" && ["undefined", "string"].indexOf(typeof arg.aws_session_token) > -1;
var resolveStaticCredentials = (profile) => Promise.resolve({
  accessKeyId: profile.aws_access_key_id,
  secretAccessKey: profile.aws_secret_access_key,
  sessionToken: profile.aws_session_token
});

// ../../node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromTokenFile.js
var import_fs6 = require("fs");

// ../../node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromWebToken.js
var fromWebToken = (init) => () => {
  const { roleArn, roleSessionName, webIdentityToken, providerId, policyArns, policy, durationSeconds, roleAssumerWithWebIdentity } = init;
  if (!roleAssumerWithWebIdentity) {
    throw new CredentialsProviderError(`Role Arn '${roleArn}' needs to be assumed with web identity, but no role assumption callback was provided.`, false);
  }
  return roleAssumerWithWebIdentity({
    RoleArn: roleArn,
    RoleSessionName: roleSessionName ?? `aws-sdk-js-session-${Date.now()}`,
    WebIdentityToken: webIdentityToken,
    ProviderId: providerId,
    PolicyArns: policyArns,
    Policy: policy,
    DurationSeconds: durationSeconds
  });
};

// ../../node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromTokenFile.js
var ENV_TOKEN_FILE = "AWS_WEB_IDENTITY_TOKEN_FILE";
var ENV_ROLE_ARN = "AWS_ROLE_ARN";
var ENV_ROLE_SESSION_NAME = "AWS_ROLE_SESSION_NAME";
var fromTokenFile = (init = {}) => async () => {
  return resolveTokenFile(init);
};
var resolveTokenFile = (init) => {
  const webIdentityTokenFile = init?.webIdentityTokenFile ?? process.env[ENV_TOKEN_FILE];
  const roleArn = init?.roleArn ?? process.env[ENV_ROLE_ARN];
  const roleSessionName = init?.roleSessionName ?? process.env[ENV_ROLE_SESSION_NAME];
  if (!webIdentityTokenFile || !roleArn) {
    throw new CredentialsProviderError("Web identity configuration not specified");
  }
  return fromWebToken({
    ...init,
    webIdentityToken: (0, import_fs6.readFileSync)(webIdentityTokenFile, { encoding: "ascii" }),
    roleArn,
    roleSessionName
  })();
};

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveWebIdentityCredentials.js
var isWebIdentityProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.web_identity_token_file === "string" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1;
var resolveWebIdentityCredentials = async (profile, options) => fromTokenFile({
  webIdentityTokenFile: profile.web_identity_token_file,
  roleArn: profile.role_arn,
  roleSessionName: profile.role_session_name,
  roleAssumerWithWebIdentity: options.roleAssumerWithWebIdentity
})();

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveProfileData.js
var resolveProfileData = async (profileName, profiles, options, visitedProfiles = {}) => {
  const data = profiles[profileName];
  if (Object.keys(visitedProfiles).length > 0 && isStaticCredsProfile(data)) {
    return resolveStaticCredentials(data);
  }
  if (isAssumeRoleProfile(data)) {
    return resolveAssumeRoleCredentials(profileName, profiles, options, visitedProfiles);
  }
  if (isStaticCredsProfile(data)) {
    return resolveStaticCredentials(data);
  }
  if (isWebIdentityProfile(data)) {
    return resolveWebIdentityCredentials(data, options);
  }
  if (isProcessProfile(data)) {
    return resolveProcessCredentials2(options, profileName);
  }
  if (isSsoProfile(data)) {
    return resolveSsoCredentials(data);
  }
  throw new CredentialsProviderError(`Profile ${profileName} could not be found or parsed in shared credentials file.`);
};

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/fromIni.js
var fromIni = (init = {}) => async () => {
  const profiles = await parseKnownFiles(init);
  return resolveProfileData(getProfileName(init), profiles, init);
};

// ../../node_modules/@aws-sdk/credential-provider-node/dist-es/remoteProvider.js
var ENV_IMDS_DISABLED2 = "AWS_EC2_METADATA_DISABLED";
var remoteProvider = (init) => {
  if (process.env[ENV_CMDS_RELATIVE_URI] || process.env[ENV_CMDS_FULL_URI]) {
    return fromContainerMetadata(init);
  }
  if (process.env[ENV_IMDS_DISABLED2]) {
    return async () => {
      throw new CredentialsProviderError("EC2 Instance Metadata Service access disabled");
    };
  }
  return fromInstanceMetadata(init);
};

// ../../node_modules/@aws-sdk/credential-provider-node/dist-es/defaultProvider.js
var defaultProvider = (init = {}) => memoize(chain(...init.profile || process.env[ENV_PROFILE] ? [] : [fromEnv()], fromSSO(init), fromIni(init), fromProcess(init), fromTokenFile(init), remoteProvider(init), async () => {
  throw new CredentialsProviderError("Could not load credentials from any providers", false);
}), (credentials2) => credentials2.expiration !== void 0 && credentials2.expiration.getTime() - Date.now() < 3e5, (credentials2) => credentials2.expiration !== void 0);

// ../../node_modules/@aws-sdk/client-sts/dist-es/endpoint/ruleset.js
var G = "required";
var H = "type";
var I = "fn";
var J = "argv";
var K = "ref";
var L = "properties";
var M = "headers";
var a3 = false;
var b3 = true;
var c3 = "PartitionResult";
var d3 = "tree";
var e3 = "booleanEquals";
var f3 = "stringEquals";
var g3 = "sigv4";
var h3 = "us-east-1";
var i3 = "sts";
var j3 = "endpoint";
var k3 = "https://sts.{Region}.{PartitionResult#dnsSuffix}";
var l3 = "error";
var m3 = "getAttr";
var n3 = { [G]: false, [H]: "String" };
var o3 = { [G]: true, "default": false, [H]: "Boolean" };
var p3 = { [K]: "Region" };
var q3 = { [K]: "UseFIPS" };
var r3 = { [K]: "UseDualStack" };
var s3 = { [I]: "isSet", [J]: [{ [K]: "Endpoint" }] };
var t = { [K]: "Endpoint" };
var u = { "url": "https://sts.amazonaws.com", [L]: { "authSchemes": [{ "name": g3, "signingRegion": h3, "signingName": i3 }] }, [M]: {} };
var v = {};
var w = { "conditions": [{ [I]: f3, [J]: [p3, "aws-global"] }], [j3]: u, [H]: j3 };
var x = { [I]: e3, [J]: [q3, true] };
var y = { [I]: e3, [J]: [r3, true] };
var z = { [I]: e3, [J]: [true, { [I]: m3, [J]: [{ [K]: c3 }, "supportsFIPS"] }] };
var A = { [K]: c3 };
var B = { [I]: e3, [J]: [true, { [I]: m3, [J]: [A, "supportsDualStack"] }] };
var C = { "url": k3, [L]: {}, [M]: {} };
var D = [t];
var E = [x];
var F = [y];
var _data3 = { version: "1.0", parameters: { Region: n3, UseDualStack: o3, UseFIPS: o3, Endpoint: n3, UseGlobalEndpoint: o3 }, rules: [{ conditions: [{ [I]: "aws.partition", [J]: [p3], assign: c3 }], [H]: d3, rules: [{ conditions: [{ [I]: e3, [J]: [{ [K]: "UseGlobalEndpoint" }, b3] }, { [I]: e3, [J]: [q3, a3] }, { [I]: e3, [J]: [r3, a3] }, { [I]: "not", [J]: [s3] }], [H]: d3, rules: [{ conditions: [{ [I]: f3, [J]: [p3, "ap-northeast-1"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "ap-south-1"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "ap-southeast-1"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "ap-southeast-2"] }], endpoint: u, [H]: j3 }, w, { conditions: [{ [I]: f3, [J]: [p3, "ca-central-1"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "eu-central-1"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "eu-north-1"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "eu-west-1"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "eu-west-2"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "eu-west-3"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "sa-east-1"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, h3] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "us-east-2"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "us-west-1"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "us-west-2"] }], endpoint: u, [H]: j3 }, { endpoint: { url: k3, [L]: { authSchemes: [{ name: g3, signingRegion: "{Region}", signingName: i3 }] }, [M]: v }, [H]: j3 }] }, { conditions: [s3, { [I]: "parseURL", [J]: D, assign: "url" }], [H]: d3, rules: [{ conditions: E, error: "Invalid Configuration: FIPS and custom endpoint are not supported", [H]: l3 }, { [H]: d3, rules: [{ conditions: F, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", [H]: l3 }, { endpoint: { url: t, [L]: v, [M]: v }, [H]: j3 }] }] }, { conditions: [x, y], [H]: d3, rules: [{ conditions: [z, B], [H]: d3, rules: [{ endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", [L]: v, [M]: v }, [H]: j3 }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", [H]: l3 }] }, { conditions: E, [H]: d3, rules: [{ conditions: [z], [H]: d3, rules: [{ [H]: d3, rules: [{ conditions: [{ [I]: f3, [J]: ["aws-us-gov", { [I]: m3, [J]: [A, "name"] }] }], endpoint: C, [H]: j3 }, { endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}", [L]: v, [M]: v }, [H]: j3 }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", [H]: l3 }] }, { conditions: F, [H]: d3, rules: [{ conditions: [B], [H]: d3, rules: [{ endpoint: { url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}", [L]: v, [M]: v }, [H]: j3 }] }, { error: "DualStack is enabled but this partition does not support DualStack", [H]: l3 }] }, { [H]: d3, rules: [w, { endpoint: C, [H]: j3 }] }] }] };
var ruleSet3 = _data3;

// ../../node_modules/@aws-sdk/client-sts/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver3 = (endpointParams, context = {}) => {
  return resolveEndpoint(ruleSet3, {
    endpointParams,
    logger: context.logger
  });
};

// ../../node_modules/@aws-sdk/client-sts/dist-es/runtimeConfig.shared.js
var getRuntimeConfig5 = (config) => ({
  apiVersion: "2011-06-15",
  base64Decoder: config?.base64Decoder ?? fromBase64,
  base64Encoder: config?.base64Encoder ?? toBase64,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver3,
  logger: config?.logger ?? new NoOpLogger(),
  serviceId: config?.serviceId ?? "STS",
  urlParser: config?.urlParser ?? parseUrl,
  utf8Decoder: config?.utf8Decoder ?? fromUtf84,
  utf8Encoder: config?.utf8Encoder ?? toUtf84
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/runtimeConfig.js
var getRuntimeConfig6 = (config) => {
  emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = resolveDefaultsModeConfig(config);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig5(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
    credentialDefaultProvider: config?.credentialDefaultProvider ?? decorateDefaultCredentialProvider(defaultProvider),
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent({ serviceId: clientSharedValues.serviceId, clientVersion: package_default2.version }),
    maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
    region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
  };
};

// ../../node_modules/@aws-sdk/client-sts/dist-es/STSClient.js
var STSClient = class extends Client {
  constructor(configuration) {
    const _config_0 = getRuntimeConfig6(configuration);
    const _config_1 = resolveClientEndpointParameters2(_config_0);
    const _config_2 = resolveRegionConfig(_config_1);
    const _config_3 = resolveEndpointConfig(_config_2);
    const _config_4 = resolveRetryConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig(_config_4);
    const _config_6 = resolveStsAuthConfig(_config_5, { stsClientCtor: STSClient });
    const _config_7 = resolveUserAgentConfig(_config_6);
    super(_config_7);
    this.config = _config_7;
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
    this.middlewareStack.use(getUserAgentPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../../node_modules/@aws-sdk/client-sts/dist-es/defaultRoleAssumers.js
var getCustomizableStsClientCtor = (baseCtor, customizations) => {
  if (!customizations)
    return baseCtor;
  else
    return class CustomizableSTSClient extends baseCtor {
      constructor(config) {
        super(config);
        for (const customization of customizations) {
          this.middlewareStack.use(customization);
        }
      }
    };
};
var getDefaultRoleAssumer2 = (stsOptions = {}, stsPlugins) => getDefaultRoleAssumer(stsOptions, getCustomizableStsClientCtor(STSClient, stsPlugins));
var getDefaultRoleAssumerWithWebIdentity2 = (stsOptions = {}, stsPlugins) => getDefaultRoleAssumerWithWebIdentity(stsOptions, getCustomizableStsClientCtor(STSClient, stsPlugins));
var decorateDefaultCredentialProvider2 = (provider) => (input) => provider({
  roleAssumer: getDefaultRoleAssumer2(input),
  roleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity2(input),
  ...input
});

// ../../node_modules/@aws-sdk/eventstream-codec/dist-es/EventStreamCodec.js
var import_crc323 = __toESM(require_build2());

// ../../node_modules/@aws-sdk/eventstream-codec/dist-es/Int64.js
var Int64 = class {
  constructor(bytes) {
    this.bytes = bytes;
    if (bytes.byteLength !== 8) {
      throw new Error("Int64 buffers must be exactly 8 bytes");
    }
  }
  static fromNumber(number2) {
    if (number2 > 9223372036854776e3 || number2 < -9223372036854776e3) {
      throw new Error(`${number2} is too large (or, if negative, too small) to represent as an Int64`);
    }
    const bytes = new Uint8Array(8);
    for (let i10 = 7, remaining = Math.abs(Math.round(number2)); i10 > -1 && remaining > 0; i10--, remaining /= 256) {
      bytes[i10] = remaining;
    }
    if (number2 < 0) {
      negate(bytes);
    }
    return new Int64(bytes);
  }
  valueOf() {
    const bytes = this.bytes.slice(0);
    const negative = bytes[0] & 128;
    if (negative) {
      negate(bytes);
    }
    return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);
  }
  toString() {
    return String(this.valueOf());
  }
};
function negate(bytes) {
  for (let i10 = 0; i10 < 8; i10++) {
    bytes[i10] ^= 255;
  }
  for (let i10 = 7; i10 > -1; i10--) {
    bytes[i10]++;
    if (bytes[i10] !== 0)
      break;
  }
}

// ../../node_modules/@aws-sdk/eventstream-codec/dist-es/HeaderMarshaller.js
var HeaderMarshaller = class {
  constructor(toUtf85, fromUtf85) {
    this.toUtf8 = toUtf85;
    this.fromUtf8 = fromUtf85;
  }
  format(headers) {
    const chunks = [];
    for (const headerName of Object.keys(headers)) {
      const bytes = this.fromUtf8(headerName);
      chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
    }
    const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
    let position = 0;
    for (const chunk2 of chunks) {
      out.set(chunk2, position);
      position += chunk2.byteLength;
    }
    return out;
  }
  formatHeaderValue(header) {
    switch (header.type) {
      case "boolean":
        return Uint8Array.from([header.value ? 0 : 1]);
      case "byte":
        return Uint8Array.from([2, header.value]);
      case "short":
        const shortView = new DataView(new ArrayBuffer(3));
        shortView.setUint8(0, 3);
        shortView.setInt16(1, header.value, false);
        return new Uint8Array(shortView.buffer);
      case "integer":
        const intView = new DataView(new ArrayBuffer(5));
        intView.setUint8(0, 4);
        intView.setInt32(1, header.value, false);
        return new Uint8Array(intView.buffer);
      case "long":
        const longBytes = new Uint8Array(9);
        longBytes[0] = 5;
        longBytes.set(header.value.bytes, 1);
        return longBytes;
      case "binary":
        const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
        binView.setUint8(0, 6);
        binView.setUint16(1, header.value.byteLength, false);
        const binBytes = new Uint8Array(binView.buffer);
        binBytes.set(header.value, 3);
        return binBytes;
      case "string":
        const utf8Bytes = this.fromUtf8(header.value);
        const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
        strView.setUint8(0, 7);
        strView.setUint16(1, utf8Bytes.byteLength, false);
        const strBytes = new Uint8Array(strView.buffer);
        strBytes.set(utf8Bytes, 3);
        return strBytes;
      case "timestamp":
        const tsBytes = new Uint8Array(9);
        tsBytes[0] = 8;
        tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
        return tsBytes;
      case "uuid":
        if (!UUID_PATTERN.test(header.value)) {
          throw new Error(`Invalid UUID received: ${header.value}`);
        }
        const uuidBytes = new Uint8Array(17);
        uuidBytes[0] = 9;
        uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
        return uuidBytes;
    }
  }
  parse(headers) {
    const out = {};
    let position = 0;
    while (position < headers.byteLength) {
      const nameLength = headers.getUint8(position++);
      const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));
      position += nameLength;
      switch (headers.getUint8(position++)) {
        case 0:
          out[name] = {
            type: BOOLEAN_TAG,
            value: true
          };
          break;
        case 1:
          out[name] = {
            type: BOOLEAN_TAG,
            value: false
          };
          break;
        case 2:
          out[name] = {
            type: BYTE_TAG,
            value: headers.getInt8(position++)
          };
          break;
        case 3:
          out[name] = {
            type: SHORT_TAG,
            value: headers.getInt16(position, false)
          };
          position += 2;
          break;
        case 4:
          out[name] = {
            type: INT_TAG,
            value: headers.getInt32(position, false)
          };
          position += 4;
          break;
        case 5:
          out[name] = {
            type: LONG_TAG,
            value: new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8))
          };
          position += 8;
          break;
        case 6:
          const binaryLength = headers.getUint16(position, false);
          position += 2;
          out[name] = {
            type: BINARY_TAG,
            value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength)
          };
          position += binaryLength;
          break;
        case 7:
          const stringLength = headers.getUint16(position, false);
          position += 2;
          out[name] = {
            type: STRING_TAG,
            value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength))
          };
          position += stringLength;
          break;
        case 8:
          out[name] = {
            type: TIMESTAMP_TAG,
            value: new Date(new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf())
          };
          position += 8;
          break;
        case 9:
          const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);
          position += 16;
          out[name] = {
            type: UUID_TAG,
            value: `${toHex(uuidBytes.subarray(0, 4))}-${toHex(uuidBytes.subarray(4, 6))}-${toHex(uuidBytes.subarray(6, 8))}-${toHex(uuidBytes.subarray(8, 10))}-${toHex(uuidBytes.subarray(10))}`
          };
          break;
        default:
          throw new Error(`Unrecognized header type tag`);
      }
    }
    return out;
  }
};
var HEADER_VALUE_TYPE;
(function(HEADER_VALUE_TYPE2) {
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolTrue"] = 0] = "boolTrue";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolFalse"] = 1] = "boolFalse";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byte"] = 2] = "byte";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["short"] = 3] = "short";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["integer"] = 4] = "integer";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["long"] = 5] = "long";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byteArray"] = 6] = "byteArray";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["string"] = 7] = "string";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["timestamp"] = 8] = "timestamp";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["uuid"] = 9] = "uuid";
})(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
var BOOLEAN_TAG = "boolean";
var BYTE_TAG = "byte";
var SHORT_TAG = "short";
var INT_TAG = "integer";
var LONG_TAG = "long";
var BINARY_TAG = "binary";
var STRING_TAG = "string";
var TIMESTAMP_TAG = "timestamp";
var UUID_TAG = "uuid";
var UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;

// ../../node_modules/@aws-sdk/eventstream-codec/dist-es/splitMessage.js
var import_crc322 = __toESM(require_build2());
var PRELUDE_MEMBER_LENGTH = 4;
var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
var CHECKSUM_LENGTH = 4;
var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
function splitMessage({ byteLength, byteOffset, buffer }) {
  if (byteLength < MINIMUM_MESSAGE_LENGTH) {
    throw new Error("Provided message too short to accommodate event stream message overhead");
  }
  const view = new DataView(buffer, byteOffset, byteLength);
  const messageLength = view.getUint32(0, false);
  if (byteLength !== messageLength) {
    throw new Error("Reported message length does not match received message length");
  }
  const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);
  const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);
  const expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);
  const checksummer = new import_crc322.Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));
  if (expectedPreludeChecksum !== checksummer.digest()) {
    throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);
  }
  checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));
  if (expectedMessageChecksum !== checksummer.digest()) {
    throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);
  }
  return {
    headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),
    body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH))
  };
}

// ../../node_modules/@aws-sdk/eventstream-codec/dist-es/EventStreamCodec.js
var EventStreamCodec = class {
  constructor(toUtf85, fromUtf85) {
    this.headerMarshaller = new HeaderMarshaller(toUtf85, fromUtf85);
  }
  encode({ headers: rawHeaders, body }) {
    const headers = this.headerMarshaller.format(rawHeaders);
    const length = headers.byteLength + body.byteLength + 16;
    const out = new Uint8Array(length);
    const view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    const checksum = new import_crc323.Crc32();
    view.setUint32(0, length, false);
    view.setUint32(4, headers.byteLength, false);
    view.setUint32(8, checksum.update(out.subarray(0, 8)).digest(), false);
    out.set(headers, 12);
    out.set(body, headers.byteLength + 12);
    view.setUint32(length - 4, checksum.update(out.subarray(8, length - 4)).digest(), false);
    return out;
  }
  decode(message) {
    const { headers, body } = splitMessage(message);
    return { headers: this.headerMarshaller.parse(headers), body };
  }
  formatHeaders(rawHeaders) {
    return this.headerMarshaller.format(rawHeaders);
  }
};

// ../../node_modules/@aws-sdk/eventstream-serde-universal/dist-es/getChunkedStream.js
function getChunkedStream(source) {
  let currentMessageTotalLength = 0;
  let currentMessagePendingLength = 0;
  let currentMessage = null;
  let messageLengthBuffer = null;
  const allocateMessage = (size) => {
    if (typeof size !== "number") {
      throw new Error("Attempted to allocate an event message where size was not a number: " + size);
    }
    currentMessageTotalLength = size;
    currentMessagePendingLength = 4;
    currentMessage = new Uint8Array(size);
    const currentMessageView = new DataView(currentMessage.buffer);
    currentMessageView.setUint32(0, size, false);
  };
  const iterator = async function* () {
    const sourceIterator = source[Symbol.asyncIterator]();
    while (true) {
      const { value, done } = await sourceIterator.next();
      if (done) {
        if (!currentMessageTotalLength) {
          return;
        } else if (currentMessageTotalLength === currentMessagePendingLength) {
          yield currentMessage;
        } else {
          throw new Error("Truncated event message received.");
        }
        return;
      }
      const chunkLength = value.length;
      let currentOffset = 0;
      while (currentOffset < chunkLength) {
        if (!currentMessage) {
          const bytesRemaining = chunkLength - currentOffset;
          if (!messageLengthBuffer) {
            messageLengthBuffer = new Uint8Array(4);
          }
          const numBytesForTotal = Math.min(4 - currentMessagePendingLength, bytesRemaining);
          messageLengthBuffer.set(value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);
          currentMessagePendingLength += numBytesForTotal;
          currentOffset += numBytesForTotal;
          if (currentMessagePendingLength < 4) {
            break;
          }
          allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));
          messageLengthBuffer = null;
        }
        const numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, chunkLength - currentOffset);
        currentMessage.set(value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);
        currentMessagePendingLength += numBytesToWrite;
        currentOffset += numBytesToWrite;
        if (currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength) {
          yield currentMessage;
          currentMessage = null;
          currentMessageTotalLength = 0;
          currentMessagePendingLength = 0;
        }
      }
    }
  };
  return {
    [Symbol.asyncIterator]: iterator
  };
}

// ../../node_modules/@aws-sdk/eventstream-serde-universal/dist-es/getUnmarshalledStream.js
function getUnmarshalledStream(source, options) {
  return {
    [Symbol.asyncIterator]: async function* () {
      for await (const chunk2 of source) {
        const message = options.eventStreamCodec.decode(chunk2);
        const { value: messageType } = message.headers[":message-type"];
        if (messageType === "error") {
          const unmodeledError = new Error(message.headers[":error-message"].value || "UnknownError");
          unmodeledError.name = message.headers[":error-code"].value;
          throw unmodeledError;
        } else if (messageType === "exception") {
          const code = message.headers[":exception-type"].value;
          const exception = { [code]: message };
          const deserializedException = await options.deserializer(exception);
          if (deserializedException.$unknown) {
            const error = new Error(options.toUtf8(message.body));
            error.name = code;
            throw error;
          }
          throw deserializedException[code];
        } else if (messageType === "event") {
          const event = {
            [message.headers[":event-type"].value]: message
          };
          const deserialized = await options.deserializer(event);
          if (deserialized.$unknown)
            continue;
          yield deserialized;
        } else {
          throw Error(`Unrecognizable event type: ${message.headers[":event-type"].value}`);
        }
      }
    }
  };
}

// ../../node_modules/@aws-sdk/eventstream-serde-universal/dist-es/EventStreamMarshaller.js
var EventStreamMarshaller = class {
  constructor({ utf8Encoder, utf8Decoder }) {
    this.eventStreamCodec = new EventStreamCodec(utf8Encoder, utf8Decoder);
    this.utfEncoder = utf8Encoder;
  }
  deserialize(body, deserializer) {
    const chunkedStream = getChunkedStream(body);
    const unmarshalledStream = getUnmarshalledStream(chunkedStream, {
      eventStreamCodec: this.eventStreamCodec,
      deserializer,
      toUtf8: this.utfEncoder
    });
    return unmarshalledStream;
  }
  serialize(input, serializer) {
    const self2 = this;
    const serializedIterator = async function* () {
      for await (const chunk2 of input) {
        const payloadBuf = self2.eventStreamCodec.encode(serializer(chunk2));
        yield payloadBuf;
      }
      yield new Uint8Array(0);
    };
    return {
      [Symbol.asyncIterator]: serializedIterator
    };
  }
};

// ../../node_modules/@aws-sdk/eventstream-serde-node/dist-es/EventStreamMarshaller.js
var import_stream3 = require("stream");

// ../../node_modules/@aws-sdk/eventstream-serde-node/dist-es/utils.js
async function* readabletoIterable(readStream) {
  let streamEnded = false;
  let generationEnded = false;
  const records = new Array();
  readStream.on("error", (err) => {
    if (!streamEnded) {
      streamEnded = true;
    }
    if (err) {
      throw err;
    }
  });
  readStream.on("data", (data) => {
    records.push(data);
  });
  readStream.on("end", () => {
    streamEnded = true;
  });
  while (!generationEnded) {
    const value = await new Promise((resolve) => setTimeout(() => resolve(records.shift()), 0));
    if (value) {
      yield value;
    }
    generationEnded = streamEnded && records.length === 0;
  }
}

// ../../node_modules/@aws-sdk/eventstream-serde-node/dist-es/EventStreamMarshaller.js
var EventStreamMarshaller2 = class {
  constructor({ utf8Encoder, utf8Decoder }) {
    this.universalMarshaller = new EventStreamMarshaller({
      utf8Decoder,
      utf8Encoder
    });
  }
  deserialize(body, deserializer) {
    const bodyIterable = typeof body[Symbol.asyncIterator] === "function" ? body : readabletoIterable(body);
    return this.universalMarshaller.deserialize(bodyIterable, deserializer);
  }
  serialize(input, serializer) {
    return import_stream3.Readable.from(this.universalMarshaller.serialize(input, serializer));
  }
};

// ../../node_modules/@aws-sdk/eventstream-serde-node/dist-es/provider.js
var eventStreamSerdeProvider = (options) => new EventStreamMarshaller2(options);

// ../../node_modules/@aws-sdk/hash-stream-node/dist-es/HashCalculator.js
var import_stream4 = require("stream");
var HashCalculator = class extends import_stream4.Writable {
  constructor(hash2, options) {
    super(options);
    this.hash = hash2;
  }
  _write(chunk2, encoding, callback) {
    try {
      this.hash.update(toUint8Array(chunk2));
    } catch (err) {
      return callback(err);
    }
    callback();
  }
};

// ../../node_modules/@aws-sdk/hash-stream-node/dist-es/readableStreamHasher.js
var readableStreamHasher = (hashCtor, readableStream) => {
  if (readableStream.readableFlowing !== null) {
    throw new Error("Unable to calculate hash for flowing readable stream");
  }
  const hash2 = new hashCtor();
  const hashCalculator = new HashCalculator(hash2);
  readableStream.pipe(hashCalculator);
  return new Promise((resolve, reject) => {
    readableStream.on("error", (err) => {
      hashCalculator.end();
      reject(err);
    });
    hashCalculator.on("error", reject);
    hashCalculator.on("finish", () => {
      hash2.digest().then(resolve).catch(reject);
    });
  });
};

// ../../node_modules/@aws-sdk/middleware-bucket-endpoint/dist-es/NodeUseArnRegionConfigOptions.js
var NODE_USE_ARN_REGION_ENV_NAME = "AWS_S3_USE_ARN_REGION";
var NODE_USE_ARN_REGION_INI_NAME = "s3_use_arn_region";
var NODE_USE_ARN_REGION_CONFIG_OPTIONS = {
  environmentVariableSelector: (env3) => booleanSelector(env3, NODE_USE_ARN_REGION_ENV_NAME, SelectorType.ENV),
  configFileSelector: (profile) => booleanSelector(profile, NODE_USE_ARN_REGION_INI_NAME, SelectorType.CONFIG),
  default: false
};

// ../../node_modules/@aws-sdk/util-stream-node/dist-es/getAwsChunkedEncodingStream.js
var import_stream5 = require("stream");
var getAwsChunkedEncodingStream = (readableStream, options) => {
  const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
  const checksumRequired = base64Encoder !== void 0 && checksumAlgorithmFn !== void 0 && checksumLocationName !== void 0 && streamHasher !== void 0;
  const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : void 0;
  const awsChunkedEncodingStream = new import_stream5.Readable({ read: () => {
  } });
  readableStream.on("data", (data) => {
    awsChunkedEncodingStream.push(`${(bodyLengthChecker(data) || 0).toString(16)}\r
${data.toString()}\r
`);
  });
  readableStream.on("end", async () => {
    awsChunkedEncodingStream.push(`0\r
`);
    if (checksumRequired) {
      const checksum = base64Encoder(await digest);
      awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum}\r
`);
      awsChunkedEncodingStream.push(`\r
`);
    }
    awsChunkedEncodingStream.push(null);
  });
  return awsChunkedEncodingStream;
};

// ../../node_modules/@aws-sdk/util-stream-node/dist-es/sdk-stream-mixin.js
var import_stream6 = require("stream");
var import_util4 = require("util");
var ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
var sdkStreamMixin = (stream) => {
  if (!(stream instanceof import_stream6.Readable)) {
    const name = stream?.__proto__?.constructor?.name || stream;
    throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
  }
  let transformed = false;
  const transformToByteArray = async () => {
    if (transformed) {
      throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
    }
    transformed = true;
    return await streamCollector(stream);
  };
  return Object.assign(stream, {
    transformToByteArray,
    transformToString: async (encoding) => {
      const buf = await transformToByteArray();
      if (encoding === void 0 || Buffer.isEncoding(encoding)) {
        return fromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
      } else {
        const decoder = new import_util4.TextDecoder(encoding);
        return decoder.decode(buf);
      }
    },
    transformToWebStream: () => {
      if (transformed) {
        throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
      }
      if (stream.readableFlowing !== null) {
        throw new Error("The stream has been consumed by other callbacks.");
      }
      if (typeof import_stream6.Readable.toWeb !== "function") {
        throw new Error("Readable.toWeb() is not supported. Please make sure you are using Node.js >= 17.0.0, or polyfill is available.");
      }
      transformed = true;
      return import_stream6.Readable.toWeb(stream);
    }
  });
};

// ../../node_modules/@aws-sdk/signature-v4-multi-region/dist-es/SignatureV4MultiRegion.js
var SignatureV4MultiRegion = class {
  constructor(options) {
    this.sigv4Signer = new SignatureV4(options);
    this.signerOptions = options;
  }
  async sign(requestToSign, options = {}) {
    if (options.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().sign(requestToSign, options);
    }
    return this.sigv4Signer.sign(requestToSign, options);
  }
  async presign(originalRequest, options = {}) {
    if (options.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().presign(originalRequest, options);
    }
    return this.sigv4Signer.presign(originalRequest, options);
  }
  getSigv4aSigner() {
    if (!this.sigv4aSigner) {
      let CrtSignerV4;
      try {
        CrtSignerV4 = typeof require === "function" && require("@aws-sdk/signature-v4-crt").CrtSignerV4;
        if (typeof CrtSignerV4 !== "function")
          throw new Error();
      } catch (e10) {
        e10.message = `${e10.message}
Please check if you have installed "@aws-sdk/signature-v4-crt" package explicitly. 
For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`;
        throw e10;
      }
      this.sigv4aSigner = new CrtSignerV4({
        ...this.signerOptions,
        signingAlgorithm: 1
      });
    }
    return this.sigv4aSigner;
  }
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/endpoint/ruleset.js
var bV = "required";
var bW = "type";
var bX = "rules";
var bY = "conditions";
var bZ = "fn";
var ca = "argv";
var cb = "ref";
var cc = "assign";
var cd = "url";
var ce = "properties";
var cf = "authSchemes";
var cg = "signingRegion";
var ch = "signingName";
var ci = "disableDoubleEncoding";
var cj = "headers";
var a4 = false;
var b4 = true;
var c4 = "tree";
var d4 = "isSet";
var e4 = "substring";
var f4 = "hardwareType";
var g4 = "regionPrefix";
var h4 = "abbaSuffix";
var i4 = "outpostId";
var j4 = "aws.partition";
var k4 = "stringEquals";
var l4 = "isValidHostLabel";
var m4 = "not";
var n4 = "error";
var o4 = "parseURL";
var p4 = "s3-outposts";
var q4 = "endpoint";
var r4 = "booleanEquals";
var s4 = "aws.parseArn";
var t2 = "s3";
var u2 = "aws.isVirtualHostableS3Bucket";
var v2 = "getAttr";
var w2 = "name";
var x2 = "Host override cannot be combined with Dualstack, FIPS, or S3 Accelerate";
var y2 = "https://{Bucket}.s3.{partitionResult#dnsSuffix}";
var z2 = "bucketArn";
var A2 = "arnType";
var B2 = "";
var C2 = "s3-object-lambda";
var D2 = "accesspoint";
var E2 = "accessPointName";
var F2 = "{url#scheme}://{accessPointName}-{bucketArn#accountId}.{url#authority}{url#path}";
var G2 = "mrapPartition";
var H2 = "outpostType";
var I2 = "arnPrefix";
var J2 = "{url#scheme}://{url#authority}{url#path}";
var K2 = "https://s3.{partitionResult#dnsSuffix}";
var L2 = { [bV]: false, [bW]: "String" };
var M2 = { [bV]: true, "default": false, [bW]: "Boolean" };
var N = { [bV]: false, [bW]: "Boolean" };
var O = { [bZ]: d4, [ca]: [{ [cb]: "Bucket" }] };
var P = { [cb]: "Bucket" };
var Q = { [cb]: f4 };
var R = { [bY]: [{ [bZ]: m4, [ca]: [{ [bZ]: d4, [ca]: [{ [cb]: "Endpoint" }] }] }], [n4]: "Expected a endpoint to be specified but no endpoint was found", [bW]: n4 };
var S = { [bZ]: m4, [ca]: [{ [bZ]: d4, [ca]: [{ [cb]: "Endpoint" }] }] };
var T = { [bZ]: d4, [ca]: [{ [cb]: "Endpoint" }] };
var U = { [bZ]: o4, [ca]: [{ [cb]: "Endpoint" }], [cc]: "url" };
var V = { [cf]: [{ [w2]: "sigv4", [cg]: "{Region}", [ch]: p4, [ci]: true }] };
var W = {};
var X = { [cb]: "ForcePathStyle" };
var Y = { [bY]: [{ [bZ]: "uriEncode", [ca]: [P], [cc]: "uri_encoded_bucket" }], [bW]: c4, [bX]: [{ [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, true] }, T], [n4]: "Cannot set dual-stack in combination with a custom endpoint.", [bW]: n4 }, { [bW]: c4, [bX]: [{ [bY]: [{ [bZ]: j4, [ca]: [{ [cb]: "Region" }], [cc]: "partitionResult" }], [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "Accelerate" }, false] }], [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, true] }, S, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }, { [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, true] }, S, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }, { [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, true] }, S, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: m4, [ca]: [{ [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r4, [ca]: [{ [cb]: "UseGlobalEndpoint" }, true] }], [bW]: c4, [bX]: [{ [q4]: { [cd]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "{Region}", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }] }, { [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, true] }, S, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: m4, [ca]: [{ [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r4, [ca]: [{ [cb]: "UseGlobalEndpoint" }, false] }], [q4]: { [cd]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "{Region}", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }, { [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, false] }, T, U, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }, { [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, false] }, T, U, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }, { [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, false] }, T, U, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: m4, [ca]: [{ [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r4, [ca]: [{ [cb]: "UseGlobalEndpoint" }, true] }], [bW]: c4, [bX]: [{ [q4]: { [cd]: "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "{Region}", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }] }, { [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, false] }, T, U, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: m4, [ca]: [{ [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r4, [ca]: [{ [cb]: "UseGlobalEndpoint" }, false] }], [q4]: { [cd]: "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "{Region}", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }, { [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, false] }, S, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }, { [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, false] }, S, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }, { [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, false] }, S, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: m4, [ca]: [{ [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r4, [ca]: [{ [cb]: "UseGlobalEndpoint" }, true] }], [bW]: c4, [bX]: [{ [q4]: { [cd]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "{Region}", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }] }, { [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, false] }, S, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, true] }, { [bZ]: m4, [ca]: [{ [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r4, [ca]: [{ [cb]: "UseGlobalEndpoint" }, false] }], [q4]: { [cd]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "{Region}", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }, { [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, true] }, S, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }, { [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, true] }, S, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }, { [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, true] }, S, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: m4, [ca]: [{ [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r4, [ca]: [{ [cb]: "UseGlobalEndpoint" }, true] }], [bW]: c4, [bX]: [{ [q4]: { [cd]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "{Region}", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }] }, { [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, true] }, S, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: m4, [ca]: [{ [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r4, [ca]: [{ [cb]: "UseGlobalEndpoint" }, false] }], [q4]: { [cd]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "{Region}", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }, { [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, false] }, T, U, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }, { [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, false] }, T, U, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }, { [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, false] }, T, U, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: m4, [ca]: [{ [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r4, [ca]: [{ [cb]: "UseGlobalEndpoint" }, true] }], [bW]: c4, [bX]: [{ [bY]: [{ [bZ]: k4, [ca]: [{ [cb]: "Region" }, "us-east-1"] }], [q4]: { [cd]: "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "{Region}", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }, { [q4]: { [cd]: "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "{Region}", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }] }, { [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, false] }, T, U, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: m4, [ca]: [{ [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r4, [ca]: [{ [cb]: "UseGlobalEndpoint" }, false] }], [q4]: { [cd]: "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "{Region}", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }, { [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, false] }, S, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }, { [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, false] }, S, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }, { [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, false] }, S, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: m4, [ca]: [{ [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r4, [ca]: [{ [cb]: "UseGlobalEndpoint" }, true] }], [bW]: c4, [bX]: [{ [bY]: [{ [bZ]: k4, [ca]: [{ [cb]: "Region" }, "us-east-1"] }], [q4]: { [cd]: "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "{Region}", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }, { [q4]: { [cd]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "{Region}", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }] }, { [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, false] }, S, { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, false] }, { [bZ]: m4, [ca]: [{ [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }] }, { [bZ]: r4, [ca]: [{ [cb]: "UseGlobalEndpoint" }, false] }], [q4]: { [cd]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "{Region}", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 }] }] }, { [n4]: "Path-style addressing cannot be used with S3 Accelerate", [bW]: n4 }] }] }, { [n4]: "A valid partition could not be determined", [bW]: n4 }] }] };
var Z = { [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, true] };
var aa = { [bZ]: r4, [ca]: [{ [cb]: "Accelerate" }, false] };
var ab = { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, true] };
var ac = { [bZ]: m4, [ca]: [{ [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }] };
var ad = { [bZ]: r4, [ca]: [{ [cb]: "UseGlobalEndpoint" }, true] };
var ae = { [cf]: [{ [w2]: "sigv4", [cg]: "{Region}", [ch]: t2, [ci]: true }] };
var af = { [bZ]: r4, [ca]: [{ [cb]: "UseGlobalEndpoint" }, false] };
var ag = { [bZ]: r4, [ca]: [{ [cb]: "UseDualStack" }, false] };
var ah = { [bZ]: r4, [ca]: [{ [cb]: "UseFIPS" }, false] };
var ai = { [n4]: "A valid partition could not be determined", [bW]: n4 };
var aj = { [bY]: [ab, { [bZ]: k4, [ca]: [{ [bZ]: v2, [ca]: [{ [cb]: "partitionResult" }, w2] }, "aws-cn"] }], [n4]: "Partition does not support FIPS", [bW]: n4 };
var ak = { [bZ]: k4, [ca]: [{ [bZ]: v2, [ca]: [{ [cb]: "partitionResult" }, w2] }, "aws-cn"] };
var al = { [bZ]: r4, [ca]: [{ [cb]: "Accelerate" }, true] };
var am = { [bY]: [Z, ab, aa, S, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: "https://{Bucket}.s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 };
var an = { [cd]: "https://{Bucket}.s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [ce]: ae, [cj]: {} };
var ao = { [bY]: [ag, ab, aa, S, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: "https://{Bucket}.s3-fips.us-east-1.{partitionResult#dnsSuffix}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 };
var ap = { [cd]: "https://{Bucket}.s3-fips.{Region}.{partitionResult#dnsSuffix}", [ce]: ae, [cj]: {} };
var aq = { [bY]: [Z, ah, al, S, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: "https://{Bucket}.s3-accelerate.dualstack.us-east-1.{partitionResult#dnsSuffix}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 };
var ar = { [cd]: "https://{Bucket}.s3-accelerate.dualstack.{partitionResult#dnsSuffix}", [ce]: ae, [cj]: {} };
var as = { [bY]: [Z, ah, aa, S, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: "https://{Bucket}.s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 };
var at = { [cd]: "https://{Bucket}.s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [ce]: ae, [cj]: {} };
var au = { [bY]: [ag, ah, aa, T, U, { [bZ]: r4, [ca]: [{ [bZ]: v2, [ca]: [{ [cb]: "url" }, "isIp"] }, true] }, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 };
var av = { [bZ]: r4, [ca]: [{ [bZ]: v2, [ca]: [{ [cb]: "url" }, "isIp"] }, true] };
var aw = { [cb]: "url" };
var ax = { [bY]: [ag, ah, aa, T, U, { [bZ]: r4, [ca]: [{ [bZ]: v2, [ca]: [aw, "isIp"] }, false] }, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: "{url#scheme}://{Bucket}.{url#authority}{url#path}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 };
var ay = { [bZ]: r4, [ca]: [{ [bZ]: v2, [ca]: [aw, "isIp"] }, false] };
var az = { [cd]: "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}", [ce]: ae, [cj]: {} };
var aA = { [cd]: "{url#scheme}://{Bucket}.{url#authority}{url#path}", [ce]: ae, [cj]: {} };
var aB = { [q4]: aA, [bW]: q4 };
var aC = { [bY]: [ag, ah, al, S, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 };
var aD = { [cd]: "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}", [ce]: ae, [cj]: {} };
var aE = { [bY]: [ag, ah, aa, S, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: y2, [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 };
var aF = { [cd]: "https://{Bucket}.s3.{Region}.{partitionResult#dnsSuffix}", [ce]: ae, [cj]: {} };
var aG = { [n4]: "Invalid region: region was not a valid DNS name.", [bW]: n4 };
var aH = { [cb]: z2 };
var aI = { [cb]: A2 };
var aJ = { [bZ]: v2, [ca]: [aH, "service"] };
var aK = { [cb]: E2 };
var aL = { [bY]: [Z], [n4]: "S3 Object Lambda does not support Dual-stack", [bW]: n4 };
var aM = { [bY]: [al], [n4]: "S3 Object Lambda does not support S3 Accelerate", [bW]: n4 };
var aN = { [bY]: [{ [bZ]: d4, [ca]: [{ [cb]: "DisableAccessPoints" }] }, { [bZ]: r4, [ca]: [{ [cb]: "DisableAccessPoints" }, true] }], [n4]: "Access points are not supported for this operation", [bW]: n4 };
var aO = { [bY]: [{ [bZ]: d4, [ca]: [{ [cb]: "UseArnRegion" }] }, { [bZ]: r4, [ca]: [{ [cb]: "UseArnRegion" }, false] }, { [bZ]: m4, [ca]: [{ [bZ]: k4, [ca]: [{ [bZ]: v2, [ca]: [aH, "region"] }, "{Region}"] }] }], [n4]: "Invalid configuration: region from ARN `{bucketArn#region}` does not match client region `{Region}` and UseArnRegion is `false`", [bW]: n4 };
var aP = { [bZ]: v2, [ca]: [{ [cb]: "bucketPartition" }, w2] };
var aQ = { [bZ]: v2, [ca]: [aH, "accountId"] };
var aR = { [bY]: [ab, { [bZ]: k4, [ca]: [aP, "aws-cn"] }], [n4]: "Partition does not support FIPS", [bW]: n4 };
var aS = { [cf]: [{ [w2]: "sigv4", [cg]: "{bucketArn#region}", [ch]: C2, [ci]: true }] };
var aT = { [n4]: "Invalid ARN: The access point name may only contain a-z, A-Z, 0-9 and `-`. Found: `{accessPointName}`", [bW]: n4 };
var aU = { [n4]: "Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `{bucketArn#accountId}`", [bW]: n4 };
var aV = { [n4]: "Invalid region in ARN: `{bucketArn#region}` (invalid DNS name)", [bW]: n4 };
var aW = { [n4]: "Client was configured for partition `{partitionResult#name}` but ARN (`{Bucket}`) has `{bucketPartition#name}`", [bW]: n4 };
var aX = { [n4]: "Could not load partition for ARN region `{bucketArn#region}`", [bW]: n4 };
var aY = { [n4]: "Invalid ARN: The ARN may only contain a single resource component after `accesspoint`.", [bW]: n4 };
var aZ = { [n4]: "Invalid ARN: bucket ARN is missing a region", [bW]: n4 };
var ba = { [n4]: "Invalid ARN: Expected a resource of the format `accesspoint:<accesspoint name>` but no name was provided", [bW]: n4 };
var bb = { [cf]: [{ [w2]: "sigv4", [cg]: "{bucketArn#region}", [ch]: t2, [ci]: true }] };
var bc = { [cf]: [{ [w2]: "sigv4", [cg]: "{bucketArn#region}", [ch]: p4, [ci]: true }] };
var bd = { [cb]: "UseObjectLambdaEndpoint" };
var be = { [cf]: [{ [w2]: "sigv4", [cg]: "{Region}", [ch]: C2, [ci]: true }] };
var bf = { [bY]: [ab, Z, T, U, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: J2, [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 };
var bg = { [q4]: { [cd]: J2, [ce]: ae, [cj]: {} }, [bW]: q4 };
var bh = { [cd]: J2, [ce]: ae, [cj]: {} };
var bi = { [bY]: [ab, Z, S, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 };
var bj = { [cd]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [ce]: ae, [cj]: {} };
var bk = { [bY]: [ab, ag, T, U, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: J2, [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 };
var bl = { [bY]: [ab, ag, S, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 };
var bm = { [cd]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}", [ce]: ae, [cj]: {} };
var bn = { [bY]: [ah, Z, T, U, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: J2, [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 };
var bo = { [bY]: [ah, Z, S, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 };
var bp = { [cd]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [ce]: ae, [cj]: {} };
var bq = { [bY]: [ah, ag, T, U, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: J2, [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 };
var br = { [bY]: [ah, ag, S, { [bZ]: k4, [ca]: [{ [cb]: "Region" }, "aws-global"] }], [q4]: { [cd]: K2, [ce]: { [cf]: [{ [w2]: "sigv4", [cg]: "us-east-1", [ch]: t2, [ci]: true }] }, [cj]: {} }, [bW]: q4 };
var bs = { [cd]: "https://s3.{Region}.{partitionResult#dnsSuffix}", [ce]: ae, [cj]: {} };
var bt = [{ [cb]: "Region" }];
var bu = [P];
var bv = [{ [bZ]: l4, [ca]: [{ [cb]: i4 }, false] }];
var bw = [{ [bZ]: k4, [ca]: [{ [cb]: g4 }, "beta"] }];
var bx = [{ [cb]: "Endpoint" }];
var by = [T, U];
var bz = [O];
var bA = [{ [bZ]: s4, [ca]: [P] }];
var bB = [Z, T];
var bC = [{ [bZ]: j4, [ca]: bt, [cc]: "partitionResult" }];
var bD = [{ [bZ]: k4, [ca]: [{ [cb]: "Region" }, "us-east-1"] }];
var bE = [{ [bZ]: l4, [ca]: [{ [cb]: "Region" }, false] }];
var bF = [{ [bZ]: k4, [ca]: [aI, D2] }];
var bG = [{ [bZ]: v2, [ca]: [aH, "resourceId[1]"], [cc]: E2 }, { [bZ]: m4, [ca]: [{ [bZ]: k4, [ca]: [aK, B2] }] }];
var bH = [aH, "resourceId[1]"];
var bI = [Z];
var bJ = [al];
var bK = [{ [bZ]: m4, [ca]: [{ [bZ]: k4, [ca]: [{ [bZ]: v2, [ca]: [aH, "region"] }, B2] }] }];
var bL = [{ [bZ]: m4, [ca]: [{ [bZ]: d4, [ca]: [{ [bZ]: v2, [ca]: [aH, "resourceId[2]"] }] }] }];
var bM = [aH, "resourceId[2]"];
var bN = [{ [bZ]: j4, [ca]: [{ [bZ]: v2, [ca]: [aH, "region"] }], [cc]: "bucketPartition" }];
var bO = [{ [bZ]: k4, [ca]: [aP, { [bZ]: v2, [ca]: [{ [cb]: "partitionResult" }, w2] }] }];
var bP = [{ [bZ]: l4, [ca]: [{ [bZ]: v2, [ca]: [aH, "region"] }, true] }];
var bQ = [{ [bZ]: l4, [ca]: [aQ, false] }];
var bR = [{ [bZ]: l4, [ca]: [aK, false] }];
var bS = [ab];
var bT = [{ [bZ]: l4, [ca]: [{ [cb]: "Region" }, true] }];
var bU = [bg];
var _data4 = { version: "1.0", parameters: { Bucket: L2, Region: L2, UseFIPS: M2, UseDualStack: M2, Endpoint: L2, ForcePathStyle: N, Accelerate: M2, UseGlobalEndpoint: M2, UseObjectLambdaEndpoint: N, DisableAccessPoints: N, DisableMultiRegionAccessPoints: M2, UseArnRegion: N }, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: [{ [bZ]: d4, [ca]: bt }], [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: [O, { [bZ]: e4, [ca]: [P, 49, 50, b4], [cc]: f4 }, { [bZ]: e4, [ca]: [P, 8, 12, b4], [cc]: g4 }, { [bZ]: e4, [ca]: [P, 0, 7, b4], [cc]: h4 }, { [bZ]: e4, [ca]: [P, 32, 49, b4], [cc]: i4 }, { [bZ]: j4, [ca]: bt, [cc]: "regionPartition" }, { [bZ]: k4, [ca]: [{ [cb]: h4 }, "--op-s3"] }], [bW]: c4, [bX]: [{ [bY]: bv, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: [{ [bZ]: k4, [ca]: [Q, "e"] }], [bW]: c4, [bX]: [{ [bY]: bw, [bW]: c4, [bX]: [R, { [bY]: by, endpoint: { [cd]: "https://{Bucket}.ec2.{url#authority}", [ce]: V, [cj]: W }, [bW]: q4 }] }, { endpoint: { [cd]: "https://{Bucket}.ec2.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [ce]: V, [cj]: W }, [bW]: q4 }] }, { [bY]: [{ [bZ]: k4, [ca]: [Q, "o"] }], [bW]: c4, [bX]: [{ [bY]: bw, [bW]: c4, [bX]: [R, { [bY]: by, endpoint: { [cd]: "https://{Bucket}.op-{outpostId}.{url#authority}", [ce]: V, [cj]: W }, [bW]: q4 }] }, { endpoint: { [cd]: "https://{Bucket}.op-{outpostId}.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [ce]: V, [cj]: W }, [bW]: q4 }] }, { error: 'Unrecognized hardware type: "Expected hardware type o or e but got {hardwareType}"', [bW]: n4 }] }] }, { error: "Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`.", [bW]: n4 }] }, { [bY]: bz, [bW]: c4, [bX]: [{ [bY]: [T, { [bZ]: m4, [ca]: [{ [bZ]: d4, [ca]: [{ [bZ]: o4, [ca]: bx }] }] }], error: "Custom endpoint `{Endpoint}` was not a valid URI", [bW]: n4 }, { [bW]: c4, [bX]: [{ [bY]: [{ [bZ]: d4, [ca]: [X] }, { [bZ]: r4, [ca]: [X, b4] }], [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: bA, error: "Path-style addressing cannot be used with ARN buckets", [bW]: n4 }, Y] }] }, { [bY]: [{ [bZ]: u2, [ca]: [P, a4] }], [bW]: c4, [bX]: [{ [bY]: bC, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: bE, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [aj, { [bW]: c4, [bX]: [{ [bY]: [al, ab], error: "Accelerate cannot be used with FIPS", [bW]: n4 }, { [bW]: c4, [bX]: [{ [bY]: [al, ak], error: "S3 Accelerate cannot be used in this region", [bW]: n4 }, { [bW]: c4, [bX]: [{ [bY]: [T, Z], error: x2, [bW]: n4 }, { [bW]: c4, [bX]: [{ [bY]: [T, ab], error: x2, [bW]: n4 }, { [bW]: c4, [bX]: [{ [bY]: [T, al], error: x2, [bW]: n4 }, { [bW]: c4, [bX]: [am, am, { [bY]: [Z, ab, aa, S, ac, ad], [bW]: c4, [bX]: [{ endpoint: an, [bW]: q4 }] }, { [bY]: [Z, ab, aa, S, ac, af], endpoint: an, [bW]: q4 }, ao, ao, { [bY]: [ag, ab, aa, S, ac, ad], [bW]: c4, [bX]: [{ endpoint: ap, [bW]: q4 }] }, { [bY]: [ag, ab, aa, S, ac, af], endpoint: ap, [bW]: q4 }, aq, aq, { [bY]: [Z, ah, al, S, ac, ad], [bW]: c4, [bX]: [{ endpoint: ar, [bW]: q4 }] }, { [bY]: [Z, ah, al, S, ac, af], endpoint: ar, [bW]: q4 }, as, as, { [bY]: [Z, ah, aa, S, ac, ad], [bW]: c4, [bX]: [{ endpoint: at, [bW]: q4 }] }, { [bY]: [Z, ah, aa, S, ac, af], endpoint: at, [bW]: q4 }, au, ax, au, ax, { [bY]: [ag, ah, aa, T, U, av, ac, ad], [bW]: c4, [bX]: [{ [bY]: bD, endpoint: az, [bW]: q4 }, { endpoint: az, [bW]: q4 }] }, { [bY]: [ag, ah, aa, T, U, ay, ac, ad], [bW]: c4, [bX]: [{ [bY]: bD, endpoint: aA, [bW]: q4 }, aB] }, { [bY]: [ag, ah, aa, T, U, av, ac, af], endpoint: az, [bW]: q4 }, { [bY]: [ag, ah, aa, T, U, ay, ac, af], endpoint: aA, [bW]: q4 }, aC, aC, { [bY]: [ag, ah, al, S, ac, ad], [bW]: c4, [bX]: [{ [bY]: bD, endpoint: aD, [bW]: q4 }, { endpoint: aD, [bW]: q4 }] }, { [bY]: [ag, ah, al, S, ac, af], endpoint: aD, [bW]: q4 }, aE, aE, { [bY]: [ag, ah, aa, S, ac, ad], [bW]: c4, [bX]: [{ [bY]: bD, endpoint: { [cd]: y2, [ce]: ae, [cj]: W }, [bW]: q4 }, { endpoint: aF, [bW]: q4 }] }, { [bY]: [ag, ah, aa, S, ac, af], endpoint: aF, [bW]: q4 }] }] }] }] }] }] }] }] }, aG] }] }, ai] }, { [bY]: [T, U, { [bZ]: k4, [ca]: [{ [bZ]: v2, [ca]: [aw, "scheme"] }, "http"] }, { [bZ]: u2, [ca]: [P, b4] }, ah, ag, aa], [bW]: c4, [bX]: [{ [bY]: bC, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: bE, [bW]: c4, [bX]: [aB] }, aG] }] }, ai] }, { [bY]: [{ [bZ]: s4, [ca]: bu, [cc]: z2 }], [bW]: c4, [bX]: [{ [bY]: [{ [bZ]: v2, [ca]: [aH, "resourceId[0]"], [cc]: A2 }, { [bZ]: m4, [ca]: [{ [bZ]: k4, [ca]: [aI, B2] }] }], [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: [{ [bZ]: k4, [ca]: [aJ, C2] }], [bW]: c4, [bX]: [{ [bY]: bF, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: bG, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [aL, { [bW]: c4, [bX]: [aM, { [bW]: c4, [bX]: [{ [bY]: bK, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [aN, { [bW]: c4, [bX]: [{ [bY]: bL, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [aO, { [bW]: c4, [bX]: [{ [bY]: bN, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: bC, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: bO, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: bP, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: [{ [bZ]: k4, [ca]: [aQ, B2] }], error: "Invalid ARN: Missing account id", [bW]: n4 }, { [bW]: c4, [bX]: [{ [bY]: bQ, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: bR, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [aR, { [bW]: c4, [bX]: [{ [bY]: by, endpoint: { [cd]: F2, [ce]: aS, [cj]: W }, [bW]: q4 }, { [bY]: bS, endpoint: { [cd]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ce]: aS, [cj]: W }, [bW]: q4 }, { endpoint: { [cd]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ce]: aS, [cj]: W }, [bW]: q4 }] }] }] }, aT] }] }, aU] }] }] }, aV] }] }, aW] }] }, ai] }] }, aX] }] }] }, aY] }] }] }, aZ] }] }] }] }, ba] }] }, { error: "Invalid ARN: Object Lambda ARNs only support `accesspoint` arn types, but found: `{arnType}`", [bW]: n4 }] }, { [bY]: bF, [bW]: c4, [bX]: [{ [bY]: bG, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: bK, [bW]: c4, [bX]: [{ [bY]: bF, [bW]: c4, [bX]: [{ [bY]: bK, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [aN, { [bW]: c4, [bX]: [{ [bY]: bL, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [aO, { [bW]: c4, [bX]: [{ [bY]: bN, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: bC, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: [{ [bZ]: k4, [ca]: [aP, "{partitionResult#name}"] }], [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: bP, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: [{ [bZ]: k4, [ca]: [aJ, t2] }], [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: bQ, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: bR, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: bJ, error: "Access Points do not support S3 Accelerate", [bW]: n4 }, { [bW]: c4, [bX]: [aR, { [bW]: c4, [bX]: [{ [bY]: bB, error: "DualStack cannot be combined with a Host override (PrivateLink)", [bW]: n4 }, { [bW]: c4, [bX]: [{ [bY]: [ab, Z], endpoint: { [cd]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ce]: bb, [cj]: W }, [bW]: q4 }, { [bY]: [ab, ag], endpoint: { [cd]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ce]: bb, [cj]: W }, [bW]: q4 }, { [bY]: [ah, Z], endpoint: { [cd]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ce]: bb, [cj]: W }, [bW]: q4 }, { [bY]: [ah, ag, T, U], endpoint: { [cd]: F2, [ce]: bb, [cj]: W }, [bW]: q4 }, { [bY]: [ah, ag], endpoint: { [cd]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ce]: bb, [cj]: W }, [bW]: q4 }] }] }] }] }] }, aT] }] }, aU] }] }, { error: "Invalid ARN: The ARN was not for the S3 service, found: {bucketArn#service}", [bW]: n4 }] }] }, aV] }] }, aW] }] }, ai] }] }, aX] }] }] }, aY] }] }] }, aZ] }] }, { [bW]: c4, [bX]: [{ [bY]: [{ [bZ]: l4, [ca]: [aK, b4] }], [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: bI, error: "S3 MRAP does not support dual-stack", [bW]: n4 }, { [bW]: c4, [bX]: [{ [bY]: bS, error: "S3 MRAP does not support FIPS", [bW]: n4 }, { [bW]: c4, [bX]: [{ [bY]: bJ, error: "S3 MRAP does not support S3 Accelerate", [bW]: n4 }, { [bW]: c4, [bX]: [{ [bY]: [{ [bZ]: r4, [ca]: [{ [cb]: "DisableMultiRegionAccessPoints" }, b4] }], error: "Invalid configuration: Multi-Region Access Point ARNs are disabled.", [bW]: n4 }, { [bW]: c4, [bX]: [{ [bY]: [{ [bZ]: j4, [ca]: bt, [cc]: G2 }], [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: [{ [bZ]: k4, [ca]: [{ [bZ]: v2, [ca]: [{ [cb]: G2 }, w2] }, { [bZ]: v2, [ca]: [aH, "partition"] }] }], [bW]: c4, [bX]: [{ endpoint: { [cd]: "https://{accessPointName}.accesspoint.s3-global.{mrapPartition#dnsSuffix}", [ce]: { [cf]: [{ name: "sigv4a", signingRegionSet: ["*"], [ch]: t2, [ci]: b4 }] }, [cj]: W }, [bW]: q4 }] }, { error: "Client was configured for partition `{mrapPartition#name}` but bucket referred to partition `{bucketArn#partition}`", [bW]: n4 }] }] }, { error: "{Region} was not a valid region", [bW]: n4 }] }] }] }] }] }] }, { error: "Invalid Access Point Name", [bW]: n4 }] }] }] }, ba] }, { [bY]: [{ [bZ]: k4, [ca]: [aJ, p4] }], [bW]: c4, [bX]: [{ [bY]: bI, error: "S3 Outposts does not support Dual-stack", [bW]: n4 }, { [bW]: c4, [bX]: [{ [bY]: bS, error: "S3 Outposts does not support FIPS", [bW]: n4 }, { [bW]: c4, [bX]: [{ [bY]: bJ, error: "S3 Outposts does not support S3 Accelerate", [bW]: n4 }, { [bW]: c4, [bX]: [{ [bY]: [{ [bZ]: d4, [ca]: [{ [bZ]: v2, [ca]: [aH, "resourceId[4]"] }] }], error: "Invalid Arn: Outpost Access Point ARN contains sub resources", [bW]: n4 }, { [bW]: c4, [bX]: [{ [bY]: [{ [bZ]: v2, [ca]: bH, [cc]: i4 }], [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: bv, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [aO, { [bW]: c4, [bX]: [{ [bY]: bN, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: bC, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: bO, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: bP, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: bQ, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: [{ [bZ]: v2, [ca]: bM, [cc]: H2 }], [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: [{ [bZ]: v2, [ca]: [aH, "resourceId[3]"], [cc]: E2 }], [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: [{ [bZ]: k4, [ca]: [{ [cb]: H2 }, D2] }], [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: by, endpoint: { [cd]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.{url#authority}", [ce]: bc, [cj]: W }, [bW]: q4 }, { endpoint: { [cd]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.s3-outposts.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ce]: bc, [cj]: W }, [bW]: q4 }] }] }, { error: "Expected an outpost type `accesspoint`, found {outpostType}", [bW]: n4 }] }] }, { error: "Invalid ARN: expected an access point name", [bW]: n4 }] }] }, { error: "Invalid ARN: Expected a 4-component resource", [bW]: n4 }] }] }, aU] }] }, aV] }] }, aW] }] }, ai] }] }, { error: "Could not load partition for ARN region {bucketArn#region}", [bW]: n4 }] }] }] }, { error: "Invalid ARN: The outpost Id may only contain a-z, A-Z, 0-9 and `-`. Found: `{outpostId}`", [bW]: n4 }] }] }, { error: "Invalid ARN: The Outpost Id was not set", [bW]: n4 }] }] }] }] }] }, { error: "Invalid ARN: Unrecognized format: {Bucket} (type: {arnType})", [bW]: n4 }] }] }, { error: "Invalid ARN: No ARN type specified", [bW]: n4 }] }, { [bY]: [{ [bZ]: e4, [ca]: [P, 0, 4, a4], [cc]: I2 }, { [bZ]: k4, [ca]: [{ [cb]: I2 }, "arn:"] }, { [bZ]: m4, [ca]: [{ [bZ]: d4, [ca]: bA }] }], error: "Invalid ARN: `{Bucket}` was not a valid ARN", [bW]: n4 }, Y] }] }, { [bY]: [{ [bZ]: d4, [ca]: [bd] }, { [bZ]: r4, [ca]: [bd, b4] }], [bW]: c4, [bX]: [{ [bY]: bC, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: bT, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [aL, { [bW]: c4, [bX]: [aM, { [bW]: c4, [bX]: [aj, { [bW]: c4, [bX]: [{ [bY]: by, endpoint: { [cd]: J2, [ce]: be, [cj]: W }, [bW]: q4 }, { [bY]: bS, endpoint: { [cd]: "https://s3-object-lambda-fips.{Region}.{partitionResult#dnsSuffix}", [ce]: be, [cj]: W }, [bW]: q4 }, { endpoint: { [cd]: "https://s3-object-lambda.{Region}.{partitionResult#dnsSuffix}", [ce]: be, [cj]: W }, [bW]: q4 }] }] }] }] }] }, aG] }] }, ai] }, { [bY]: [{ [bZ]: m4, [ca]: bz }], [bW]: c4, [bX]: [{ [bY]: bC, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [{ [bY]: bT, [bW]: c4, [bX]: [{ [bW]: c4, [bX]: [aj, { [bW]: c4, [bX]: [bf, bf, { [bY]: [ab, Z, T, U, ac, ad], [bW]: c4, [bX]: bU }, { [bY]: [ab, Z, T, U, ac, af], endpoint: bh, [bW]: q4 }, bi, bi, { [bY]: [ab, Z, S, ac, ad], [bW]: c4, [bX]: [{ endpoint: bj, [bW]: q4 }] }, { [bY]: [ab, Z, S, ac, af], endpoint: bj, [bW]: q4 }, bk, bk, { [bY]: [ab, ag, T, U, ac, ad], [bW]: c4, [bX]: bU }, { [bY]: [ab, ag, T, U, ac, af], endpoint: bh, [bW]: q4 }, bl, bl, { [bY]: [ab, ag, S, ac, ad], [bW]: c4, [bX]: [{ endpoint: bm, [bW]: q4 }] }, { [bY]: [ab, ag, S, ac, af], endpoint: bm, [bW]: q4 }, bn, bn, { [bY]: [ah, Z, T, U, ac, ad], [bW]: c4, [bX]: bU }, { [bY]: [ah, Z, T, U, ac, af], endpoint: bh, [bW]: q4 }, bo, bo, { [bY]: [ah, Z, S, ac, ad], [bW]: c4, [bX]: [{ endpoint: bp, [bW]: q4 }] }, { [bY]: [ah, Z, S, ac, af], endpoint: bp, [bW]: q4 }, bq, bq, { [bY]: [ah, ag, T, U, ac, ad], [bW]: c4, [bX]: [{ [bY]: bD, endpoint: bh, [bW]: q4 }, bg] }, { [bY]: [ah, ag, T, U, ac, af], endpoint: bh, [bW]: q4 }, br, br, { [bY]: [ah, ag, S, ac, ad], [bW]: c4, [bX]: [{ [bY]: bD, endpoint: { [cd]: K2, [ce]: ae, [cj]: W }, [bW]: q4 }, { endpoint: bs, [bW]: q4 }] }, { [bY]: [ah, ag, S, ac, af], endpoint: bs, [bW]: q4 }] }] }] }, aG] }] }, ai] }] }] }, { error: "A region must be set when sending requests to S3.", [bW]: n4 }] }] };
var ruleSet4 = _data4;

// ../../node_modules/@aws-sdk/client-s3/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver4 = (endpointParams, context = {}) => {
  return resolveEndpoint(ruleSet4, {
    endpointParams,
    logger: context.logger
  });
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.shared.js
var getRuntimeConfig7 = (config) => ({
  apiVersion: "2006-03-01",
  base64Decoder: config?.base64Decoder ?? fromBase64,
  base64Encoder: config?.base64Encoder ?? toBase64,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver4,
  logger: config?.logger ?? new NoOpLogger(),
  serviceId: config?.serviceId ?? "S3",
  signerConstructor: config?.signerConstructor ?? SignatureV4MultiRegion,
  signingEscapePath: config?.signingEscapePath ?? false,
  urlParser: config?.urlParser ?? parseUrl,
  useArnRegion: config?.useArnRegion ?? false,
  utf8Decoder: config?.utf8Decoder ?? fromUtf84,
  utf8Encoder: config?.utf8Encoder ?? toUtf84
});

// ../../node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.js
var getRuntimeConfig8 = (config) => {
  emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = resolveDefaultsModeConfig(config);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig7(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
    credentialDefaultProvider: config?.credentialDefaultProvider ?? decorateDefaultCredentialProvider2(defaultProvider),
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent({ serviceId: clientSharedValues.serviceId, clientVersion: package_default.version }),
    eventStreamSerdeProvider: config?.eventStreamSerdeProvider ?? eventStreamSerdeProvider,
    getAwsChunkedEncodingStream: config?.getAwsChunkedEncodingStream ?? getAwsChunkedEncodingStream,
    maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
    md5: config?.md5 ?? Hash.bind(null, "md5"),
    region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sdkStreamMixin: config?.sdkStreamMixin ?? sdkStreamMixin,
    sha1: config?.sha1 ?? Hash.bind(null, "sha1"),
    sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector,
    streamHasher: config?.streamHasher ?? readableStreamHasher,
    useArnRegion: config?.useArnRegion ?? loadConfig(NODE_USE_ARN_REGION_CONFIG_OPTIONS),
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
  };
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/S3Client.js
var S3Client = class extends Client {
  constructor(configuration) {
    const _config_0 = getRuntimeConfig8(configuration);
    const _config_1 = resolveClientEndpointParameters(_config_0);
    const _config_2 = resolveRegionConfig(_config_1);
    const _config_3 = resolveEndpointConfig(_config_2);
    const _config_4 = resolveRetryConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig(_config_4);
    const _config_6 = resolveAwsAuthConfig(_config_5);
    const _config_7 = resolveS3Config(_config_6);
    const _config_8 = resolveUserAgentConfig(_config_7);
    const _config_9 = resolveEventStreamSerdeConfig(_config_8);
    super(_config_9);
    this.config = _config_9;
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
    this.middlewareStack.use(getAwsAuthPlugin(this.config));
    this.middlewareStack.use(getValidateBucketNamePlugin(this.config));
    this.middlewareStack.use(getAddExpectContinuePlugin(this.config));
    this.middlewareStack.use(getUserAgentPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// storage/index.ts
var import_picomatch = __toESM(require_picomatch2(), 1);

// ../../lib/telemetry/index.ts
var count = (usage, value, embeddedNamespace) => {
  ;
  process.telemetry?.count(usage, value, embeddedNamespace);
};
var telemetry_default = {
  withCounter(usage, embeddedNamespace) {
    return (fn) => {
      return (...args) => {
        count(usage, 1, embeddedNamespace);
        return fn(...args);
      };
    };
  },
  count
};

// ../../node_modules/ulid/dist/index.esm.js
function createError(message) {
  var err = new Error(message);
  err.source = "ulid";
  return err;
}
var ENCODING = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
var ENCODING_LEN = ENCODING.length;
var TIME_MAX = Math.pow(2, 48) - 1;
var TIME_LEN = 10;
var RANDOM_LEN = 16;
function randomChar(prng) {
  var rand = Math.floor(prng() * ENCODING_LEN);
  if (rand === ENCODING_LEN) {
    rand = ENCODING_LEN - 1;
  }
  return ENCODING.charAt(rand);
}
function encodeTime(now, len) {
  if (isNaN(now)) {
    throw new Error(now + " must be a number");
  }
  if (now > TIME_MAX) {
    throw createError("cannot encode time greater than " + TIME_MAX);
  }
  if (now < 0) {
    throw createError("time must be positive");
  }
  if (Number.isInteger(now) === false) {
    throw createError("time must be an integer");
  }
  var mod = void 0;
  var str = "";
  for (; len > 0; len--) {
    mod = now % ENCODING_LEN;
    str = ENCODING.charAt(mod) + str;
    now = (now - mod) / ENCODING_LEN;
  }
  return str;
}
function encodeRandom(len, prng) {
  var str = "";
  for (; len > 0; len--) {
    str = randomChar(prng) + str;
  }
  return str;
}
function detectPrng() {
  var allowInsecure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
  var root = arguments[1];
  if (!root) {
    root = typeof window !== "undefined" ? window : null;
  }
  var browserCrypto = root && (root.crypto || root.msCrypto);
  if (browserCrypto) {
    return function() {
      var buffer = new Uint8Array(1);
      browserCrypto.getRandomValues(buffer);
      return buffer[0] / 255;
    };
  } else {
    try {
      var nodeCrypto = require("crypto");
      return function() {
        return nodeCrypto.randomBytes(1).readUInt8() / 255;
      };
    } catch (e10) {
    }
  }
  if (allowInsecure) {
    try {
      console.error("secure crypto unusable, falling back to insecure Math.random()!");
    } catch (e10) {
    }
    return function() {
      return Math.random();
    };
  }
  throw createError("secure crypto unusable, insecure Math.random not allowed");
}
function factory(currPrng) {
  if (!currPrng) {
    currPrng = detectPrng();
  }
  return function ulid2(seedTime) {
    if (isNaN(seedTime)) {
      seedTime = Date.now();
    }
    return encodeTime(seedTime, TIME_LEN) + encodeRandom(RANDOM_LEN, currPrng);
  };
}
var ulid = factory();

// ../../lib/events-core/index.ts
function parseEventSpecifier(_specifier, validEventNames) {
  const result = /* @__PURE__ */ new Map();
  const specifiers = Array.isArray(_specifier) ? _specifier : [_specifier];
  for (const specifier of specifiers) {
    const [name, namespaceFilter, keyFilter] = specifier.split(":");
    if (name === "*") {
      validEventNames.forEach((name2) => result.set(name2, { name: name2, namespaceFilter, keyFilter }));
    } else {
      if (!validEventNames.includes(name)) {
        throw new Error(`Invalid event name: ${name}`);
      }
      result.set(name, { name, namespaceFilter, keyFilter });
    }
  }
  return result.values();
}
var MAX_SHARDS = 1;
var base32 = "0123456789ABCDEFGHJKMNPQRSTVWXYX";
function getPartitionKey(eventId) {
  const pid = eventId.slice(0, 6);
  const sid = eventId.slice(-1);
  return `${pid}_${sid}`;
}
function mintEventIdForTimestamp(timestamp) {
  return mintEventIdForTimestampAndShard(timestamp, randomShard());
}
function mintEventIdForTimestampAndShard(timestamp, partition2) {
  const sid = base32.charAt(partition2);
  const id = ulid(timestamp);
  return `${id}${sid}`;
}
function randomShard() {
  return Math.floor(Math.random() * MAX_SHARDS);
}

// ../../lib/aws-credentials/aws-credentials.ts
var import_https2 = __toESM(require("https"), 1);
var import_url2 = require("url");

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromNodeProviderChain.js
var fromNodeProviderChain = (init = {}) => defaultProvider({
  ...init,
  roleAssumer: init.roleAssumer ?? getDefaultRoleAssumer2(init.clientConfig, init.clientPlugins),
  roleAssumerWithWebIdentity: init.roleAssumerWithWebIdentity ?? getDefaultRoleAssumerWithWebIdentity2(init.clientConfig, init.clientPlugins)
});

// ../../lib/aws-credentials/aws-credentials.ts
var { AMPT_REFRESH_URL: refreshUrl, AMPT_REFRESH_AUTH: refreshAuth, AMPT_CLI_VERSION: cliVersion } = process.env;
var cached;
var defaultProvider2 = fromNodeProviderChain();
async function credentials() {
  if (refreshUrl) {
    if (!cached || cached.expiration >= Date.now()) {
      cached = await new Promise((resolve, reject) => {
        const url = new import_url2.URL(refreshUrl);
        const options = {
          headers: {
            Authorization: refreshAuth,
            "User-Agent": `ampt-cli/${cliVersion}`,
            "ampt-version": cliVersion
            // TODO: x-request-id and ampt-session-id?
          }
        };
        const req = import_https2.default.request(url, options, (res) => {
          const chunks = [];
          res.on("data", (chunk2) => {
            chunks.push(chunk2);
          });
          res.on("end", () => {
            const body = Buffer.concat(chunks).toString();
            const { credentials: credentials2 } = JSON.parse(body);
            credentials2.expiration = new Date(credentials2.expiration);
            resolve(credentials2);
          });
        });
        req.on("error", (error) => {
          reject(error);
        });
        req.end();
      });
    }
    return cached;
  }
  return defaultProvider2();
}

// ../../node_modules/@aws-sdk/util-format-url/dist-es/index.js
function formatUrl(request2) {
  const { port, query } = request2;
  let { protocol, path, hostname } = request2;
  if (protocol && protocol.slice(-1) !== ":") {
    protocol += ":";
  }
  if (port) {
    hostname += `:${port}`;
  }
  if (path && path.charAt(0) !== "/") {
    path = `/${path}`;
  }
  let queryString = query ? buildQueryString(query) : "";
  if (queryString && queryString[0] !== "?") {
    queryString = `?${queryString}`;
  }
  return `${protocol}//${hostname}${path}${queryString}`;
}

// ../../node_modules/@aws-sdk/s3-request-presigner/dist-es/constants.js
var UNSIGNED_PAYLOAD2 = "UNSIGNED-PAYLOAD";
var SHA256_HEADER2 = "X-Amz-Content-Sha256";

// ../../node_modules/@aws-sdk/s3-request-presigner/dist-es/presigner.js
var S3RequestPresigner = class {
  constructor(options) {
    const resolvedOptions = {
      service: options.signingName || options.service || "s3",
      uriEscapePath: options.uriEscapePath || false,
      applyChecksum: options.applyChecksum || false,
      ...options
    };
    this.signer = new SignatureV4MultiRegion(resolvedOptions);
  }
  presign(requestToSign, { unsignableHeaders = /* @__PURE__ */ new Set(), unhoistableHeaders = /* @__PURE__ */ new Set(), ...options } = {}) {
    unsignableHeaders.add("content-type");
    Object.keys(requestToSign.headers).map((header) => header.toLowerCase()).filter((header) => header.startsWith("x-amz-server-side-encryption")).forEach((header) => {
      unhoistableHeaders.add(header);
    });
    requestToSign.headers[SHA256_HEADER2] = UNSIGNED_PAYLOAD2;
    const currentHostHeader = requestToSign.headers.host;
    const port = requestToSign.port;
    const expectedHostHeader = `${requestToSign.hostname}${requestToSign.port != null ? ":" + port : ""}`;
    if (!currentHostHeader || currentHostHeader === requestToSign.hostname && requestToSign.port != null) {
      requestToSign.headers.host = expectedHostHeader;
    }
    return this.signer.presign(requestToSign, {
      expiresIn: 900,
      unsignableHeaders,
      unhoistableHeaders,
      ...options
    });
  }
};

// ../../node_modules/@aws-sdk/s3-request-presigner/dist-es/getSignedUrl.js
var getSignedUrl = async (client2, command, options = {}) => {
  let s3Presigner;
  if (typeof client2.config.endpointProvider === "function") {
    const endpointV2 = await getEndpointFromInstructions(command.input, command.constructor, client2.config);
    const authScheme = endpointV2.properties?.authSchemes?.[0];
    s3Presigner = new S3RequestPresigner({
      ...client2.config,
      signingName: authScheme?.signingName,
      region: async () => authScheme?.signingRegion
    });
  } else {
    s3Presigner = new S3RequestPresigner(client2.config);
  }
  const presignInterceptMiddleware = (next, context) => async (args) => {
    const { request: request2 } = args;
    if (!HttpRequest.isInstance(request2)) {
      throw new Error("Request to be presigned is not an valid HTTP request.");
    }
    delete request2.headers["amz-sdk-invocation-id"];
    delete request2.headers["amz-sdk-request"];
    delete request2.headers["x-amz-user-agent"];
    const presigned2 = await s3Presigner.presign(request2, {
      ...options,
      signingRegion: options.signingRegion ?? context["signing_region"],
      signingService: options.signingService ?? context["signing_service"]
    });
    return {
      response: {},
      output: {
        $metadata: { httpStatusCode: 200 },
        presigned: presigned2
      }
    };
  };
  const middlewareName = "presignInterceptMiddleware";
  const clientStack = client2.middlewareStack.clone();
  clientStack.addRelativeTo(presignInterceptMiddleware, {
    name: middlewareName,
    relation: "before",
    toMiddleware: "awsAuthMiddleware",
    override: true
  });
  const handler = command.resolveMiddleware(clientStack, client2.config, {});
  const { output } = await handler({ input: command.input });
  const { presigned } = output;
  return formatUrl(presigned);
};

// storage/util.ts
var import_mime_types = __toESM(require_mime_types(), 1);
var SECONDS_IN_YEAR = 365 * 24 * 60 * 60;
var normalizeSlashes = (str) => {
  return str.replace(/\/*$/, "").replace(/^\/*/, "").replace(/\/+/, "/");
};
var storageBucketName = () => {
  if (!process.env.STORAGE_BUCKET && process.env.AMPT_API_KEY) {
    console.log(
      JSON.stringify({
        error: "No storage bucket defined",
        _slsLog: true,
        _slsKey: "__console_access_key__"
      })
    );
    throw new StorageError("Internal Storage Error");
  }
  return process.env.STORAGE_BUCKET;
};
var head = async (args) => {
  const { client: client2, key } = args;
  if (!client2) {
    throw new StorageError("No client defined");
  }
  const headObjectCommand = new HeadObjectCommand({
    Bucket: storageBucketName(),
    Key: key
  });
  try {
    return await client2.send(headObjectCommand);
  } catch (e10) {
    const code = e10.Code || e10.name || e10.message;
    if (code === "NoSuchKey" || code === "NotFound") {
      return void 0;
    }
    console.log(
      JSON.stringify({
        error: e10.message,
        _slsLog: true,
        _slsKey: "__console_access_key__"
      })
    );
    throw new StorageError(code || e10);
  }
};
var getSignedUrl2 = async (args) => {
  const { client: client2, getObjectCommand, expiresIn } = args;
  return await getSignedUrl(client2, getObjectCommand, { expiresIn });
};
var read = async (args) => {
  const { client: client2, key, options = {} } = args;
  if (!client2) {
    throw new StorageError("No S3 client defined");
  }
  const headObjectResponse = await head({ client: client2, key });
  if (!headObjectResponse) {
    return void 0;
  }
  const getObjectCommand = new GetObjectCommand({
    Bucket: storageBucketName(),
    Key: key
  });
  try {
    const getObjectResponse = await client2.send(getObjectCommand);
    const bytesReceived = getObjectResponse.ContentLength || 0;
    telemetry_default.count("storageBytesReceived", bytesReceived, "storage");
    if (getObjectResponse.Body) {
      const stream = getObjectResponse.Body;
      if (options.buffer) {
        const chunks = [];
        for await (const chunk2 of stream) {
          chunks.push(chunk2);
        }
        return Buffer.concat(chunks);
      } else {
        return stream;
      }
    }
  } catch (e10) {
    return void 0;
  }
};
var redirect = async (args) => {
  const { client: client2, key, expiresIn = 3600 } = args;
  const getObjectCommand = new GetObjectCommand({
    Bucket: storageBucketName(),
    Key: key
  });
  return getSignedUrl2({ client: client2, getObjectCommand, expiresIn });
};
var write = async (args) => {
  const { client: client2, data, key, options = {} } = args;
  try {
    const isPublic = key.startsWith("storage/public");
    const putObjectCommand = new PutObjectCommand({
      Bucket: storageBucketName(),
      Body: Buffer.isBuffer(data) ? data : Buffer.from(data),
      CacheControl: options?.maxAge ? `max-age=${options.maxAge}` : void 0,
      Key: key,
      ContentType: options?.type || import_mime_types.default.lookup(key) || "application/octet-stream",
      Metadata: isPublic ? { ...options?.metadata || {}, "Cache-Control": `max-age=${options?.maxAge || SECONDS_IN_YEAR}` } : options?.metadata
    });
    const bytesWritten = Buffer.byteLength(data);
    await client2.send(putObjectCommand);
    telemetry_default.count("storageBytesStored", bytesWritten, "storage");
  } catch (e10) {
    console.log(
      JSON.stringify({
        error: e10.message,
        _slsLog: true,
        _slsKey: "__console_access_key__"
      })
    );
    throw new StorageError(e10.message);
  }
};
var list = async (args) => {
  const { client: client2, key, options = {} } = args;
  const listObjectsCommand = new ListObjectsV2Command({
    Bucket: storageBucketName(),
    Prefix: key,
    ContinuationToken: args.continuationToken || void 0,
    MaxKeys: options.pageSize || 100,
    Delimiter: !options.recursive ? "/" : void 0
  });
  const response = await client2.send(listObjectsCommand);
  const prefix = response.CommonPrefixes?.[0]?.Prefix;
  if (prefix && prefix.endsWith("/") && prefix.slice(0, -1) === key) {
    return list({
      client: client2,
      key: `${key}/`,
      options
    });
  }
  return response;
};
var copyOrMove = async (args) => {
  const { client: client2, move = false, key, destKey } = args;
  const filename = key.split("/").pop();
  const dest = destKey.endsWith("/") ? `${destKey}${filename}` : destKey;
  const source = `${storageBucketName()}/${key}`;
  const copyObjectCommand = new CopyObjectCommand({
    Bucket: storageBucketName(),
    CopySource: source,
    Key: dest
  });
  await client2.send(copyObjectCommand);
  if (move) {
    const deleteObjectCommand = new DeleteObjectCommand({
      Bucket: storageBucketName(),
      Key: key
    });
    await client2.send(deleteObjectCommand);
  }
};
var remove = async (args) => {
  const { client: client2, key } = args;
  try {
    const deleteObjectCommand = new DeleteObjectCommand({
      Bucket: storageBucketName(),
      Key: key
    });
    await client2.send(deleteObjectCommand);
  } catch (e10) {
    throw new StorageError(e10.ode || e10.name || e10.message || e10);
  }
};
var getUploadUrl = async (args) => {
  const { client: client2, key, expiresIn = 3600 } = args;
  try {
    const putCommand = new PutObjectCommand({
      Bucket: storageBucketName(),
      Key: key
    });
    return await getSignedUrl(client2, putCommand, { expiresIn });
  } catch (e10) {
    throw new StorageError(e10.code || e10.message || e10);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/models/SQSServiceException.js
var SQSServiceException = class extends ServiceException {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, SQSServiceException.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/models/models_0.js
var InvalidMessageContents = class extends SQSServiceException {
  constructor(opts) {
    super({
      name: "InvalidMessageContents",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidMessageContents";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidMessageContents.prototype);
  }
};
var UnsupportedOperation = class extends SQSServiceException {
  constructor(opts) {
    super({
      name: "UnsupportedOperation",
      $fault: "client",
      ...opts
    });
    this.name = "UnsupportedOperation";
    this.$fault = "client";
    Object.setPrototypeOf(this, UnsupportedOperation.prototype);
  }
};
var SendMessageRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var SendMessageResultFilterSensitiveLog = (obj) => ({
  ...obj
});

// ../../node_modules/@aws-sdk/client-sqs/dist-es/protocols/Aws_query.js
var import_fast_xml_parser3 = __toESM(require_fxp());
var serializeAws_querySendMessageCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString2({
    ...serializeAws_querySendMessageRequest(input, context),
    Action: "SendMessage",
    Version: "2012-11-05"
  });
  return buildHttpRpcRequest2(context, headers, "/", void 0, body);
};
var deserializeAws_querySendMessageCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_querySendMessageCommandError(output, context);
  }
  const data = await parseBody5(output.body, context);
  let contents = {};
  contents = deserializeAws_querySendMessageResult(data.SendMessageResult, context);
  const response = {
    $metadata: deserializeMetadata6(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_querySendMessageCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody5(output.body, context)
  };
  const errorCode = loadQueryErrorCode2(output, parsedOutput.body);
  switch (errorCode) {
    case "AWS.SimpleQueueService.UnsupportedOperation":
    case "com.amazonaws.sqs#UnsupportedOperation":
      throw await deserializeAws_queryUnsupportedOperationResponse(parsedOutput, context);
    case "InvalidMessageContents":
    case "com.amazonaws.sqs#InvalidMessageContents":
      throw await deserializeAws_queryInvalidMessageContentsResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        exceptionCtor: SQSServiceException,
        errorCode
      });
  }
};
var deserializeAws_queryInvalidMessageContentsResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryInvalidMessageContents(body.Error, context);
  const exception = new InvalidMessageContents({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_queryUnsupportedOperationResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryUnsupportedOperation(body.Error, context);
  const exception = new UnsupportedOperation({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var serializeAws_queryBinaryList = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`BinaryListValue.${counter}`] = context.base64Encoder(entry);
    counter++;
  }
  return entries;
};
var serializeAws_queryMessageAttributeValue = (input, context) => {
  const entries = {};
  if (input.StringValue != null) {
    entries["StringValue"] = input.StringValue;
  }
  if (input.BinaryValue != null) {
    entries["BinaryValue"] = context.base64Encoder(input.BinaryValue);
  }
  if (input.StringListValues != null) {
    const memberEntries = serializeAws_queryStringList(input.StringListValues, context);
    if (input.StringListValues?.length === 0) {
      entries.StringListValue = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `StringListValue.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.BinaryListValues != null) {
    const memberEntries = serializeAws_queryBinaryList(input.BinaryListValues, context);
    if (input.BinaryListValues?.length === 0) {
      entries.BinaryListValue = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `BinaryListValue.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DataType != null) {
    entries["DataType"] = input.DataType;
  }
  return entries;
};
var serializeAws_queryMessageBodyAttributeMap = (input, context) => {
  const entries = {};
  let counter = 1;
  Object.keys(input).filter((key) => input[key] != null).forEach((key) => {
    entries[`entry.${counter}.Name`] = key;
    const memberEntries = serializeAws_queryMessageAttributeValue(input[key], context);
    Object.entries(memberEntries).forEach(([key2, value]) => {
      entries[`entry.${counter}.Value.${key2}`] = value;
    });
    counter++;
  });
  return entries;
};
var serializeAws_queryMessageBodySystemAttributeMap = (input, context) => {
  const entries = {};
  let counter = 1;
  Object.keys(input).filter((key) => input[key] != null).forEach((key) => {
    entries[`entry.${counter}.Name`] = key;
    const memberEntries = serializeAws_queryMessageSystemAttributeValue(input[key], context);
    Object.entries(memberEntries).forEach(([key2, value]) => {
      entries[`entry.${counter}.Value.${key2}`] = value;
    });
    counter++;
  });
  return entries;
};
var serializeAws_queryMessageSystemAttributeValue = (input, context) => {
  const entries = {};
  if (input.StringValue != null) {
    entries["StringValue"] = input.StringValue;
  }
  if (input.BinaryValue != null) {
    entries["BinaryValue"] = context.base64Encoder(input.BinaryValue);
  }
  if (input.StringListValues != null) {
    const memberEntries = serializeAws_queryStringList(input.StringListValues, context);
    if (input.StringListValues?.length === 0) {
      entries.StringListValue = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `StringListValue.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.BinaryListValues != null) {
    const memberEntries = serializeAws_queryBinaryList(input.BinaryListValues, context);
    if (input.BinaryListValues?.length === 0) {
      entries.BinaryListValue = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `BinaryListValue.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DataType != null) {
    entries["DataType"] = input.DataType;
  }
  return entries;
};
var serializeAws_querySendMessageRequest = (input, context) => {
  const entries = {};
  if (input.QueueUrl != null) {
    entries["QueueUrl"] = input.QueueUrl;
  }
  if (input.MessageBody != null) {
    entries["MessageBody"] = input.MessageBody;
  }
  if (input.DelaySeconds != null) {
    entries["DelaySeconds"] = input.DelaySeconds;
  }
  if (input.MessageAttributes != null) {
    const memberEntries = serializeAws_queryMessageBodyAttributeMap(input.MessageAttributes, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MessageAttribute.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MessageSystemAttributes != null) {
    const memberEntries = serializeAws_queryMessageBodySystemAttributeMap(input.MessageSystemAttributes, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MessageSystemAttribute.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MessageDeduplicationId != null) {
    entries["MessageDeduplicationId"] = input.MessageDeduplicationId;
  }
  if (input.MessageGroupId != null) {
    entries["MessageGroupId"] = input.MessageGroupId;
  }
  return entries;
};
var serializeAws_queryStringList = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`StringListValue.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var deserializeAws_queryInvalidMessageContents = (output, context) => {
  const contents = {};
  return contents;
};
var deserializeAws_querySendMessageResult = (output, context) => {
  const contents = {
    MD5OfMessageBody: void 0,
    MD5OfMessageAttributes: void 0,
    MD5OfMessageSystemAttributes: void 0,
    MessageId: void 0,
    SequenceNumber: void 0
  };
  if (output["MD5OfMessageBody"] !== void 0) {
    contents.MD5OfMessageBody = expectString(output["MD5OfMessageBody"]);
  }
  if (output["MD5OfMessageAttributes"] !== void 0) {
    contents.MD5OfMessageAttributes = expectString(output["MD5OfMessageAttributes"]);
  }
  if (output["MD5OfMessageSystemAttributes"] !== void 0) {
    contents.MD5OfMessageSystemAttributes = expectString(output["MD5OfMessageSystemAttributes"]);
  }
  if (output["MessageId"] !== void 0) {
    contents.MessageId = expectString(output["MessageId"]);
  }
  if (output["SequenceNumber"] !== void 0) {
    contents.SequenceNumber = expectString(output["SequenceNumber"]);
  }
  return contents;
};
var deserializeAws_queryUnsupportedOperation = (output, context) => {
  const contents = {};
  return contents;
};
var deserializeMetadata6 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
var collectBody6 = (streamBody = new Uint8Array(), context) => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
var collectBodyString6 = (streamBody, context) => collectBody6(streamBody, context).then((body) => context.utf8Encoder(body));
var buildHttpRpcRequest2 = async (context, headers, path, resolvedHostname, body) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const contents = {
    protocol,
    hostname,
    port,
    method: "POST",
    path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
    headers
  };
  if (resolvedHostname !== void 0) {
    contents.hostname = resolvedHostname;
  }
  if (body !== void 0) {
    contents.body = body;
  }
  return new HttpRequest(contents);
};
var parseBody5 = (streamBody, context) => collectBodyString6(streamBody, context).then((encoded) => {
  if (encoded.length) {
    const parser = new import_fast_xml_parser3.XMLParser({
      attributeNamePrefix: "",
      htmlEntities: true,
      ignoreAttributes: false,
      ignoreDeclaration: true,
      parseTagValue: false,
      trimValues: false,
      tagValueProcessor: (_, val) => val.trim() === "" && val.includes("\n") ? "" : void 0
    });
    parser.addEntity("#xD", "\r");
    parser.addEntity("#10", "\n");
    const parsedObj = parser.parse(encoded);
    const textNodeName = "#text";
    const key = Object.keys(parsedObj)[0];
    const parsedObjToReturn = parsedObj[key];
    if (parsedObjToReturn[textNodeName]) {
      parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
      delete parsedObjToReturn[textNodeName];
    }
    return getValueFromTextNode(parsedObjToReturn);
  }
  return {};
});
var parseErrorBody5 = async (errorBody, context) => {
  const value = await parseBody5(errorBody, context);
  if (value.Error) {
    value.Error.message = value.Error.message ?? value.Error.Message;
  }
  return value;
};
var buildFormUrlencodedString2 = (formEntries) => Object.entries(formEntries).map(([key, value]) => extendedEncodeURIComponent(key) + "=" + extendedEncodeURIComponent(value)).join("&");
var loadQueryErrorCode2 = (output, data) => {
  if (data.Error?.Code !== void 0) {
    return data.Error.Code;
  }
  if (output.statusCode == 404) {
    return "NotFound";
  }
};

// ../../node_modules/@aws-sdk/middleware-sdk-sqs/dist-es/send-message.js
var sendMessageMiddleware = (options) => (next) => async (args) => {
  const resp = await next({ ...args });
  const output = resp.output;
  const hash2 = new options.md5();
  hash2.update(toUint8Array(args.input.MessageBody || ""));
  if (output.MD5OfMessageBody !== toHex(await hash2.digest())) {
    throw new Error("InvalidChecksumError");
  }
  return resp;
};
var sendMessageMiddlewareOptions = {
  step: "initialize",
  tags: ["VALIDATE_BODY_MD5"],
  name: "sendMessageMiddleware",
  override: true
};
var getSendMessagePlugin = (config) => ({
  applyToStack: (clientStack) => {
    clientStack.add(sendMessageMiddleware(config), sendMessageMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/SendMessageCommand.js
var SendMessageCommand = class extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, SendMessageCommand.getEndpointParameterInstructions()));
    this.middlewareStack.use(getSendMessagePlugin(configuration));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SQSClient";
    const commandName = "SendMessageCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: SendMessageRequestFilterSensitiveLog,
      outputFilterSensitiveLog: SendMessageResultFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_querySendMessageCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_querySendMessageCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters5 = (options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "sqs"
  };
};

// ../../node_modules/@aws-sdk/client-sqs/package.json
var package_default5 = {
  name: "@aws-sdk/client-sqs",
  description: "AWS SDK for JavaScript Sqs Client for Node.js, Browser and React Native",
  version: "3.272.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo sqs"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/client-sts": "3.272.0",
    "@aws-sdk/config-resolver": "3.272.0",
    "@aws-sdk/credential-provider-node": "3.272.0",
    "@aws-sdk/fetch-http-handler": "3.272.0",
    "@aws-sdk/hash-node": "3.272.0",
    "@aws-sdk/invalid-dependency": "3.272.0",
    "@aws-sdk/md5-js": "3.272.0",
    "@aws-sdk/middleware-content-length": "3.272.0",
    "@aws-sdk/middleware-endpoint": "3.272.0",
    "@aws-sdk/middleware-host-header": "3.272.0",
    "@aws-sdk/middleware-logger": "3.272.0",
    "@aws-sdk/middleware-recursion-detection": "3.272.0",
    "@aws-sdk/middleware-retry": "3.272.0",
    "@aws-sdk/middleware-sdk-sqs": "3.272.0",
    "@aws-sdk/middleware-serde": "3.272.0",
    "@aws-sdk/middleware-signing": "3.272.0",
    "@aws-sdk/middleware-stack": "3.272.0",
    "@aws-sdk/middleware-user-agent": "3.272.0",
    "@aws-sdk/node-config-provider": "3.272.0",
    "@aws-sdk/node-http-handler": "3.272.0",
    "@aws-sdk/protocol-http": "3.272.0",
    "@aws-sdk/smithy-client": "3.272.0",
    "@aws-sdk/types": "3.272.0",
    "@aws-sdk/url-parser": "3.272.0",
    "@aws-sdk/util-base64": "3.208.0",
    "@aws-sdk/util-body-length-browser": "3.188.0",
    "@aws-sdk/util-body-length-node": "3.208.0",
    "@aws-sdk/util-defaults-mode-browser": "3.272.0",
    "@aws-sdk/util-defaults-mode-node": "3.272.0",
    "@aws-sdk/util-endpoints": "3.272.0",
    "@aws-sdk/util-retry": "3.272.0",
    "@aws-sdk/util-user-agent-browser": "3.272.0",
    "@aws-sdk/util-user-agent-node": "3.272.0",
    "@aws-sdk/util-utf8": "3.254.0",
    "fast-xml-parser": "4.0.11",
    tslib: "^2.3.1"
  },
  devDependencies: {
    "@aws-sdk/service-client-documentation-generator": "3.208.0",
    "@tsconfig/node14": "1.0.3",
    "@types/node": "^14.14.31",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.19.2",
    typescript: "~4.6.2"
  },
  overrides: {
    typedoc: {
      typescript: "~4.6.2"
    }
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sqs",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-sqs"
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/endpoint/ruleset.js
var s5 = "required";
var t3 = "fn";
var u3 = "argv";
var v3 = "ref";
var a5 = "PartitionResult";
var b5 = "tree";
var c5 = "error";
var d5 = "endpoint";
var e5 = "getAttr";
var f5 = { [s5]: false, "type": "String" };
var g5 = { [s5]: true, "default": false, "type": "Boolean" };
var h5 = { [v3]: "Endpoint" };
var i5 = { [t3]: "booleanEquals", [u3]: [{ [v3]: "UseFIPS" }, true] };
var j5 = { [t3]: "booleanEquals", [u3]: [{ [v3]: "UseDualStack" }, true] };
var k5 = {};
var l5 = { [t3]: "booleanEquals", [u3]: [true, { [t3]: e5, [u3]: [{ [v3]: a5 }, "supportsFIPS"] }] };
var m5 = { [v3]: a5 };
var n5 = { [t3]: "booleanEquals", [u3]: [true, { [t3]: e5, [u3]: [m5, "supportsDualStack"] }] };
var o5 = { "url": "https://sqs.{Region}.{PartitionResult#dnsSuffix}", "properties": {}, "headers": {} };
var p5 = [h5];
var q5 = [i5];
var r5 = [j5];
var _data5 = { version: "1.0", parameters: { Region: f5, UseDualStack: g5, UseFIPS: g5, Endpoint: f5 }, rules: [{ conditions: [{ [t3]: "aws.partition", [u3]: [{ [v3]: "Region" }], assign: a5 }], type: b5, rules: [{ conditions: [{ [t3]: "isSet", [u3]: p5 }, { [t3]: "parseURL", [u3]: p5, assign: "url" }], type: b5, rules: [{ conditions: q5, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c5 }, { type: b5, rules: [{ conditions: r5, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c5 }, { endpoint: { url: h5, properties: k5, headers: k5 }, type: d5 }] }] }, { conditions: [i5, j5], type: b5, rules: [{ conditions: [l5, n5], type: b5, rules: [{ endpoint: { url: "https://sqs-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: k5, headers: k5 }, type: d5 }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c5 }] }, { conditions: q5, type: b5, rules: [{ conditions: [l5], type: b5, rules: [{ type: b5, rules: [{ conditions: [{ [t3]: "stringEquals", [u3]: ["aws-us-gov", { [t3]: e5, [u3]: [m5, "name"] }] }], endpoint: o5, type: d5 }, { endpoint: { url: "https://sqs-fips.{Region}.{PartitionResult#dnsSuffix}", properties: k5, headers: k5 }, type: d5 }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c5 }] }, { conditions: r5, type: b5, rules: [{ conditions: [n5], type: b5, rules: [{ endpoint: { url: "https://sqs.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: k5, headers: k5 }, type: d5 }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c5 }] }, { endpoint: o5, type: d5 }] }] };
var ruleSet5 = _data5;

// ../../node_modules/@aws-sdk/client-sqs/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver5 = (endpointParams, context = {}) => {
  return resolveEndpoint(ruleSet5, {
    endpointParams,
    logger: context.logger
  });
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/runtimeConfig.shared.js
var getRuntimeConfig9 = (config) => ({
  apiVersion: "2012-11-05",
  base64Decoder: config?.base64Decoder ?? fromBase64,
  base64Encoder: config?.base64Encoder ?? toBase64,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver5,
  logger: config?.logger ?? new NoOpLogger(),
  serviceId: config?.serviceId ?? "SQS",
  urlParser: config?.urlParser ?? parseUrl,
  utf8Decoder: config?.utf8Decoder ?? fromUtf84,
  utf8Encoder: config?.utf8Encoder ?? toUtf84
});

// ../../node_modules/@aws-sdk/client-sqs/dist-es/runtimeConfig.js
var getRuntimeConfig10 = (config) => {
  emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = resolveDefaultsModeConfig(config);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig9(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
    credentialDefaultProvider: config?.credentialDefaultProvider ?? decorateDefaultCredentialProvider2(defaultProvider),
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent({ serviceId: clientSharedValues.serviceId, clientVersion: package_default5.version }),
    maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
    md5: config?.md5 ?? Hash.bind(null, "md5"),
    region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
  };
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/SQSClient.js
var SQSClient = class extends Client {
  constructor(configuration) {
    const _config_0 = getRuntimeConfig10(configuration);
    const _config_1 = resolveClientEndpointParameters5(_config_0);
    const _config_2 = resolveRegionConfig(_config_1);
    const _config_3 = resolveEndpointConfig(_config_2);
    const _config_4 = resolveRetryConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig(_config_4);
    const _config_6 = resolveAwsAuthConfig(_config_5);
    const _config_7 = resolveUserAgentConfig(_config_6);
    super(_config_7);
    this.config = _config_7;
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
    this.middlewareStack.use(getAwsAuthPlugin(this.config));
    this.middlewareStack.use(getUserAgentPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-endpoint/dist-es/service-customizations/s3.js
var resolveParamsForS32 = async (endpointParams) => {
  const bucket = endpointParams?.Bucket || "";
  if (typeof endpointParams.Bucket === "string") {
    endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
  }
  if (isArnBucketName2(bucket)) {
    if (endpointParams.ForcePathStyle === true) {
      throw new Error("Path-style addressing cannot be used with ARN buckets");
    }
  } else if (!isDnsCompatibleBucketName3(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
    endpointParams.ForcePathStyle = true;
  }
  if (endpointParams.DisableMultiRegionAccessPoints) {
    endpointParams.disableMultiRegionAccessPoints = true;
    endpointParams.DisableMRAP = true;
  }
  return endpointParams;
};
var DOMAIN_PATTERN2 = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
var IP_ADDRESS_PATTERN2 = /(\d+\.){3}\d+/;
var DOTS_PATTERN2 = /\.\./;
var isDnsCompatibleBucketName3 = (bucketName) => DOMAIN_PATTERN2.test(bucketName) && !IP_ADDRESS_PATTERN2.test(bucketName) && !DOTS_PATTERN2.test(bucketName);
var isArnBucketName2 = (bucketName) => {
  const [arn, partition2, service, region, account, typeOrId] = bucketName.split(":");
  const isArn = arn === "arn" && bucketName.split(":").length >= 6;
  const isValidArn = [arn, partition2, service, account, typeOrId].filter(Boolean).length === 5;
  if (isArn && !isValidArn) {
    throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
  }
  return arn === "arn" && !!partition2 && !!service && !!account && !!typeOrId;
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-endpoint/dist-es/adaptors/createConfigValueProvider.js
var createConfigValueProvider2 = (configKey, canonicalEndpointParamKey, config) => {
  const configProvider = async () => {
    const configValue = config[configKey] ?? config[canonicalEndpointParamKey];
    if (typeof configValue === "function") {
      return configValue();
    }
    return configValue;
  };
  if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
    return async () => {
      const endpoint = await configProvider();
      if (endpoint && typeof endpoint === "object") {
        if ("url" in endpoint) {
          return endpoint.url.href;
        }
        if ("hostname" in endpoint) {
          const { protocol, hostname, port, path } = endpoint;
          return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
        }
      }
      return endpoint;
    };
  }
  return configProvider;
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js
var getEndpointFromInstructions2 = async (commandInput, instructionsSupplier, clientConfig, context) => {
  const endpointParams = await resolveParams2(commandInput, instructionsSupplier, clientConfig);
  if (typeof clientConfig.endpointProvider !== "function") {
    throw new Error("config.endpointProvider is not set.");
  }
  const endpoint = clientConfig.endpointProvider(endpointParams, context);
  return endpoint;
};
var resolveParams2 = async (commandInput, instructionsSupplier, clientConfig) => {
  const endpointParams = {};
  const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
  for (const [name, instruction] of Object.entries(instructions)) {
    switch (instruction.type) {
      case "staticContextParams":
        endpointParams[name] = instruction.value;
        break;
      case "contextParams":
        endpointParams[name] = commandInput[instruction.name];
        break;
      case "clientContextParams":
      case "builtInParams":
        endpointParams[name] = await createConfigValueProvider2(instruction.name, name, clientConfig)();
        break;
      default:
        throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
    }
  }
  if (Object.keys(instructions).length === 0) {
    Object.assign(endpointParams, clientConfig);
  }
  if (String(clientConfig.serviceId).toLowerCase() === "s3") {
    await resolveParamsForS32(endpointParams);
  }
  return endpointParams;
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-endpoint/dist-es/adaptors/toEndpointV1.js
var toEndpointV12 = (endpoint) => {
  if (typeof endpoint === "object") {
    if ("url" in endpoint) {
      return parseUrl(endpoint.url);
    }
    return endpoint;
  }
  return parseUrl(endpoint);
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-endpoint/dist-es/endpointMiddleware.js
var endpointMiddleware2 = ({ config, instructions }) => {
  return (next, context) => async (args) => {
    const endpoint = await getEndpointFromInstructions2(args.input, {
      getEndpointParameterInstructions() {
        return instructions;
      }
    }, { ...config }, context);
    context.endpointV2 = endpoint;
    context.authSchemes = endpoint.properties?.authSchemes;
    const authScheme = context.authSchemes?.[0];
    if (authScheme) {
      context["signing_region"] = authScheme.signingRegion;
      context["signing_service"] = authScheme.signingName;
    }
    return next({
      ...args
    });
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-endpoint/dist-es/getEndpointPlugin.js
var endpointMiddlewareOptions2 = {
  step: "serialize",
  tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
  name: "endpointV2Middleware",
  override: true,
  relation: "before",
  toMiddleware: serializerMiddlewareOption.name
};
var getEndpointPlugin2 = (config, instructions) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(endpointMiddleware2({
      config,
      instructions
    }), endpointMiddlewareOptions2);
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-endpoint/dist-es/resolveEndpointConfig.js
var resolveEndpointConfig2 = (input) => {
  const tls = input.tls ?? true;
  const { endpoint } = input;
  const customEndpointProvider = endpoint != null ? async () => toEndpointV12(await normalizeProvider(endpoint)()) : void 0;
  const isCustomEndpoint = !!endpoint;
  return {
    ...input,
    endpoint: customEndpointProvider,
    tls,
    isCustomEndpoint,
    useDualstackEndpoint: normalizeProvider(input.useDualstackEndpoint ?? false),
    useFipsEndpoint: normalizeProvider(input.useFipsEndpoint ?? false)
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/smithy-client/dist-es/NoOpLogger.js
var NoOpLogger2 = class {
  trace() {
  }
  debug() {
  }
  info() {
  }
  warn() {
  }
  error() {
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/smithy-client/dist-es/client.js
var Client2 = class {
  constructor(config) {
    this.middlewareStack = constructStack();
    this.config = config;
  }
  send(command, optionsOrCb, cb2) {
    const options = typeof optionsOrCb !== "function" ? optionsOrCb : void 0;
    const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb2;
    const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
    if (callback) {
      handler(command).then((result) => callback(null, result.output), (err) => callback(err)).catch(() => {
      });
    } else {
      return handler(command).then((result) => result.output);
    }
  }
  destroy() {
    if (this.config.requestHandler.destroy)
      this.config.requestHandler.destroy();
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/smithy-client/dist-es/command.js
var Command2 = class {
  constructor() {
    this.middlewareStack = constructStack();
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/smithy-client/dist-es/constants.js
var SENSITIVE_STRING2 = "***SensitiveInformation***";

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/smithy-client/dist-es/parse-utils.js
var expectBoolean = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value === "number") {
    if (value === 0 || value === 1) {
      logger2.warn(stackTraceWarning2(`Expected boolean, got ${typeof value}: ${value}`));
    }
    if (value === 0) {
      return false;
    }
    if (value === 1) {
      return true;
    }
  }
  if (typeof value === "string") {
    const lower = value.toLowerCase();
    if (lower === "false" || lower === "true") {
      logger2.warn(stackTraceWarning2(`Expected boolean, got ${typeof value}: ${value}`));
    }
    if (lower === "false") {
      return false;
    }
    if (lower === "true") {
      return true;
    }
  }
  if (typeof value === "boolean") {
    return value;
  }
  throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
};
var expectNumber2 = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value === "string") {
    const parsed = parseFloat(value);
    if (!Number.isNaN(parsed)) {
      if (String(parsed) !== String(value)) {
        logger2.warn(stackTraceWarning2(`Expected number but observed string: ${value}`));
      }
      return parsed;
    }
  }
  if (typeof value === "number") {
    return value;
  }
  throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
};
var MAX_FLOAT2 = Math.ceil(2 ** 127 * (2 - 2 ** -23));
var expectFloat322 = (value) => {
  const expected = expectNumber2(value);
  if (expected !== void 0 && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
    if (Math.abs(expected) > MAX_FLOAT2) {
      throw new TypeError(`Expected 32-bit float, got ${value}`);
    }
  }
  return expected;
};
var expectLong2 = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (Number.isInteger(value) && !Number.isNaN(value)) {
    return value;
  }
  throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
};
var expectInt322 = (value) => expectSizedInt2(value, 32);
var expectShort2 = (value) => expectSizedInt2(value, 16);
var expectByte2 = (value) => expectSizedInt2(value, 8);
var expectSizedInt2 = (value, size) => {
  const expected = expectLong2(value);
  if (expected !== void 0 && castInt2(expected, size) !== expected) {
    throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
  }
  return expected;
};
var castInt2 = (value, size) => {
  switch (size) {
    case 32:
      return Int32Array.of(value)[0];
    case 16:
      return Int16Array.of(value)[0];
    case 8:
      return Int8Array.of(value)[0];
  }
};
var expectNonNull2 = (value, location) => {
  if (value === null || value === void 0) {
    if (location) {
      throw new TypeError(`Expected a non-null value for ${location}`);
    }
    throw new TypeError("Expected a non-null value");
  }
  return value;
};
var expectObject2 = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value === "object" && !Array.isArray(value)) {
    return value;
  }
  const receivedType = Array.isArray(value) ? "array" : typeof value;
  throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
};
var expectString2 = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value === "string") {
    return value;
  }
  if (["boolean", "number", "bigint"].includes(typeof value)) {
    logger2.warn(stackTraceWarning2(`Expected string, got ${typeof value}: ${value}`));
    return String(value);
  }
  throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
};
var expectUnion2 = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  const asObject = expectObject2(value);
  const setKeys = Object.entries(asObject).filter(([, v7]) => v7 != null).map(([k10]) => k10);
  if (setKeys.length === 0) {
    throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
  }
  if (setKeys.length > 1) {
    throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
  }
  return asObject;
};
var strictParseFloat322 = (value) => {
  if (typeof value == "string") {
    return expectFloat322(parseNumber2(value));
  }
  return expectFloat322(value);
};
var NUMBER_REGEX2 = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
var parseNumber2 = (value) => {
  const matches = value.match(NUMBER_REGEX2);
  if (matches === null || matches[0].length !== value.length) {
    throw new TypeError(`Expected real number, got implicit NaN`);
  }
  return parseFloat(value);
};
var limitedParseDouble = (value) => {
  if (typeof value == "string") {
    return parseFloatString(value);
  }
  return expectNumber2(value);
};
var parseFloatString = (value) => {
  switch (value) {
    case "NaN":
      return NaN;
    case "Infinity":
      return Infinity;
    case "-Infinity":
      return -Infinity;
    default:
      throw new Error(`Unable to parse float value: ${value}`);
  }
};
var strictParseInt322 = (value) => {
  if (typeof value === "string") {
    return expectInt322(parseNumber2(value));
  }
  return expectInt322(value);
};
var strictParseShort2 = (value) => {
  if (typeof value === "string") {
    return expectShort2(parseNumber2(value));
  }
  return expectShort2(value);
};
var strictParseByte2 = (value) => {
  if (typeof value === "string") {
    return expectByte2(parseNumber2(value));
  }
  return expectByte2(value);
};
var stackTraceWarning2 = (message) => {
  return String(new TypeError(message).stack || message).split("\n").slice(0, 5).filter((s10) => !s10.includes("stackTraceWarning")).join("\n");
};
var logger2 = {
  warn: console.warn
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/smithy-client/dist-es/date-utils.js
var MONTHS2 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
var RFC33392 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
var RFC3339_WITH_OFFSET2 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
var parseRfc3339DateTimeWithOffset2 = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value !== "string") {
    throw new TypeError("RFC-3339 date-times must be expressed as strings");
  }
  const match = RFC3339_WITH_OFFSET2.exec(value);
  if (!match) {
    throw new TypeError("Invalid RFC-3339 date-time value");
  }
  const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
  const year = strictParseShort2(stripLeadingZeroes2(yearStr));
  const month = parseDateValue2(monthStr, "month", 1, 12);
  const day = parseDateValue2(dayStr, "day", 1, 31);
  const date2 = buildDate2(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
  if (offsetStr.toUpperCase() != "Z") {
    date2.setTime(date2.getTime() - parseOffsetToMilliseconds2(offsetStr));
  }
  return date2;
};
var IMF_FIXDATE2 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
var RFC_850_DATE2 = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
var ASC_TIME2 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
var buildDate2 = (year, month, day, time) => {
  const adjustedMonth = month - 1;
  validateDayOfMonth2(year, adjustedMonth, day);
  return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue2(time.hours, "hour", 0, 23), parseDateValue2(time.minutes, "minute", 0, 59), parseDateValue2(time.seconds, "seconds", 0, 60), parseMilliseconds2(time.fractionalMilliseconds)));
};
var FIFTY_YEARS_IN_MILLIS2 = 50 * 365 * 24 * 60 * 60 * 1e3;
var DAYS_IN_MONTH2 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var validateDayOfMonth2 = (year, month, day) => {
  let maxDays = DAYS_IN_MONTH2[month];
  if (month === 1 && isLeapYear2(year)) {
    maxDays = 29;
  }
  if (day > maxDays) {
    throw new TypeError(`Invalid day for ${MONTHS2[month]} in ${year}: ${day}`);
  }
};
var isLeapYear2 = (year) => {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
var parseDateValue2 = (value, type, lower, upper) => {
  const dateVal = strictParseByte2(stripLeadingZeroes2(value));
  if (dateVal < lower || dateVal > upper) {
    throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
  }
  return dateVal;
};
var parseMilliseconds2 = (value) => {
  if (value === null || value === void 0) {
    return 0;
  }
  return strictParseFloat322("0." + value) * 1e3;
};
var parseOffsetToMilliseconds2 = (value) => {
  const directionStr = value[0];
  let direction = 1;
  if (directionStr == "+") {
    direction = 1;
  } else if (directionStr == "-") {
    direction = -1;
  } else {
    throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
  }
  const hour = Number(value.substring(1, 3));
  const minute = Number(value.substring(4, 6));
  return direction * (hour * 60 + minute) * 60 * 1e3;
};
var stripLeadingZeroes2 = (value) => {
  let idx = 0;
  while (idx < value.length - 1 && value.charAt(idx) === "0") {
    idx++;
  }
  if (idx === 0) {
    return value;
  }
  return value.slice(idx);
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/smithy-client/dist-es/exceptions.js
var ServiceException2 = class extends Error {
  constructor(options) {
    super(options.message);
    Object.setPrototypeOf(this, ServiceException2.prototype);
    this.name = options.name;
    this.$fault = options.$fault;
    this.$metadata = options.$metadata;
  }
};
var decorateServiceException2 = (exception, additions = {}) => {
  Object.entries(additions).filter(([, v7]) => v7 !== void 0).forEach(([k10, v7]) => {
    if (exception[k10] == void 0 || exception[k10] === "") {
      exception[k10] = v7;
    }
  });
  const message = exception.message || exception.Message || "UnknownError";
  exception.message = message;
  delete exception.Message;
  return exception;
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/smithy-client/dist-es/default-error-handler.js
var throwDefaultError2 = ({ output, parsedBody, exceptionCtor, errorCode }) => {
  const $metadata = deserializeMetadata7(output);
  const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : void 0;
  const response = new exceptionCtor({
    name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
    $fault: "client",
    $metadata
  });
  throw decorateServiceException2(response, parsedBody);
};
var deserializeMetadata7 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/smithy-client/dist-es/defaults-mode.js
var loadConfigsForDefaultMode2 = (mode) => {
  switch (mode) {
    case "standard":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "in-region":
      return {
        retryMode: "standard",
        connectionTimeout: 1100
      };
    case "cross-region":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "mobile":
      return {
        retryMode: "standard",
        connectionTimeout: 3e4
      };
    default:
      return {};
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js
var warningEmitted2 = false;
var emitWarningIfUnsupportedVersion2 = (version) => {
  if (version && !warningEmitted2 && parseInt(version.substring(1, version.indexOf("."))) < 14) {
    warningEmitted2 = true;
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/smithy-client/dist-es/extended-encode-uri-component.js
function extendedEncodeURIComponent2(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c10) {
    return "%" + c10.charCodeAt(0).toString(16).toUpperCase();
  });
}

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/smithy-client/dist-es/get-value-from-text-node.js
var getValueFromTextNode2 = (obj) => {
  const textNodeName = "#text";
  for (const key in obj) {
    if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== void 0) {
      obj[key] = obj[key][textNodeName];
    } else if (typeof obj[key] === "object" && obj[key] !== null) {
      obj[key] = getValueFromTextNode2(obj[key]);
    }
  }
  return obj;
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/smithy-client/dist-es/lazy-json.js
var StringWrapper2 = function() {
  const Class = Object.getPrototypeOf(this).constructor;
  const Constructor = Function.bind.apply(String, [null, ...arguments]);
  const instance = new Constructor();
  Object.setPrototypeOf(instance, Class.prototype);
  return instance;
};
StringWrapper2.prototype = Object.create(String.prototype, {
  constructor: {
    value: StringWrapper2,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
Object.setPrototypeOf(StringWrapper2, String);

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/smithy-client/dist-es/object-mapping.js
function map6(arg0, arg1, arg2) {
  let target;
  let filter;
  let instructions;
  if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
    target = {};
    instructions = arg0;
  } else {
    target = arg0;
    if (typeof arg1 === "function") {
      filter = arg1;
      instructions = arg2;
      return mapWithFilter2(target, filter, instructions);
    } else {
      instructions = arg1;
    }
  }
  for (const key of Object.keys(instructions)) {
    if (!Array.isArray(instructions[key])) {
      target[key] = instructions[key];
      continue;
    }
    let [filter2, value] = instructions[key];
    if (typeof value === "function") {
      let _value;
      const defaultFilterPassed = filter2 === void 0 && (_value = value()) != null;
      const customFilterPassed = typeof filter2 === "function" && !!filter2(void 0) || typeof filter2 !== "function" && !!filter2;
      if (defaultFilterPassed) {
        target[key] = _value;
      } else if (customFilterPassed) {
        target[key] = value();
      }
    } else {
      const defaultFilterPassed = filter2 === void 0 && value != null;
      const customFilterPassed = typeof filter2 === "function" && !!filter2(value) || typeof filter2 !== "function" && !!filter2;
      if (defaultFilterPassed || customFilterPassed) {
        target[key] = value;
      }
    }
  }
  return target;
}
var mapWithFilter2 = (target, filter, instructions) => {
  return map6(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
    if (Array.isArray(value)) {
      _instructions[key] = value;
    } else {
      if (typeof value === "function") {
        _instructions[key] = [filter, value()];
      } else {
        _instructions[key] = [filter, value];
      }
    }
    return _instructions;
  }, {}));
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/models/DynamoDBServiceException.js
var DynamoDBServiceException = class extends ServiceException2 {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, DynamoDBServiceException.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/models/models_0.js
var AttributeAction;
(function(AttributeAction2) {
  AttributeAction2["ADD"] = "ADD";
  AttributeAction2["DELETE"] = "DELETE";
  AttributeAction2["PUT"] = "PUT";
})(AttributeAction || (AttributeAction = {}));
var ScalarAttributeType;
(function(ScalarAttributeType2) {
  ScalarAttributeType2["B"] = "B";
  ScalarAttributeType2["N"] = "N";
  ScalarAttributeType2["S"] = "S";
})(ScalarAttributeType || (ScalarAttributeType = {}));
var BackupStatus;
(function(BackupStatus2) {
  BackupStatus2["AVAILABLE"] = "AVAILABLE";
  BackupStatus2["CREATING"] = "CREATING";
  BackupStatus2["DELETED"] = "DELETED";
})(BackupStatus || (BackupStatus = {}));
var BackupType;
(function(BackupType2) {
  BackupType2["AWS_BACKUP"] = "AWS_BACKUP";
  BackupType2["SYSTEM"] = "SYSTEM";
  BackupType2["USER"] = "USER";
})(BackupType || (BackupType = {}));
var BillingMode;
(function(BillingMode2) {
  BillingMode2["PAY_PER_REQUEST"] = "PAY_PER_REQUEST";
  BillingMode2["PROVISIONED"] = "PROVISIONED";
})(BillingMode || (BillingMode = {}));
var KeyType;
(function(KeyType2) {
  KeyType2["HASH"] = "HASH";
  KeyType2["RANGE"] = "RANGE";
})(KeyType || (KeyType = {}));
var ProjectionType;
(function(ProjectionType2) {
  ProjectionType2["ALL"] = "ALL";
  ProjectionType2["INCLUDE"] = "INCLUDE";
  ProjectionType2["KEYS_ONLY"] = "KEYS_ONLY";
})(ProjectionType || (ProjectionType = {}));
var SSEType;
(function(SSEType2) {
  SSEType2["AES256"] = "AES256";
  SSEType2["KMS"] = "KMS";
})(SSEType || (SSEType = {}));
var SSEStatus;
(function(SSEStatus2) {
  SSEStatus2["DISABLED"] = "DISABLED";
  SSEStatus2["DISABLING"] = "DISABLING";
  SSEStatus2["ENABLED"] = "ENABLED";
  SSEStatus2["ENABLING"] = "ENABLING";
  SSEStatus2["UPDATING"] = "UPDATING";
})(SSEStatus || (SSEStatus = {}));
var StreamViewType;
(function(StreamViewType2) {
  StreamViewType2["KEYS_ONLY"] = "KEYS_ONLY";
  StreamViewType2["NEW_AND_OLD_IMAGES"] = "NEW_AND_OLD_IMAGES";
  StreamViewType2["NEW_IMAGE"] = "NEW_IMAGE";
  StreamViewType2["OLD_IMAGE"] = "OLD_IMAGE";
})(StreamViewType || (StreamViewType = {}));
var TimeToLiveStatus;
(function(TimeToLiveStatus2) {
  TimeToLiveStatus2["DISABLED"] = "DISABLED";
  TimeToLiveStatus2["DISABLING"] = "DISABLING";
  TimeToLiveStatus2["ENABLED"] = "ENABLED";
  TimeToLiveStatus2["ENABLING"] = "ENABLING";
})(TimeToLiveStatus || (TimeToLiveStatus = {}));
var BackupTypeFilter;
(function(BackupTypeFilter2) {
  BackupTypeFilter2["ALL"] = "ALL";
  BackupTypeFilter2["AWS_BACKUP"] = "AWS_BACKUP";
  BackupTypeFilter2["SYSTEM"] = "SYSTEM";
  BackupTypeFilter2["USER"] = "USER";
})(BackupTypeFilter || (BackupTypeFilter = {}));
var ReturnConsumedCapacity;
(function(ReturnConsumedCapacity2) {
  ReturnConsumedCapacity2["INDEXES"] = "INDEXES";
  ReturnConsumedCapacity2["NONE"] = "NONE";
  ReturnConsumedCapacity2["TOTAL"] = "TOTAL";
})(ReturnConsumedCapacity || (ReturnConsumedCapacity = {}));
var BatchStatementErrorCodeEnum;
(function(BatchStatementErrorCodeEnum2) {
  BatchStatementErrorCodeEnum2["AccessDenied"] = "AccessDenied";
  BatchStatementErrorCodeEnum2["ConditionalCheckFailed"] = "ConditionalCheckFailed";
  BatchStatementErrorCodeEnum2["DuplicateItem"] = "DuplicateItem";
  BatchStatementErrorCodeEnum2["InternalServerError"] = "InternalServerError";
  BatchStatementErrorCodeEnum2["ItemCollectionSizeLimitExceeded"] = "ItemCollectionSizeLimitExceeded";
  BatchStatementErrorCodeEnum2["ProvisionedThroughputExceeded"] = "ProvisionedThroughputExceeded";
  BatchStatementErrorCodeEnum2["RequestLimitExceeded"] = "RequestLimitExceeded";
  BatchStatementErrorCodeEnum2["ResourceNotFound"] = "ResourceNotFound";
  BatchStatementErrorCodeEnum2["ThrottlingError"] = "ThrottlingError";
  BatchStatementErrorCodeEnum2["TransactionConflict"] = "TransactionConflict";
  BatchStatementErrorCodeEnum2["ValidationError"] = "ValidationError";
})(BatchStatementErrorCodeEnum || (BatchStatementErrorCodeEnum = {}));
var InternalServerError = class extends DynamoDBServiceException {
  constructor(opts) {
    super({
      name: "InternalServerError",
      $fault: "server",
      ...opts
    });
    this.name = "InternalServerError";
    this.$fault = "server";
    Object.setPrototypeOf(this, InternalServerError.prototype);
  }
};
var RequestLimitExceeded = class extends DynamoDBServiceException {
  constructor(opts) {
    super({
      name: "RequestLimitExceeded",
      $fault: "client",
      ...opts
    });
    this.name = "RequestLimitExceeded";
    this.$fault = "client";
    Object.setPrototypeOf(this, RequestLimitExceeded.prototype);
  }
};
var InvalidEndpointException = class extends DynamoDBServiceException {
  constructor(opts) {
    super({
      name: "InvalidEndpointException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidEndpointException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidEndpointException.prototype);
    this.Message = opts.Message;
  }
};
var ProvisionedThroughputExceededException = class extends DynamoDBServiceException {
  constructor(opts) {
    super({
      name: "ProvisionedThroughputExceededException",
      $fault: "client",
      ...opts
    });
    this.name = "ProvisionedThroughputExceededException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ProvisionedThroughputExceededException.prototype);
  }
};
var ResourceNotFoundException2 = class extends DynamoDBServiceException {
  constructor(opts) {
    super({
      name: "ResourceNotFoundException",
      $fault: "client",
      ...opts
    });
    this.name = "ResourceNotFoundException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ResourceNotFoundException2.prototype);
  }
};
var ReturnItemCollectionMetrics;
(function(ReturnItemCollectionMetrics2) {
  ReturnItemCollectionMetrics2["NONE"] = "NONE";
  ReturnItemCollectionMetrics2["SIZE"] = "SIZE";
})(ReturnItemCollectionMetrics || (ReturnItemCollectionMetrics = {}));
var ItemCollectionSizeLimitExceededException = class extends DynamoDBServiceException {
  constructor(opts) {
    super({
      name: "ItemCollectionSizeLimitExceededException",
      $fault: "client",
      ...opts
    });
    this.name = "ItemCollectionSizeLimitExceededException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ItemCollectionSizeLimitExceededException.prototype);
  }
};
var ComparisonOperator;
(function(ComparisonOperator2) {
  ComparisonOperator2["BEGINS_WITH"] = "BEGINS_WITH";
  ComparisonOperator2["BETWEEN"] = "BETWEEN";
  ComparisonOperator2["CONTAINS"] = "CONTAINS";
  ComparisonOperator2["EQ"] = "EQ";
  ComparisonOperator2["GE"] = "GE";
  ComparisonOperator2["GT"] = "GT";
  ComparisonOperator2["IN"] = "IN";
  ComparisonOperator2["LE"] = "LE";
  ComparisonOperator2["LT"] = "LT";
  ComparisonOperator2["NE"] = "NE";
  ComparisonOperator2["NOT_CONTAINS"] = "NOT_CONTAINS";
  ComparisonOperator2["NOT_NULL"] = "NOT_NULL";
  ComparisonOperator2["NULL"] = "NULL";
})(ComparisonOperator || (ComparisonOperator = {}));
var ConditionalCheckFailedException = class extends DynamoDBServiceException {
  constructor(opts) {
    super({
      name: "ConditionalCheckFailedException",
      $fault: "client",
      ...opts
    });
    this.name = "ConditionalCheckFailedException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ConditionalCheckFailedException.prototype);
  }
};
var ConditionalOperator;
(function(ConditionalOperator2) {
  ConditionalOperator2["AND"] = "AND";
  ConditionalOperator2["OR"] = "OR";
})(ConditionalOperator || (ConditionalOperator = {}));
var ReturnValuesOnConditionCheckFailure;
(function(ReturnValuesOnConditionCheckFailure2) {
  ReturnValuesOnConditionCheckFailure2["ALL_OLD"] = "ALL_OLD";
  ReturnValuesOnConditionCheckFailure2["NONE"] = "NONE";
})(ReturnValuesOnConditionCheckFailure || (ReturnValuesOnConditionCheckFailure = {}));
var ContinuousBackupsStatus;
(function(ContinuousBackupsStatus2) {
  ContinuousBackupsStatus2["DISABLED"] = "DISABLED";
  ContinuousBackupsStatus2["ENABLED"] = "ENABLED";
})(ContinuousBackupsStatus || (ContinuousBackupsStatus = {}));
var PointInTimeRecoveryStatus;
(function(PointInTimeRecoveryStatus2) {
  PointInTimeRecoveryStatus2["DISABLED"] = "DISABLED";
  PointInTimeRecoveryStatus2["ENABLED"] = "ENABLED";
})(PointInTimeRecoveryStatus || (PointInTimeRecoveryStatus = {}));
var ContributorInsightsAction;
(function(ContributorInsightsAction2) {
  ContributorInsightsAction2["DISABLE"] = "DISABLE";
  ContributorInsightsAction2["ENABLE"] = "ENABLE";
})(ContributorInsightsAction || (ContributorInsightsAction = {}));
var ContributorInsightsStatus;
(function(ContributorInsightsStatus2) {
  ContributorInsightsStatus2["DISABLED"] = "DISABLED";
  ContributorInsightsStatus2["DISABLING"] = "DISABLING";
  ContributorInsightsStatus2["ENABLED"] = "ENABLED";
  ContributorInsightsStatus2["ENABLING"] = "ENABLING";
  ContributorInsightsStatus2["FAILED"] = "FAILED";
})(ContributorInsightsStatus || (ContributorInsightsStatus = {}));
var GlobalTableStatus;
(function(GlobalTableStatus2) {
  GlobalTableStatus2["ACTIVE"] = "ACTIVE";
  GlobalTableStatus2["CREATING"] = "CREATING";
  GlobalTableStatus2["DELETING"] = "DELETING";
  GlobalTableStatus2["UPDATING"] = "UPDATING";
})(GlobalTableStatus || (GlobalTableStatus = {}));
var ReplicaStatus;
(function(ReplicaStatus2) {
  ReplicaStatus2["ACTIVE"] = "ACTIVE";
  ReplicaStatus2["CREATING"] = "CREATING";
  ReplicaStatus2["CREATION_FAILED"] = "CREATION_FAILED";
  ReplicaStatus2["DELETING"] = "DELETING";
  ReplicaStatus2["INACCESSIBLE_ENCRYPTION_CREDENTIALS"] = "INACCESSIBLE_ENCRYPTION_CREDENTIALS";
  ReplicaStatus2["REGION_DISABLED"] = "REGION_DISABLED";
  ReplicaStatus2["UPDATING"] = "UPDATING";
})(ReplicaStatus || (ReplicaStatus = {}));
var TableClass;
(function(TableClass2) {
  TableClass2["STANDARD"] = "STANDARD";
  TableClass2["STANDARD_INFREQUENT_ACCESS"] = "STANDARD_INFREQUENT_ACCESS";
})(TableClass || (TableClass = {}));
var IndexStatus;
(function(IndexStatus2) {
  IndexStatus2["ACTIVE"] = "ACTIVE";
  IndexStatus2["CREATING"] = "CREATING";
  IndexStatus2["DELETING"] = "DELETING";
  IndexStatus2["UPDATING"] = "UPDATING";
})(IndexStatus || (IndexStatus = {}));
var TableStatus;
(function(TableStatus2) {
  TableStatus2["ACTIVE"] = "ACTIVE";
  TableStatus2["ARCHIVED"] = "ARCHIVED";
  TableStatus2["ARCHIVING"] = "ARCHIVING";
  TableStatus2["CREATING"] = "CREATING";
  TableStatus2["DELETING"] = "DELETING";
  TableStatus2["INACCESSIBLE_ENCRYPTION_CREDENTIALS"] = "INACCESSIBLE_ENCRYPTION_CREDENTIALS";
  TableStatus2["UPDATING"] = "UPDATING";
})(TableStatus || (TableStatus = {}));
var ReturnValue;
(function(ReturnValue2) {
  ReturnValue2["ALL_NEW"] = "ALL_NEW";
  ReturnValue2["ALL_OLD"] = "ALL_OLD";
  ReturnValue2["NONE"] = "NONE";
  ReturnValue2["UPDATED_NEW"] = "UPDATED_NEW";
  ReturnValue2["UPDATED_OLD"] = "UPDATED_OLD";
})(ReturnValue || (ReturnValue = {}));
var TransactionConflictException = class extends DynamoDBServiceException {
  constructor(opts) {
    super({
      name: "TransactionConflictException",
      $fault: "client",
      ...opts
    });
    this.name = "TransactionConflictException";
    this.$fault = "client";
    Object.setPrototypeOf(this, TransactionConflictException.prototype);
  }
};
var ExportFormat;
(function(ExportFormat2) {
  ExportFormat2["DYNAMODB_JSON"] = "DYNAMODB_JSON";
  ExportFormat2["ION"] = "ION";
})(ExportFormat || (ExportFormat = {}));
var ExportStatus;
(function(ExportStatus2) {
  ExportStatus2["COMPLETED"] = "COMPLETED";
  ExportStatus2["FAILED"] = "FAILED";
  ExportStatus2["IN_PROGRESS"] = "IN_PROGRESS";
})(ExportStatus || (ExportStatus = {}));
var S3SseAlgorithm;
(function(S3SseAlgorithm2) {
  S3SseAlgorithm2["AES256"] = "AES256";
  S3SseAlgorithm2["KMS"] = "KMS";
})(S3SseAlgorithm || (S3SseAlgorithm = {}));
var ImportStatus;
(function(ImportStatus2) {
  ImportStatus2["CANCELLED"] = "CANCELLED";
  ImportStatus2["CANCELLING"] = "CANCELLING";
  ImportStatus2["COMPLETED"] = "COMPLETED";
  ImportStatus2["FAILED"] = "FAILED";
  ImportStatus2["IN_PROGRESS"] = "IN_PROGRESS";
})(ImportStatus || (ImportStatus = {}));
var InputCompressionType;
(function(InputCompressionType2) {
  InputCompressionType2["GZIP"] = "GZIP";
  InputCompressionType2["NONE"] = "NONE";
  InputCompressionType2["ZSTD"] = "ZSTD";
})(InputCompressionType || (InputCompressionType = {}));
var InputFormat;
(function(InputFormat2) {
  InputFormat2["CSV"] = "CSV";
  InputFormat2["DYNAMODB_JSON"] = "DYNAMODB_JSON";
  InputFormat2["ION"] = "ION";
})(InputFormat || (InputFormat = {}));
var DestinationStatus;
(function(DestinationStatus2) {
  DestinationStatus2["ACTIVE"] = "ACTIVE";
  DestinationStatus2["DISABLED"] = "DISABLED";
  DestinationStatus2["DISABLING"] = "DISABLING";
  DestinationStatus2["ENABLE_FAILED"] = "ENABLE_FAILED";
  DestinationStatus2["ENABLING"] = "ENABLING";
})(DestinationStatus || (DestinationStatus = {}));
var Select;
(function(Select2) {
  Select2["ALL_ATTRIBUTES"] = "ALL_ATTRIBUTES";
  Select2["ALL_PROJECTED_ATTRIBUTES"] = "ALL_PROJECTED_ATTRIBUTES";
  Select2["COUNT"] = "COUNT";
  Select2["SPECIFIC_ATTRIBUTES"] = "SPECIFIC_ATTRIBUTES";
})(Select || (Select = {}));
var AttributeValue;
(function(AttributeValue2) {
  AttributeValue2.visit = (value, visitor) => {
    if (value.S !== void 0)
      return visitor.S(value.S);
    if (value.N !== void 0)
      return visitor.N(value.N);
    if (value.B !== void 0)
      return visitor.B(value.B);
    if (value.SS !== void 0)
      return visitor.SS(value.SS);
    if (value.NS !== void 0)
      return visitor.NS(value.NS);
    if (value.BS !== void 0)
      return visitor.BS(value.BS);
    if (value.M !== void 0)
      return visitor.M(value.M);
    if (value.L !== void 0)
      return visitor.L(value.L);
    if (value.NULL !== void 0)
      return visitor.NULL(value.NULL);
    if (value.BOOL !== void 0)
      return visitor.BOOL(value.BOOL);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(AttributeValue || (AttributeValue = {}));
var DescribeEndpointsRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var DescribeEndpointsResponseFilterSensitiveLog = (obj) => ({
  ...obj
});
var AttributeValueFilterSensitiveLog = (obj) => {
  if (obj.S !== void 0)
    return { S: obj.S };
  if (obj.N !== void 0)
    return { N: obj.N };
  if (obj.B !== void 0)
    return { B: obj.B };
  if (obj.SS !== void 0)
    return { SS: obj.SS };
  if (obj.NS !== void 0)
    return { NS: obj.NS };
  if (obj.BS !== void 0)
    return { BS: obj.BS };
  if (obj.M !== void 0)
    return {
      M: Object.entries(obj.M).reduce((acc, [key, value]) => (acc[key] = AttributeValueFilterSensitiveLog(value), acc), {})
    };
  if (obj.L !== void 0)
    return { L: obj.L.map((item) => AttributeValueFilterSensitiveLog(item)) };
  if (obj.NULL !== void 0)
    return { NULL: obj.NULL };
  if (obj.BOOL !== void 0)
    return { BOOL: obj.BOOL };
  if (obj.$unknown !== void 0)
    return { [obj.$unknown[0]]: "UNKNOWN" };
};
var AttributeValueUpdateFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Value && { Value: AttributeValueFilterSensitiveLog(obj.Value) }
});
var ConditionFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.AttributeValueList && {
    AttributeValueList: obj.AttributeValueList.map((item) => AttributeValueFilterSensitiveLog(item))
  }
});
var DeleteRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Key && {
    Key: Object.entries(obj.Key).reduce((acc, [key, value]) => (acc[key] = AttributeValueFilterSensitiveLog(value), acc), {})
  }
});
var ItemCollectionMetricsFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.ItemCollectionKey && {
    ItemCollectionKey: Object.entries(obj.ItemCollectionKey).reduce((acc, [key, value]) => (acc[key] = AttributeValueFilterSensitiveLog(value), acc), {})
  }
});
var PutRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Item && {
    Item: Object.entries(obj.Item).reduce((acc, [key, value]) => (acc[key] = AttributeValueFilterSensitiveLog(value), acc), {})
  }
});
var KeysAndAttributesFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Keys && {
    Keys: obj.Keys.map((item) => Object.entries(item).reduce((acc, [key, value]) => (acc[key] = AttributeValueFilterSensitiveLog(value), acc), {}))
  }
});
var BatchGetItemInputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.RequestItems && {
    RequestItems: Object.entries(obj.RequestItems).reduce((acc, [key, value]) => (acc[key] = KeysAndAttributesFilterSensitiveLog(value), acc), {})
  }
});
var ExpectedAttributeValueFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Value && { Value: AttributeValueFilterSensitiveLog(obj.Value) },
  ...obj.AttributeValueList && {
    AttributeValueList: obj.AttributeValueList.map((item) => AttributeValueFilterSensitiveLog(item))
  }
});
var DeleteItemOutputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Attributes && {
    Attributes: Object.entries(obj.Attributes).reduce((acc, [key, value]) => (acc[key] = AttributeValueFilterSensitiveLog(value), acc), {})
  },
  ...obj.ItemCollectionMetrics && {
    ItemCollectionMetrics: ItemCollectionMetricsFilterSensitiveLog(obj.ItemCollectionMetrics)
  }
});
var PutItemOutputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Attributes && {
    Attributes: Object.entries(obj.Attributes).reduce((acc, [key, value]) => (acc[key] = AttributeValueFilterSensitiveLog(value), acc), {})
  },
  ...obj.ItemCollectionMetrics && {
    ItemCollectionMetrics: ItemCollectionMetricsFilterSensitiveLog(obj.ItemCollectionMetrics)
  }
});
var QueryOutputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Items && {
    Items: obj.Items.map((item) => Object.entries(item).reduce((acc, [key, value]) => (acc[key] = AttributeValueFilterSensitiveLog(value), acc), {}))
  },
  ...obj.LastEvaluatedKey && {
    LastEvaluatedKey: Object.entries(obj.LastEvaluatedKey).reduce((acc, [key, value]) => (acc[key] = AttributeValueFilterSensitiveLog(value), acc), {})
  }
});
var UpdateItemOutputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Attributes && {
    Attributes: Object.entries(obj.Attributes).reduce((acc, [key, value]) => (acc[key] = AttributeValueFilterSensitiveLog(value), acc), {})
  },
  ...obj.ItemCollectionMetrics && {
    ItemCollectionMetrics: ItemCollectionMetricsFilterSensitiveLog(obj.ItemCollectionMetrics)
  }
});
var WriteRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.PutRequest && { PutRequest: PutRequestFilterSensitiveLog(obj.PutRequest) },
  ...obj.DeleteRequest && { DeleteRequest: DeleteRequestFilterSensitiveLog(obj.DeleteRequest) }
});
var BatchGetItemOutputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Responses && {
    Responses: Object.entries(obj.Responses).reduce((acc, [key, value]) => (acc[key] = value.map((item) => Object.entries(item).reduce((acc2, [key2, value2]) => (acc2[key2] = AttributeValueFilterSensitiveLog(value2), acc2), {})), acc), {})
  },
  ...obj.UnprocessedKeys && {
    UnprocessedKeys: Object.entries(obj.UnprocessedKeys).reduce((acc, [key, value]) => (acc[key] = KeysAndAttributesFilterSensitiveLog(value), acc), {})
  }
});
var BatchWriteItemInputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.RequestItems && {
    RequestItems: Object.entries(obj.RequestItems).reduce((acc, [key, value]) => (acc[key] = value.map((item) => WriteRequestFilterSensitiveLog(item)), acc), {})
  }
});
var DeleteItemInputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Key && {
    Key: Object.entries(obj.Key).reduce((acc, [key, value]) => (acc[key] = AttributeValueFilterSensitiveLog(value), acc), {})
  },
  ...obj.Expected && {
    Expected: Object.entries(obj.Expected).reduce((acc, [key, value]) => (acc[key] = ExpectedAttributeValueFilterSensitiveLog(value), acc), {})
  },
  ...obj.ExpressionAttributeValues && {
    ExpressionAttributeValues: Object.entries(obj.ExpressionAttributeValues).reduce((acc, [key, value]) => (acc[key] = AttributeValueFilterSensitiveLog(value), acc), {})
  }
});
var PutItemInputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Item && {
    Item: Object.entries(obj.Item).reduce((acc, [key, value]) => (acc[key] = AttributeValueFilterSensitiveLog(value), acc), {})
  },
  ...obj.Expected && {
    Expected: Object.entries(obj.Expected).reduce((acc, [key, value]) => (acc[key] = ExpectedAttributeValueFilterSensitiveLog(value), acc), {})
  },
  ...obj.ExpressionAttributeValues && {
    ExpressionAttributeValues: Object.entries(obj.ExpressionAttributeValues).reduce((acc, [key, value]) => (acc[key] = AttributeValueFilterSensitiveLog(value), acc), {})
  }
});
var QueryInputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.KeyConditions && {
    KeyConditions: Object.entries(obj.KeyConditions).reduce((acc, [key, value]) => (acc[key] = ConditionFilterSensitiveLog(value), acc), {})
  },
  ...obj.QueryFilter && {
    QueryFilter: Object.entries(obj.QueryFilter).reduce((acc, [key, value]) => (acc[key] = ConditionFilterSensitiveLog(value), acc), {})
  },
  ...obj.ExclusiveStartKey && {
    ExclusiveStartKey: Object.entries(obj.ExclusiveStartKey).reduce((acc, [key, value]) => (acc[key] = AttributeValueFilterSensitiveLog(value), acc), {})
  },
  ...obj.ExpressionAttributeValues && {
    ExpressionAttributeValues: Object.entries(obj.ExpressionAttributeValues).reduce((acc, [key, value]) => (acc[key] = AttributeValueFilterSensitiveLog(value), acc), {})
  }
});
var BatchWriteItemOutputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.UnprocessedItems && {
    UnprocessedItems: Object.entries(obj.UnprocessedItems).reduce((acc, [key, value]) => (acc[key] = value.map((item) => WriteRequestFilterSensitiveLog(item)), acc), {})
  },
  ...obj.ItemCollectionMetrics && {
    ItemCollectionMetrics: Object.entries(obj.ItemCollectionMetrics).reduce((acc, [key, value]) => (acc[key] = value.map((item) => ItemCollectionMetricsFilterSensitiveLog(item)), acc), {})
  }
});
var UpdateItemInputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Key && {
    Key: Object.entries(obj.Key).reduce((acc, [key, value]) => (acc[key] = AttributeValueFilterSensitiveLog(value), acc), {})
  },
  ...obj.AttributeUpdates && {
    AttributeUpdates: Object.entries(obj.AttributeUpdates).reduce((acc, [key, value]) => (acc[key] = AttributeValueUpdateFilterSensitiveLog(value), acc), {})
  },
  ...obj.Expected && {
    Expected: Object.entries(obj.Expected).reduce((acc, [key, value]) => (acc[key] = ExpectedAttributeValueFilterSensitiveLog(value), acc), {})
  },
  ...obj.ExpressionAttributeValues && {
    ExpressionAttributeValues: Object.entries(obj.ExpressionAttributeValues).reduce((acc, [key, value]) => (acc[key] = AttributeValueFilterSensitiveLog(value), acc), {})
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/protocol-http/dist-es/FieldPosition.js
var FieldPosition2;
(function(FieldPosition4) {
  FieldPosition4[FieldPosition4["HEADER"] = 0] = "HEADER";
  FieldPosition4[FieldPosition4["TRAILER"] = 1] = "TRAILER";
})(FieldPosition2 || (FieldPosition2 = {}));

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/protocol-http/dist-es/httpRequest.js
var HttpRequest2 = class {
  constructor(options) {
    this.method = options.method || "GET";
    this.hostname = options.hostname || "localhost";
    this.port = options.port;
    this.query = options.query || {};
    this.headers = options.headers || {};
    this.body = options.body;
    this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
    this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
  }
  static isInstance(request2) {
    if (!request2)
      return false;
    const req = request2;
    return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
  }
  clone() {
    const cloned = new HttpRequest2({
      ...this,
      headers: { ...this.headers }
    });
    if (cloned.query)
      cloned.query = cloneQuery3(cloned.query);
    return cloned;
  }
};
function cloneQuery3(query) {
  return Object.keys(query).reduce((carry, paramName) => {
    const param = query[paramName];
    return {
      ...carry,
      [paramName]: Array.isArray(param) ? [...param] : param
    };
  }, {});
}

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/protocol-http/dist-es/httpResponse.js
var HttpResponse2 = class {
  constructor(options) {
    this.statusCode = options.statusCode;
    this.headers = options.headers || {};
    this.body = options.body;
  }
  static isInstance(response) {
    if (!response)
      return false;
    const resp = response;
    return typeof resp.statusCode === "number" && typeof resp.headers === "object";
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/protocols/Aws_json1_0.js
var serializeAws_json1_0BatchGetItemCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-amz-json-1.0",
    "x-amz-target": "DynamoDB_20120810.BatchGetItem"
  };
  let body;
  body = JSON.stringify(serializeAws_json1_0BatchGetItemInput(input, context));
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_json1_0BatchWriteItemCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-amz-json-1.0",
    "x-amz-target": "DynamoDB_20120810.BatchWriteItem"
  };
  let body;
  body = JSON.stringify(serializeAws_json1_0BatchWriteItemInput(input, context));
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_json1_0DeleteItemCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-amz-json-1.0",
    "x-amz-target": "DynamoDB_20120810.DeleteItem"
  };
  let body;
  body = JSON.stringify(serializeAws_json1_0DeleteItemInput(input, context));
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_json1_0DescribeEndpointsCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-amz-json-1.0",
    "x-amz-target": "DynamoDB_20120810.DescribeEndpoints"
  };
  let body;
  body = JSON.stringify(serializeAws_json1_0DescribeEndpointsRequest(input, context));
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_json1_0PutItemCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-amz-json-1.0",
    "x-amz-target": "DynamoDB_20120810.PutItem"
  };
  let body;
  body = JSON.stringify(serializeAws_json1_0PutItemInput(input, context));
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_json1_0QueryCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-amz-json-1.0",
    "x-amz-target": "DynamoDB_20120810.Query"
  };
  let body;
  body = JSON.stringify(serializeAws_json1_0QueryInput(input, context));
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_json1_0UpdateItemCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-amz-json-1.0",
    "x-amz-target": "DynamoDB_20120810.UpdateItem"
  };
  let body;
  body = JSON.stringify(serializeAws_json1_0UpdateItemInput(input, context));
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var deserializeAws_json1_0BatchGetItemCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_0BatchGetItemCommandError(output, context);
  }
  const data = await parseBody6(output.body, context);
  let contents = {};
  contents = deserializeAws_json1_0BatchGetItemOutput(data, context);
  const response = {
    $metadata: deserializeMetadata8(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_json1_0BatchGetItemCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody6(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode3(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.dynamodb#InternalServerError":
      throw await deserializeAws_json1_0InternalServerErrorResponse(parsedOutput, context);
    case "InvalidEndpointException":
    case "com.amazonaws.dynamodb#InvalidEndpointException":
      throw await deserializeAws_json1_0InvalidEndpointExceptionResponse(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
      throw await deserializeAws_json1_0ProvisionedThroughputExceededExceptionResponse(parsedOutput, context);
    case "RequestLimitExceeded":
    case "com.amazonaws.dynamodb#RequestLimitExceeded":
      throw await deserializeAws_json1_0RequestLimitExceededResponse(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.dynamodb#ResourceNotFoundException":
      throw await deserializeAws_json1_0ResourceNotFoundExceptionResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError2({
        output,
        parsedBody,
        exceptionCtor: DynamoDBServiceException,
        errorCode
      });
  }
};
var deserializeAws_json1_0BatchWriteItemCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_0BatchWriteItemCommandError(output, context);
  }
  const data = await parseBody6(output.body, context);
  let contents = {};
  contents = deserializeAws_json1_0BatchWriteItemOutput(data, context);
  const response = {
    $metadata: deserializeMetadata8(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_json1_0BatchWriteItemCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody6(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode3(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.dynamodb#InternalServerError":
      throw await deserializeAws_json1_0InternalServerErrorResponse(parsedOutput, context);
    case "InvalidEndpointException":
    case "com.amazonaws.dynamodb#InvalidEndpointException":
      throw await deserializeAws_json1_0InvalidEndpointExceptionResponse(parsedOutput, context);
    case "ItemCollectionSizeLimitExceededException":
    case "com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException":
      throw await deserializeAws_json1_0ItemCollectionSizeLimitExceededExceptionResponse(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
      throw await deserializeAws_json1_0ProvisionedThroughputExceededExceptionResponse(parsedOutput, context);
    case "RequestLimitExceeded":
    case "com.amazonaws.dynamodb#RequestLimitExceeded":
      throw await deserializeAws_json1_0RequestLimitExceededResponse(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.dynamodb#ResourceNotFoundException":
      throw await deserializeAws_json1_0ResourceNotFoundExceptionResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError2({
        output,
        parsedBody,
        exceptionCtor: DynamoDBServiceException,
        errorCode
      });
  }
};
var deserializeAws_json1_0DeleteItemCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_0DeleteItemCommandError(output, context);
  }
  const data = await parseBody6(output.body, context);
  let contents = {};
  contents = deserializeAws_json1_0DeleteItemOutput(data, context);
  const response = {
    $metadata: deserializeMetadata8(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_json1_0DeleteItemCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody6(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode3(output, parsedOutput.body);
  switch (errorCode) {
    case "ConditionalCheckFailedException":
    case "com.amazonaws.dynamodb#ConditionalCheckFailedException":
      throw await deserializeAws_json1_0ConditionalCheckFailedExceptionResponse(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.dynamodb#InternalServerError":
      throw await deserializeAws_json1_0InternalServerErrorResponse(parsedOutput, context);
    case "InvalidEndpointException":
    case "com.amazonaws.dynamodb#InvalidEndpointException":
      throw await deserializeAws_json1_0InvalidEndpointExceptionResponse(parsedOutput, context);
    case "ItemCollectionSizeLimitExceededException":
    case "com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException":
      throw await deserializeAws_json1_0ItemCollectionSizeLimitExceededExceptionResponse(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
      throw await deserializeAws_json1_0ProvisionedThroughputExceededExceptionResponse(parsedOutput, context);
    case "RequestLimitExceeded":
    case "com.amazonaws.dynamodb#RequestLimitExceeded":
      throw await deserializeAws_json1_0RequestLimitExceededResponse(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.dynamodb#ResourceNotFoundException":
      throw await deserializeAws_json1_0ResourceNotFoundExceptionResponse(parsedOutput, context);
    case "TransactionConflictException":
    case "com.amazonaws.dynamodb#TransactionConflictException":
      throw await deserializeAws_json1_0TransactionConflictExceptionResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError2({
        output,
        parsedBody,
        exceptionCtor: DynamoDBServiceException,
        errorCode
      });
  }
};
var deserializeAws_json1_0DescribeEndpointsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_0DescribeEndpointsCommandError(output, context);
  }
  const data = await parseBody6(output.body, context);
  let contents = {};
  contents = deserializeAws_json1_0DescribeEndpointsResponse(data, context);
  const response = {
    $metadata: deserializeMetadata8(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_json1_0DescribeEndpointsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody6(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode3(output, parsedOutput.body);
  const parsedBody = parsedOutput.body;
  throwDefaultError2({
    output,
    parsedBody,
    exceptionCtor: DynamoDBServiceException,
    errorCode
  });
};
var deserializeAws_json1_0PutItemCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_0PutItemCommandError(output, context);
  }
  const data = await parseBody6(output.body, context);
  let contents = {};
  contents = deserializeAws_json1_0PutItemOutput(data, context);
  const response = {
    $metadata: deserializeMetadata8(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_json1_0PutItemCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody6(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode3(output, parsedOutput.body);
  switch (errorCode) {
    case "ConditionalCheckFailedException":
    case "com.amazonaws.dynamodb#ConditionalCheckFailedException":
      throw await deserializeAws_json1_0ConditionalCheckFailedExceptionResponse(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.dynamodb#InternalServerError":
      throw await deserializeAws_json1_0InternalServerErrorResponse(parsedOutput, context);
    case "InvalidEndpointException":
    case "com.amazonaws.dynamodb#InvalidEndpointException":
      throw await deserializeAws_json1_0InvalidEndpointExceptionResponse(parsedOutput, context);
    case "ItemCollectionSizeLimitExceededException":
    case "com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException":
      throw await deserializeAws_json1_0ItemCollectionSizeLimitExceededExceptionResponse(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
      throw await deserializeAws_json1_0ProvisionedThroughputExceededExceptionResponse(parsedOutput, context);
    case "RequestLimitExceeded":
    case "com.amazonaws.dynamodb#RequestLimitExceeded":
      throw await deserializeAws_json1_0RequestLimitExceededResponse(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.dynamodb#ResourceNotFoundException":
      throw await deserializeAws_json1_0ResourceNotFoundExceptionResponse(parsedOutput, context);
    case "TransactionConflictException":
    case "com.amazonaws.dynamodb#TransactionConflictException":
      throw await deserializeAws_json1_0TransactionConflictExceptionResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError2({
        output,
        parsedBody,
        exceptionCtor: DynamoDBServiceException,
        errorCode
      });
  }
};
var deserializeAws_json1_0QueryCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_0QueryCommandError(output, context);
  }
  const data = await parseBody6(output.body, context);
  let contents = {};
  contents = deserializeAws_json1_0QueryOutput(data, context);
  const response = {
    $metadata: deserializeMetadata8(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_json1_0QueryCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody6(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode3(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.dynamodb#InternalServerError":
      throw await deserializeAws_json1_0InternalServerErrorResponse(parsedOutput, context);
    case "InvalidEndpointException":
    case "com.amazonaws.dynamodb#InvalidEndpointException":
      throw await deserializeAws_json1_0InvalidEndpointExceptionResponse(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
      throw await deserializeAws_json1_0ProvisionedThroughputExceededExceptionResponse(parsedOutput, context);
    case "RequestLimitExceeded":
    case "com.amazonaws.dynamodb#RequestLimitExceeded":
      throw await deserializeAws_json1_0RequestLimitExceededResponse(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.dynamodb#ResourceNotFoundException":
      throw await deserializeAws_json1_0ResourceNotFoundExceptionResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError2({
        output,
        parsedBody,
        exceptionCtor: DynamoDBServiceException,
        errorCode
      });
  }
};
var deserializeAws_json1_0UpdateItemCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_0UpdateItemCommandError(output, context);
  }
  const data = await parseBody6(output.body, context);
  let contents = {};
  contents = deserializeAws_json1_0UpdateItemOutput(data, context);
  const response = {
    $metadata: deserializeMetadata8(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_json1_0UpdateItemCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody6(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode3(output, parsedOutput.body);
  switch (errorCode) {
    case "ConditionalCheckFailedException":
    case "com.amazonaws.dynamodb#ConditionalCheckFailedException":
      throw await deserializeAws_json1_0ConditionalCheckFailedExceptionResponse(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.dynamodb#InternalServerError":
      throw await deserializeAws_json1_0InternalServerErrorResponse(parsedOutput, context);
    case "InvalidEndpointException":
    case "com.amazonaws.dynamodb#InvalidEndpointException":
      throw await deserializeAws_json1_0InvalidEndpointExceptionResponse(parsedOutput, context);
    case "ItemCollectionSizeLimitExceededException":
    case "com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException":
      throw await deserializeAws_json1_0ItemCollectionSizeLimitExceededExceptionResponse(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
      throw await deserializeAws_json1_0ProvisionedThroughputExceededExceptionResponse(parsedOutput, context);
    case "RequestLimitExceeded":
    case "com.amazonaws.dynamodb#RequestLimitExceeded":
      throw await deserializeAws_json1_0RequestLimitExceededResponse(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.dynamodb#ResourceNotFoundException":
      throw await deserializeAws_json1_0ResourceNotFoundExceptionResponse(parsedOutput, context);
    case "TransactionConflictException":
    case "com.amazonaws.dynamodb#TransactionConflictException":
      throw await deserializeAws_json1_0TransactionConflictExceptionResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError2({
        output,
        parsedBody,
        exceptionCtor: DynamoDBServiceException,
        errorCode
      });
  }
};
var deserializeAws_json1_0ConditionalCheckFailedExceptionResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_json1_0ConditionalCheckFailedException(body, context);
  const exception = new ConditionalCheckFailedException({
    $metadata: deserializeMetadata8(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var deserializeAws_json1_0InternalServerErrorResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_json1_0InternalServerError(body, context);
  const exception = new InternalServerError({
    $metadata: deserializeMetadata8(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var deserializeAws_json1_0InvalidEndpointExceptionResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_json1_0InvalidEndpointException(body, context);
  const exception = new InvalidEndpointException({
    $metadata: deserializeMetadata8(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var deserializeAws_json1_0ItemCollectionSizeLimitExceededExceptionResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_json1_0ItemCollectionSizeLimitExceededException(body, context);
  const exception = new ItemCollectionSizeLimitExceededException({
    $metadata: deserializeMetadata8(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var deserializeAws_json1_0ProvisionedThroughputExceededExceptionResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_json1_0ProvisionedThroughputExceededException(body, context);
  const exception = new ProvisionedThroughputExceededException({
    $metadata: deserializeMetadata8(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var deserializeAws_json1_0RequestLimitExceededResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_json1_0RequestLimitExceeded(body, context);
  const exception = new RequestLimitExceeded({
    $metadata: deserializeMetadata8(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var deserializeAws_json1_0ResourceNotFoundExceptionResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_json1_0ResourceNotFoundException(body, context);
  const exception = new ResourceNotFoundException2({
    $metadata: deserializeMetadata8(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var deserializeAws_json1_0TransactionConflictExceptionResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_json1_0TransactionConflictException(body, context);
  const exception = new TransactionConflictException({
    $metadata: deserializeMetadata8(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var serializeAws_json1_0AttributeNameList = (input, context) => {
  return input.filter((e10) => e10 != null).map((entry) => {
    return entry;
  });
};
var serializeAws_json1_0AttributeUpdates = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = serializeAws_json1_0AttributeValueUpdate(value, context);
    return acc;
  }, {});
};
var serializeAws_json1_0AttributeValue = (input, context) => {
  return AttributeValue.visit(input, {
    B: (value) => ({ B: context.base64Encoder(value) }),
    BOOL: (value) => ({ BOOL: value }),
    BS: (value) => ({ BS: serializeAws_json1_0BinarySetAttributeValue(value, context) }),
    L: (value) => ({ L: serializeAws_json1_0ListAttributeValue(value, context) }),
    M: (value) => ({ M: serializeAws_json1_0MapAttributeValue(value, context) }),
    N: (value) => ({ N: value }),
    NS: (value) => ({ NS: serializeAws_json1_0NumberSetAttributeValue(value, context) }),
    NULL: (value) => ({ NULL: value }),
    S: (value) => ({ S: value }),
    SS: (value) => ({ SS: serializeAws_json1_0StringSetAttributeValue(value, context) }),
    _: (name, value) => ({ name: value })
  });
};
var serializeAws_json1_0AttributeValueList = (input, context) => {
  return input.filter((e10) => e10 != null).map((entry) => {
    return serializeAws_json1_0AttributeValue(entry, context);
  });
};
var serializeAws_json1_0AttributeValueUpdate = (input, context) => {
  return {
    ...input.Action != null && { Action: input.Action },
    ...input.Value != null && { Value: serializeAws_json1_0AttributeValue(input.Value, context) }
  };
};
var serializeAws_json1_0BatchGetItemInput = (input, context) => {
  return {
    ...input.RequestItems != null && {
      RequestItems: serializeAws_json1_0BatchGetRequestMap(input.RequestItems, context)
    },
    ...input.ReturnConsumedCapacity != null && { ReturnConsumedCapacity: input.ReturnConsumedCapacity }
  };
};
var serializeAws_json1_0BatchGetRequestMap = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = serializeAws_json1_0KeysAndAttributes(value, context);
    return acc;
  }, {});
};
var serializeAws_json1_0BatchWriteItemInput = (input, context) => {
  return {
    ...input.RequestItems != null && {
      RequestItems: serializeAws_json1_0BatchWriteItemRequestMap(input.RequestItems, context)
    },
    ...input.ReturnConsumedCapacity != null && { ReturnConsumedCapacity: input.ReturnConsumedCapacity },
    ...input.ReturnItemCollectionMetrics != null && {
      ReturnItemCollectionMetrics: input.ReturnItemCollectionMetrics
    }
  };
};
var serializeAws_json1_0BatchWriteItemRequestMap = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = serializeAws_json1_0WriteRequests(value, context);
    return acc;
  }, {});
};
var serializeAws_json1_0BinarySetAttributeValue = (input, context) => {
  return input.filter((e10) => e10 != null).map((entry) => {
    return context.base64Encoder(entry);
  });
};
var serializeAws_json1_0Condition = (input, context) => {
  return {
    ...input.AttributeValueList != null && {
      AttributeValueList: serializeAws_json1_0AttributeValueList(input.AttributeValueList, context)
    },
    ...input.ComparisonOperator != null && { ComparisonOperator: input.ComparisonOperator }
  };
};
var serializeAws_json1_0DeleteItemInput = (input, context) => {
  return {
    ...input.ConditionExpression != null && { ConditionExpression: input.ConditionExpression },
    ...input.ConditionalOperator != null && { ConditionalOperator: input.ConditionalOperator },
    ...input.Expected != null && { Expected: serializeAws_json1_0ExpectedAttributeMap(input.Expected, context) },
    ...input.ExpressionAttributeNames != null && {
      ExpressionAttributeNames: serializeAws_json1_0ExpressionAttributeNameMap(input.ExpressionAttributeNames, context)
    },
    ...input.ExpressionAttributeValues != null && {
      ExpressionAttributeValues: serializeAws_json1_0ExpressionAttributeValueMap(input.ExpressionAttributeValues, context)
    },
    ...input.Key != null && { Key: serializeAws_json1_0Key(input.Key, context) },
    ...input.ReturnConsumedCapacity != null && { ReturnConsumedCapacity: input.ReturnConsumedCapacity },
    ...input.ReturnItemCollectionMetrics != null && {
      ReturnItemCollectionMetrics: input.ReturnItemCollectionMetrics
    },
    ...input.ReturnValues != null && { ReturnValues: input.ReturnValues },
    ...input.TableName != null && { TableName: input.TableName }
  };
};
var serializeAws_json1_0DeleteRequest = (input, context) => {
  return {
    ...input.Key != null && { Key: serializeAws_json1_0Key(input.Key, context) }
  };
};
var serializeAws_json1_0DescribeEndpointsRequest = (input, context) => {
  return {};
};
var serializeAws_json1_0ExpectedAttributeMap = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = serializeAws_json1_0ExpectedAttributeValue(value, context);
    return acc;
  }, {});
};
var serializeAws_json1_0ExpectedAttributeValue = (input, context) => {
  return {
    ...input.AttributeValueList != null && {
      AttributeValueList: serializeAws_json1_0AttributeValueList(input.AttributeValueList, context)
    },
    ...input.ComparisonOperator != null && { ComparisonOperator: input.ComparisonOperator },
    ...input.Exists != null && { Exists: input.Exists },
    ...input.Value != null && { Value: serializeAws_json1_0AttributeValue(input.Value, context) }
  };
};
var serializeAws_json1_0ExpressionAttributeNameMap = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
};
var serializeAws_json1_0ExpressionAttributeValueMap = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = serializeAws_json1_0AttributeValue(value, context);
    return acc;
  }, {});
};
var serializeAws_json1_0FilterConditionMap = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = serializeAws_json1_0Condition(value, context);
    return acc;
  }, {});
};
var serializeAws_json1_0Key = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = serializeAws_json1_0AttributeValue(value, context);
    return acc;
  }, {});
};
var serializeAws_json1_0KeyConditions = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = serializeAws_json1_0Condition(value, context);
    return acc;
  }, {});
};
var serializeAws_json1_0KeyList = (input, context) => {
  return input.filter((e10) => e10 != null).map((entry) => {
    return serializeAws_json1_0Key(entry, context);
  });
};
var serializeAws_json1_0KeysAndAttributes = (input, context) => {
  return {
    ...input.AttributesToGet != null && {
      AttributesToGet: serializeAws_json1_0AttributeNameList(input.AttributesToGet, context)
    },
    ...input.ConsistentRead != null && { ConsistentRead: input.ConsistentRead },
    ...input.ExpressionAttributeNames != null && {
      ExpressionAttributeNames: serializeAws_json1_0ExpressionAttributeNameMap(input.ExpressionAttributeNames, context)
    },
    ...input.Keys != null && { Keys: serializeAws_json1_0KeyList(input.Keys, context) },
    ...input.ProjectionExpression != null && { ProjectionExpression: input.ProjectionExpression }
  };
};
var serializeAws_json1_0ListAttributeValue = (input, context) => {
  return input.filter((e10) => e10 != null).map((entry) => {
    return serializeAws_json1_0AttributeValue(entry, context);
  });
};
var serializeAws_json1_0MapAttributeValue = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = serializeAws_json1_0AttributeValue(value, context);
    return acc;
  }, {});
};
var serializeAws_json1_0NumberSetAttributeValue = (input, context) => {
  return input.filter((e10) => e10 != null).map((entry) => {
    return entry;
  });
};
var serializeAws_json1_0PutItemInput = (input, context) => {
  return {
    ...input.ConditionExpression != null && { ConditionExpression: input.ConditionExpression },
    ...input.ConditionalOperator != null && { ConditionalOperator: input.ConditionalOperator },
    ...input.Expected != null && { Expected: serializeAws_json1_0ExpectedAttributeMap(input.Expected, context) },
    ...input.ExpressionAttributeNames != null && {
      ExpressionAttributeNames: serializeAws_json1_0ExpressionAttributeNameMap(input.ExpressionAttributeNames, context)
    },
    ...input.ExpressionAttributeValues != null && {
      ExpressionAttributeValues: serializeAws_json1_0ExpressionAttributeValueMap(input.ExpressionAttributeValues, context)
    },
    ...input.Item != null && { Item: serializeAws_json1_0PutItemInputAttributeMap(input.Item, context) },
    ...input.ReturnConsumedCapacity != null && { ReturnConsumedCapacity: input.ReturnConsumedCapacity },
    ...input.ReturnItemCollectionMetrics != null && {
      ReturnItemCollectionMetrics: input.ReturnItemCollectionMetrics
    },
    ...input.ReturnValues != null && { ReturnValues: input.ReturnValues },
    ...input.TableName != null && { TableName: input.TableName }
  };
};
var serializeAws_json1_0PutItemInputAttributeMap = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = serializeAws_json1_0AttributeValue(value, context);
    return acc;
  }, {});
};
var serializeAws_json1_0PutRequest = (input, context) => {
  return {
    ...input.Item != null && { Item: serializeAws_json1_0PutItemInputAttributeMap(input.Item, context) }
  };
};
var serializeAws_json1_0QueryInput = (input, context) => {
  return {
    ...input.AttributesToGet != null && {
      AttributesToGet: serializeAws_json1_0AttributeNameList(input.AttributesToGet, context)
    },
    ...input.ConditionalOperator != null && { ConditionalOperator: input.ConditionalOperator },
    ...input.ConsistentRead != null && { ConsistentRead: input.ConsistentRead },
    ...input.ExclusiveStartKey != null && {
      ExclusiveStartKey: serializeAws_json1_0Key(input.ExclusiveStartKey, context)
    },
    ...input.ExpressionAttributeNames != null && {
      ExpressionAttributeNames: serializeAws_json1_0ExpressionAttributeNameMap(input.ExpressionAttributeNames, context)
    },
    ...input.ExpressionAttributeValues != null && {
      ExpressionAttributeValues: serializeAws_json1_0ExpressionAttributeValueMap(input.ExpressionAttributeValues, context)
    },
    ...input.FilterExpression != null && { FilterExpression: input.FilterExpression },
    ...input.IndexName != null && { IndexName: input.IndexName },
    ...input.KeyConditionExpression != null && { KeyConditionExpression: input.KeyConditionExpression },
    ...input.KeyConditions != null && {
      KeyConditions: serializeAws_json1_0KeyConditions(input.KeyConditions, context)
    },
    ...input.Limit != null && { Limit: input.Limit },
    ...input.ProjectionExpression != null && { ProjectionExpression: input.ProjectionExpression },
    ...input.QueryFilter != null && {
      QueryFilter: serializeAws_json1_0FilterConditionMap(input.QueryFilter, context)
    },
    ...input.ReturnConsumedCapacity != null && { ReturnConsumedCapacity: input.ReturnConsumedCapacity },
    ...input.ScanIndexForward != null && { ScanIndexForward: input.ScanIndexForward },
    ...input.Select != null && { Select: input.Select },
    ...input.TableName != null && { TableName: input.TableName }
  };
};
var serializeAws_json1_0StringSetAttributeValue = (input, context) => {
  return input.filter((e10) => e10 != null).map((entry) => {
    return entry;
  });
};
var serializeAws_json1_0UpdateItemInput = (input, context) => {
  return {
    ...input.AttributeUpdates != null && {
      AttributeUpdates: serializeAws_json1_0AttributeUpdates(input.AttributeUpdates, context)
    },
    ...input.ConditionExpression != null && { ConditionExpression: input.ConditionExpression },
    ...input.ConditionalOperator != null && { ConditionalOperator: input.ConditionalOperator },
    ...input.Expected != null && { Expected: serializeAws_json1_0ExpectedAttributeMap(input.Expected, context) },
    ...input.ExpressionAttributeNames != null && {
      ExpressionAttributeNames: serializeAws_json1_0ExpressionAttributeNameMap(input.ExpressionAttributeNames, context)
    },
    ...input.ExpressionAttributeValues != null && {
      ExpressionAttributeValues: serializeAws_json1_0ExpressionAttributeValueMap(input.ExpressionAttributeValues, context)
    },
    ...input.Key != null && { Key: serializeAws_json1_0Key(input.Key, context) },
    ...input.ReturnConsumedCapacity != null && { ReturnConsumedCapacity: input.ReturnConsumedCapacity },
    ...input.ReturnItemCollectionMetrics != null && {
      ReturnItemCollectionMetrics: input.ReturnItemCollectionMetrics
    },
    ...input.ReturnValues != null && { ReturnValues: input.ReturnValues },
    ...input.TableName != null && { TableName: input.TableName },
    ...input.UpdateExpression != null && { UpdateExpression: input.UpdateExpression }
  };
};
var serializeAws_json1_0WriteRequest = (input, context) => {
  return {
    ...input.DeleteRequest != null && {
      DeleteRequest: serializeAws_json1_0DeleteRequest(input.DeleteRequest, context)
    },
    ...input.PutRequest != null && { PutRequest: serializeAws_json1_0PutRequest(input.PutRequest, context) }
  };
};
var serializeAws_json1_0WriteRequests = (input, context) => {
  return input.filter((e10) => e10 != null).map((entry) => {
    return serializeAws_json1_0WriteRequest(entry, context);
  });
};
var deserializeAws_json1_0AttributeMap = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = deserializeAws_json1_0AttributeValue(expectUnion2(value), context);
    return acc;
  }, {});
};
var deserializeAws_json1_0AttributeNameList = (output, context) => {
  const retVal = (output || []).filter((e10) => e10 != null).map((entry) => {
    if (entry === null) {
      return null;
    }
    return expectString2(entry);
  });
  return retVal;
};
var deserializeAws_json1_0AttributeValue = (output, context) => {
  if (output.B != null) {
    return {
      B: context.base64Decoder(output.B)
    };
  }
  if (expectBoolean(output.BOOL) !== void 0) {
    return { BOOL: expectBoolean(output.BOOL) };
  }
  if (output.BS != null) {
    return {
      BS: deserializeAws_json1_0BinarySetAttributeValue(output.BS, context)
    };
  }
  if (output.L != null) {
    return {
      L: deserializeAws_json1_0ListAttributeValue(output.L, context)
    };
  }
  if (output.M != null) {
    return {
      M: deserializeAws_json1_0MapAttributeValue(output.M, context)
    };
  }
  if (expectString2(output.N) !== void 0) {
    return { N: expectString2(output.N) };
  }
  if (output.NS != null) {
    return {
      NS: deserializeAws_json1_0NumberSetAttributeValue(output.NS, context)
    };
  }
  if (expectBoolean(output.NULL) !== void 0) {
    return { NULL: expectBoolean(output.NULL) };
  }
  if (expectString2(output.S) !== void 0) {
    return { S: expectString2(output.S) };
  }
  if (output.SS != null) {
    return {
      SS: deserializeAws_json1_0StringSetAttributeValue(output.SS, context)
    };
  }
  return { $unknown: Object.entries(output)[0] };
};
var deserializeAws_json1_0BatchGetItemOutput = (output, context) => {
  return {
    ConsumedCapacity: output.ConsumedCapacity != null ? deserializeAws_json1_0ConsumedCapacityMultiple(output.ConsumedCapacity, context) : void 0,
    Responses: output.Responses != null ? deserializeAws_json1_0BatchGetResponseMap(output.Responses, context) : void 0,
    UnprocessedKeys: output.UnprocessedKeys != null ? deserializeAws_json1_0BatchGetRequestMap(output.UnprocessedKeys, context) : void 0
  };
};
var deserializeAws_json1_0BatchGetRequestMap = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = deserializeAws_json1_0KeysAndAttributes(value, context);
    return acc;
  }, {});
};
var deserializeAws_json1_0BatchGetResponseMap = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = deserializeAws_json1_0ItemList(value, context);
    return acc;
  }, {});
};
var deserializeAws_json1_0BatchWriteItemOutput = (output, context) => {
  return {
    ConsumedCapacity: output.ConsumedCapacity != null ? deserializeAws_json1_0ConsumedCapacityMultiple(output.ConsumedCapacity, context) : void 0,
    ItemCollectionMetrics: output.ItemCollectionMetrics != null ? deserializeAws_json1_0ItemCollectionMetricsPerTable(output.ItemCollectionMetrics, context) : void 0,
    UnprocessedItems: output.UnprocessedItems != null ? deserializeAws_json1_0BatchWriteItemRequestMap(output.UnprocessedItems, context) : void 0
  };
};
var deserializeAws_json1_0BatchWriteItemRequestMap = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = deserializeAws_json1_0WriteRequests(value, context);
    return acc;
  }, {});
};
var deserializeAws_json1_0BinarySetAttributeValue = (output, context) => {
  const retVal = (output || []).filter((e10) => e10 != null).map((entry) => {
    if (entry === null) {
      return null;
    }
    return context.base64Decoder(entry);
  });
  return retVal;
};
var deserializeAws_json1_0Capacity = (output, context) => {
  return {
    CapacityUnits: limitedParseDouble(output.CapacityUnits),
    ReadCapacityUnits: limitedParseDouble(output.ReadCapacityUnits),
    WriteCapacityUnits: limitedParseDouble(output.WriteCapacityUnits)
  };
};
var deserializeAws_json1_0ConditionalCheckFailedException = (output, context) => {
  return {
    message: expectString2(output.message)
  };
};
var deserializeAws_json1_0ConsumedCapacity = (output, context) => {
  return {
    CapacityUnits: limitedParseDouble(output.CapacityUnits),
    GlobalSecondaryIndexes: output.GlobalSecondaryIndexes != null ? deserializeAws_json1_0SecondaryIndexesCapacityMap(output.GlobalSecondaryIndexes, context) : void 0,
    LocalSecondaryIndexes: output.LocalSecondaryIndexes != null ? deserializeAws_json1_0SecondaryIndexesCapacityMap(output.LocalSecondaryIndexes, context) : void 0,
    ReadCapacityUnits: limitedParseDouble(output.ReadCapacityUnits),
    Table: output.Table != null ? deserializeAws_json1_0Capacity(output.Table, context) : void 0,
    TableName: expectString2(output.TableName),
    WriteCapacityUnits: limitedParseDouble(output.WriteCapacityUnits)
  };
};
var deserializeAws_json1_0ConsumedCapacityMultiple = (output, context) => {
  const retVal = (output || []).filter((e10) => e10 != null).map((entry) => {
    if (entry === null) {
      return null;
    }
    return deserializeAws_json1_0ConsumedCapacity(entry, context);
  });
  return retVal;
};
var deserializeAws_json1_0DeleteItemOutput = (output, context) => {
  return {
    Attributes: output.Attributes != null ? deserializeAws_json1_0AttributeMap(output.Attributes, context) : void 0,
    ConsumedCapacity: output.ConsumedCapacity != null ? deserializeAws_json1_0ConsumedCapacity(output.ConsumedCapacity, context) : void 0,
    ItemCollectionMetrics: output.ItemCollectionMetrics != null ? deserializeAws_json1_0ItemCollectionMetrics(output.ItemCollectionMetrics, context) : void 0
  };
};
var deserializeAws_json1_0DeleteRequest = (output, context) => {
  return {
    Key: output.Key != null ? deserializeAws_json1_0Key(output.Key, context) : void 0
  };
};
var deserializeAws_json1_0DescribeEndpointsResponse = (output, context) => {
  return {
    Endpoints: output.Endpoints != null ? deserializeAws_json1_0Endpoints(output.Endpoints, context) : void 0
  };
};
var deserializeAws_json1_0Endpoint = (output, context) => {
  return {
    Address: expectString2(output.Address),
    CachePeriodInMinutes: expectLong2(output.CachePeriodInMinutes)
  };
};
var deserializeAws_json1_0Endpoints = (output, context) => {
  const retVal = (output || []).filter((e10) => e10 != null).map((entry) => {
    if (entry === null) {
      return null;
    }
    return deserializeAws_json1_0Endpoint(entry, context);
  });
  return retVal;
};
var deserializeAws_json1_0ExpressionAttributeNameMap = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = expectString2(value);
    return acc;
  }, {});
};
var deserializeAws_json1_0InternalServerError = (output, context) => {
  return {
    message: expectString2(output.message)
  };
};
var deserializeAws_json1_0InvalidEndpointException = (output, context) => {
  return {
    Message: expectString2(output.Message)
  };
};
var deserializeAws_json1_0ItemCollectionKeyAttributeMap = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = deserializeAws_json1_0AttributeValue(expectUnion2(value), context);
    return acc;
  }, {});
};
var deserializeAws_json1_0ItemCollectionMetrics = (output, context) => {
  return {
    ItemCollectionKey: output.ItemCollectionKey != null ? deserializeAws_json1_0ItemCollectionKeyAttributeMap(output.ItemCollectionKey, context) : void 0,
    SizeEstimateRangeGB: output.SizeEstimateRangeGB != null ? deserializeAws_json1_0ItemCollectionSizeEstimateRange(output.SizeEstimateRangeGB, context) : void 0
  };
};
var deserializeAws_json1_0ItemCollectionMetricsMultiple = (output, context) => {
  const retVal = (output || []).filter((e10) => e10 != null).map((entry) => {
    if (entry === null) {
      return null;
    }
    return deserializeAws_json1_0ItemCollectionMetrics(entry, context);
  });
  return retVal;
};
var deserializeAws_json1_0ItemCollectionMetricsPerTable = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = deserializeAws_json1_0ItemCollectionMetricsMultiple(value, context);
    return acc;
  }, {});
};
var deserializeAws_json1_0ItemCollectionSizeEstimateRange = (output, context) => {
  const retVal = (output || []).filter((e10) => e10 != null).map((entry) => {
    if (entry === null) {
      return null;
    }
    return limitedParseDouble(entry);
  });
  return retVal;
};
var deserializeAws_json1_0ItemCollectionSizeLimitExceededException = (output, context) => {
  return {
    message: expectString2(output.message)
  };
};
var deserializeAws_json1_0ItemList = (output, context) => {
  const retVal = (output || []).filter((e10) => e10 != null).map((entry) => {
    if (entry === null) {
      return null;
    }
    return deserializeAws_json1_0AttributeMap(entry, context);
  });
  return retVal;
};
var deserializeAws_json1_0Key = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = deserializeAws_json1_0AttributeValue(expectUnion2(value), context);
    return acc;
  }, {});
};
var deserializeAws_json1_0KeyList = (output, context) => {
  const retVal = (output || []).filter((e10) => e10 != null).map((entry) => {
    if (entry === null) {
      return null;
    }
    return deserializeAws_json1_0Key(entry, context);
  });
  return retVal;
};
var deserializeAws_json1_0KeysAndAttributes = (output, context) => {
  return {
    AttributesToGet: output.AttributesToGet != null ? deserializeAws_json1_0AttributeNameList(output.AttributesToGet, context) : void 0,
    ConsistentRead: expectBoolean(output.ConsistentRead),
    ExpressionAttributeNames: output.ExpressionAttributeNames != null ? deserializeAws_json1_0ExpressionAttributeNameMap(output.ExpressionAttributeNames, context) : void 0,
    Keys: output.Keys != null ? deserializeAws_json1_0KeyList(output.Keys, context) : void 0,
    ProjectionExpression: expectString2(output.ProjectionExpression)
  };
};
var deserializeAws_json1_0ListAttributeValue = (output, context) => {
  const retVal = (output || []).filter((e10) => e10 != null).map((entry) => {
    if (entry === null) {
      return null;
    }
    return deserializeAws_json1_0AttributeValue(expectUnion2(entry), context);
  });
  return retVal;
};
var deserializeAws_json1_0MapAttributeValue = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = deserializeAws_json1_0AttributeValue(expectUnion2(value), context);
    return acc;
  }, {});
};
var deserializeAws_json1_0NumberSetAttributeValue = (output, context) => {
  const retVal = (output || []).filter((e10) => e10 != null).map((entry) => {
    if (entry === null) {
      return null;
    }
    return expectString2(entry);
  });
  return retVal;
};
var deserializeAws_json1_0ProvisionedThroughputExceededException = (output, context) => {
  return {
    message: expectString2(output.message)
  };
};
var deserializeAws_json1_0PutItemInputAttributeMap = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = deserializeAws_json1_0AttributeValue(expectUnion2(value), context);
    return acc;
  }, {});
};
var deserializeAws_json1_0PutItemOutput = (output, context) => {
  return {
    Attributes: output.Attributes != null ? deserializeAws_json1_0AttributeMap(output.Attributes, context) : void 0,
    ConsumedCapacity: output.ConsumedCapacity != null ? deserializeAws_json1_0ConsumedCapacity(output.ConsumedCapacity, context) : void 0,
    ItemCollectionMetrics: output.ItemCollectionMetrics != null ? deserializeAws_json1_0ItemCollectionMetrics(output.ItemCollectionMetrics, context) : void 0
  };
};
var deserializeAws_json1_0PutRequest = (output, context) => {
  return {
    Item: output.Item != null ? deserializeAws_json1_0PutItemInputAttributeMap(output.Item, context) : void 0
  };
};
var deserializeAws_json1_0QueryOutput = (output, context) => {
  return {
    ConsumedCapacity: output.ConsumedCapacity != null ? deserializeAws_json1_0ConsumedCapacity(output.ConsumedCapacity, context) : void 0,
    Count: expectInt322(output.Count),
    Items: output.Items != null ? deserializeAws_json1_0ItemList(output.Items, context) : void 0,
    LastEvaluatedKey: output.LastEvaluatedKey != null ? deserializeAws_json1_0Key(output.LastEvaluatedKey, context) : void 0,
    ScannedCount: expectInt322(output.ScannedCount)
  };
};
var deserializeAws_json1_0RequestLimitExceeded = (output, context) => {
  return {
    message: expectString2(output.message)
  };
};
var deserializeAws_json1_0ResourceNotFoundException = (output, context) => {
  return {
    message: expectString2(output.message)
  };
};
var deserializeAws_json1_0SecondaryIndexesCapacityMap = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = deserializeAws_json1_0Capacity(value, context);
    return acc;
  }, {});
};
var deserializeAws_json1_0StringSetAttributeValue = (output, context) => {
  const retVal = (output || []).filter((e10) => e10 != null).map((entry) => {
    if (entry === null) {
      return null;
    }
    return expectString2(entry);
  });
  return retVal;
};
var deserializeAws_json1_0TransactionConflictException = (output, context) => {
  return {
    message: expectString2(output.message)
  };
};
var deserializeAws_json1_0UpdateItemOutput = (output, context) => {
  return {
    Attributes: output.Attributes != null ? deserializeAws_json1_0AttributeMap(output.Attributes, context) : void 0,
    ConsumedCapacity: output.ConsumedCapacity != null ? deserializeAws_json1_0ConsumedCapacity(output.ConsumedCapacity, context) : void 0,
    ItemCollectionMetrics: output.ItemCollectionMetrics != null ? deserializeAws_json1_0ItemCollectionMetrics(output.ItemCollectionMetrics, context) : void 0
  };
};
var deserializeAws_json1_0WriteRequest = (output, context) => {
  return {
    DeleteRequest: output.DeleteRequest != null ? deserializeAws_json1_0DeleteRequest(output.DeleteRequest, context) : void 0,
    PutRequest: output.PutRequest != null ? deserializeAws_json1_0PutRequest(output.PutRequest, context) : void 0
  };
};
var deserializeAws_json1_0WriteRequests = (output, context) => {
  const retVal = (output || []).filter((e10) => e10 != null).map((entry) => {
    if (entry === null) {
      return null;
    }
    return deserializeAws_json1_0WriteRequest(entry, context);
  });
  return retVal;
};
var deserializeMetadata8 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
var collectBody7 = (streamBody = new Uint8Array(), context) => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
var collectBodyString7 = (streamBody, context) => collectBody7(streamBody, context).then((body) => context.utf8Encoder(body));
var buildHttpRpcRequest3 = async (context, headers, path, resolvedHostname, body) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const contents = {
    protocol,
    hostname,
    port,
    method: "POST",
    path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
    headers
  };
  if (resolvedHostname !== void 0) {
    contents.hostname = resolvedHostname;
  }
  if (body !== void 0) {
    contents.body = body;
  }
  return new HttpRequest2(contents);
};
var parseBody6 = (streamBody, context) => collectBodyString7(streamBody, context).then((encoded) => {
  if (encoded.length) {
    return JSON.parse(encoded);
  }
  return {};
});
var parseErrorBody6 = async (errorBody, context) => {
  const value = await parseBody6(errorBody, context);
  value.message = value.message ?? value.Message;
  return value;
};
var loadRestJsonErrorCode3 = (output, data) => {
  const findKey = (object2, key) => Object.keys(object2).find((k10) => k10.toLowerCase() === key.toLowerCase());
  const sanitizeErrorCode = (rawValue) => {
    let cleanValue = rawValue;
    if (typeof cleanValue === "number") {
      cleanValue = cleanValue.toString();
    }
    if (cleanValue.indexOf(",") >= 0) {
      cleanValue = cleanValue.split(",")[0];
    }
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  };
  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== void 0) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }
  if (data.code !== void 0) {
    return sanitizeErrorCode(data.code);
  }
  if (data["__type"] !== void 0) {
    return sanitizeErrorCode(data["__type"]);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/commands/BatchGetItemCommand.js
var BatchGetItemCommand = class extends Command2 {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin2(configuration, BatchGetItemCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "DynamoDBClient";
    const commandName = "BatchGetItemCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: BatchGetItemInputFilterSensitiveLog,
      outputFilterSensitiveLog: BatchGetItemOutputFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_json1_0BatchGetItemCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_json1_0BatchGetItemCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/commands/BatchWriteItemCommand.js
var BatchWriteItemCommand = class extends Command2 {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin2(configuration, BatchWriteItemCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "DynamoDBClient";
    const commandName = "BatchWriteItemCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: BatchWriteItemInputFilterSensitiveLog,
      outputFilterSensitiveLog: BatchWriteItemOutputFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_json1_0BatchWriteItemCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_json1_0BatchWriteItemCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DeleteItemCommand.js
var DeleteItemCommand = class extends Command2 {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin2(configuration, DeleteItemCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "DynamoDBClient";
    const commandName = "DeleteItemCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: DeleteItemInputFilterSensitiveLog,
      outputFilterSensitiveLog: DeleteItemOutputFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_json1_0DeleteItemCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_json1_0DeleteItemCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DescribeEndpointsCommand.js
var DescribeEndpointsCommand = class extends Command2 {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin2(configuration, DescribeEndpointsCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "DynamoDBClient";
    const commandName = "DescribeEndpointsCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: DescribeEndpointsRequestFilterSensitiveLog,
      outputFilterSensitiveLog: DescribeEndpointsResponseFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_json1_0DescribeEndpointsCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_json1_0DescribeEndpointsCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/commands/PutItemCommand.js
var PutItemCommand = class extends Command2 {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin2(configuration, PutItemCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "DynamoDBClient";
    const commandName = "PutItemCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: PutItemInputFilterSensitiveLog,
      outputFilterSensitiveLog: PutItemOutputFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_json1_0PutItemCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_json1_0PutItemCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/commands/QueryCommand.js
var QueryCommand = class extends Command2 {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin2(configuration, QueryCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "DynamoDBClient";
    const commandName = "QueryCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: QueryInputFilterSensitiveLog,
      outputFilterSensitiveLog: QueryOutputFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_json1_0QueryCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_json1_0QueryCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/commands/UpdateItemCommand.js
var UpdateItemCommand = class extends Command2 {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin2(configuration, UpdateItemCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "DynamoDBClient";
    const commandName = "UpdateItemCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: UpdateItemInputFilterSensitiveLog,
      outputFilterSensitiveLog: UpdateItemOutputFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_json1_0UpdateItemCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_json1_0UpdateItemCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/config-resolver/dist-es/endpointsConfig/NodeUseDualstackEndpointConfigOptions.js
var ENV_USE_DUALSTACK_ENDPOINT2 = "AWS_USE_DUALSTACK_ENDPOINT";
var CONFIG_USE_DUALSTACK_ENDPOINT2 = "use_dualstack_endpoint";
var NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS2 = {
  environmentVariableSelector: (env3) => booleanSelector(env3, ENV_USE_DUALSTACK_ENDPOINT2, SelectorType.ENV),
  configFileSelector: (profile) => booleanSelector(profile, CONFIG_USE_DUALSTACK_ENDPOINT2, SelectorType.CONFIG),
  default: false
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/config-resolver/dist-es/endpointsConfig/NodeUseFipsEndpointConfigOptions.js
var ENV_USE_FIPS_ENDPOINT2 = "AWS_USE_FIPS_ENDPOINT";
var CONFIG_USE_FIPS_ENDPOINT2 = "use_fips_endpoint";
var NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS2 = {
  environmentVariableSelector: (env3) => booleanSelector(env3, ENV_USE_FIPS_ENDPOINT2, SelectorType.ENV),
  configFileSelector: (profile) => booleanSelector(profile, CONFIG_USE_FIPS_ENDPOINT2, SelectorType.CONFIG),
  default: false
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/config-resolver/dist-es/regionConfig/config.js
var REGION_ENV_NAME2 = "AWS_REGION";
var REGION_INI_NAME2 = "region";
var NODE_REGION_CONFIG_OPTIONS2 = {
  environmentVariableSelector: (env3) => env3[REGION_ENV_NAME2],
  configFileSelector: (profile) => profile[REGION_INI_NAME2],
  default: () => {
    throw new Error("Region is missing");
  }
};
var NODE_REGION_CONFIG_FILE_OPTIONS2 = {
  preferredFile: "credentials"
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/config-resolver/dist-es/regionConfig/isFipsRegion.js
var isFipsRegion2 = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/config-resolver/dist-es/regionConfig/getRealRegion.js
var getRealRegion2 = (region) => isFipsRegion2(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region;

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/config-resolver/dist-es/regionConfig/resolveRegionConfig.js
var resolveRegionConfig2 = (input) => {
  const { region, useFipsEndpoint } = input;
  if (!region) {
    throw new Error("Region is missing");
  }
  return {
    ...input,
    region: async () => {
      if (typeof region === "string") {
        return getRealRegion2(region);
      }
      const providedRegion = await region();
      return getRealRegion2(providedRegion);
    },
    useFipsEndpoint: async () => {
      const providedRegion = typeof region === "string" ? region : await region();
      if (isFipsRegion2(providedRegion)) {
        return true;
      }
      return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
    }
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-content-length/dist-es/index.js
var CONTENT_LENGTH_HEADER3 = "content-length";
function contentLengthMiddleware2(bodyLengthChecker) {
  return (next) => async (args) => {
    const request2 = args.request;
    if (HttpRequest2.isInstance(request2)) {
      const { body, headers } = request2;
      if (body && Object.keys(headers).map((str) => str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER3) === -1) {
        try {
          const length = bodyLengthChecker(body);
          request2.headers = {
            ...request2.headers,
            [CONTENT_LENGTH_HEADER3]: String(length)
          };
        } catch (error) {
        }
      }
    }
    return next({
      ...args,
      request: request2
    });
  };
}
var contentLengthMiddlewareOptions2 = {
  step: "build",
  tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
  name: "contentLengthMiddleware",
  override: true
};
var getContentLengthPlugin2 = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(contentLengthMiddleware2(options.bodyLengthChecker), contentLengthMiddlewareOptions2);
  }
});

// ../../node_modules/@aws-sdk/middleware-endpoint-discovery/dist-es/configurations.js
var ENV_ENDPOINT_DISCOVERY = ["AWS_ENABLE_ENDPOINT_DISCOVERY", "AWS_ENDPOINT_DISCOVERY_ENABLED"];
var CONFIG_ENDPOINT_DISCOVERY = "endpoint_discovery_enabled";
var isFalsy = (value) => ["false", "0"].indexOf(value) >= 0;
var NODE_ENDPOINT_DISCOVERY_CONFIG_OPTIONS = {
  environmentVariableSelector: (env3) => {
    for (let i10 = 0; i10 < ENV_ENDPOINT_DISCOVERY.length; i10++) {
      const envKey = ENV_ENDPOINT_DISCOVERY[i10];
      if (envKey in env3) {
        const value = env3[envKey];
        if (value === "") {
          throw Error(`Environment variable ${envKey} can't be empty of undefined, got "${value}"`);
        }
        return !isFalsy(value);
      }
    }
  },
  configFileSelector: (profile) => {
    if (CONFIG_ENDPOINT_DISCOVERY in profile) {
      const value = profile[CONFIG_ENDPOINT_DISCOVERY];
      if (value === void 0) {
        throw Error(`Shared config entry ${CONFIG_ENDPOINT_DISCOVERY} can't be undefined, got "${value}"`);
      }
      return !isFalsy(value);
    }
  },
  default: void 0
};

// ../../node_modules/@aws-sdk/middleware-endpoint-discovery/node_modules/@aws-sdk/protocol-http/dist-es/FieldPosition.js
var FieldPosition3;
(function(FieldPosition4) {
  FieldPosition4[FieldPosition4["HEADER"] = 0] = "HEADER";
  FieldPosition4[FieldPosition4["TRAILER"] = 1] = "TRAILER";
})(FieldPosition3 || (FieldPosition3 = {}));

// ../../node_modules/@aws-sdk/endpoint-cache/dist-es/EndpointCache.js
var import_lru_cache = __toESM(require_lru_cache());
var EndpointCache = class {
  constructor(capacity) {
    this.cache = new import_lru_cache.default(capacity);
  }
  getEndpoint(key) {
    const endpointsWithExpiry = this.get(key);
    if (!endpointsWithExpiry || endpointsWithExpiry.length === 0) {
      return void 0;
    }
    const endpoints = endpointsWithExpiry.map((endpoint) => endpoint.Address);
    return endpoints[Math.floor(Math.random() * endpoints.length)];
  }
  get(key) {
    if (!this.has(key)) {
      return;
    }
    const value = this.cache.get(key);
    if (!value) {
      return;
    }
    const now = Date.now();
    const endpointsWithExpiry = value.filter((endpoint) => now < endpoint.Expires);
    if (endpointsWithExpiry.length === 0) {
      this.delete(key);
      return void 0;
    }
    return endpointsWithExpiry;
  }
  set(key, endpoints) {
    const now = Date.now();
    this.cache.set(key, endpoints.map(({ Address, CachePeriodInMinutes }) => ({
      Address,
      Expires: now + CachePeriodInMinutes * 60 * 1e3
    })));
  }
  delete(key) {
    this.cache.set(key, []);
  }
  has(key) {
    if (!this.cache.has(key)) {
      return false;
    }
    const endpoints = this.cache.peek(key);
    if (!endpoints) {
      return false;
    }
    return endpoints.length > 0;
  }
  clear() {
    this.cache.clear();
  }
};

// ../../node_modules/@aws-sdk/middleware-endpoint-discovery/dist-es/resolveEndpointDiscoveryConfig.js
var resolveEndpointDiscoveryConfig = (input, { endpointDiscoveryCommandCtor }) => ({
  ...input,
  endpointDiscoveryCommandCtor,
  endpointCache: new EndpointCache(input.endpointCacheSize ?? 1e3),
  endpointDiscoveryEnabled: input.endpointDiscoveryEnabled !== void 0 ? () => Promise.resolve(input.endpointDiscoveryEnabled) : input.endpointDiscoveryEnabledProvider,
  isClientEndpointDiscoveryEnabled: input.endpointDiscoveryEnabled !== void 0
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-host-header/dist-es/index.js
function resolveHostHeaderConfig2(input) {
  return input;
}
var hostHeaderMiddleware2 = (options) => (next) => async (args) => {
  if (!HttpRequest2.isInstance(args.request))
    return next(args);
  const { request: request2 } = args;
  const { handlerProtocol = "" } = options.requestHandler.metadata || {};
  if (handlerProtocol.indexOf("h2") >= 0 && !request2.headers[":authority"]) {
    delete request2.headers["host"];
    request2.headers[":authority"] = "";
  } else if (!request2.headers["host"]) {
    let host = request2.hostname;
    if (request2.port != null)
      host += `:${request2.port}`;
    request2.headers["host"] = host;
  }
  return next(args);
};
var hostHeaderMiddlewareOptions2 = {
  name: "hostHeaderMiddleware",
  step: "build",
  priority: "low",
  tags: ["HOST"],
  override: true
};
var getHostHeaderPlugin2 = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(hostHeaderMiddleware2(options), hostHeaderMiddlewareOptions2);
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js
var TRACE_ID_HEADER_NAME2 = "X-Amzn-Trace-Id";
var ENV_LAMBDA_FUNCTION_NAME2 = "AWS_LAMBDA_FUNCTION_NAME";
var ENV_TRACE_ID2 = "_X_AMZN_TRACE_ID";
var recursionDetectionMiddleware2 = (options) => (next) => async (args) => {
  const { request: request2 } = args;
  if (!HttpRequest2.isInstance(request2) || options.runtime !== "node" || request2.headers.hasOwnProperty(TRACE_ID_HEADER_NAME2)) {
    return next(args);
  }
  const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME2];
  const traceId = process.env[ENV_TRACE_ID2];
  const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
  if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
    request2.headers[TRACE_ID_HEADER_NAME2] = traceId;
  }
  return next({
    ...args,
    request: request2
  });
};
var addRecursionDetectionMiddlewareOptions2 = {
  step: "build",
  tags: ["RECURSION_DETECTION"],
  name: "recursionDetectionMiddleware",
  override: true,
  priority: "low"
};
var getRecursionDetectionPlugin2 = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(recursionDetectionMiddleware2(options), addRecursionDetectionMiddlewareOptions2);
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-retry/dist-es/util.js
var asSdkError2 = (error) => {
  if (error instanceof Error)
    return error;
  if (error instanceof Object)
    return Object.assign(new Error(), error);
  if (typeof error === "string")
    return new Error(error);
  return new Error(`AWS SDK error wrapper for ${error}`);
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-retry/dist-es/configurations.js
var ENV_MAX_ATTEMPTS2 = "AWS_MAX_ATTEMPTS";
var CONFIG_MAX_ATTEMPTS2 = "max_attempts";
var NODE_MAX_ATTEMPT_CONFIG_OPTIONS2 = {
  environmentVariableSelector: (env3) => {
    const value = env3[ENV_MAX_ATTEMPTS2];
    if (!value)
      return void 0;
    const maxAttempt = parseInt(value);
    if (Number.isNaN(maxAttempt)) {
      throw new Error(`Environment variable ${ENV_MAX_ATTEMPTS2} mast be a number, got "${value}"`);
    }
    return maxAttempt;
  },
  configFileSelector: (profile) => {
    const value = profile[CONFIG_MAX_ATTEMPTS2];
    if (!value)
      return void 0;
    const maxAttempt = parseInt(value);
    if (Number.isNaN(maxAttempt)) {
      throw new Error(`Shared config file entry ${CONFIG_MAX_ATTEMPTS2} mast be a number, got "${value}"`);
    }
    return maxAttempt;
  },
  default: DEFAULT_MAX_ATTEMPTS
};
var resolveRetryConfig2 = (input) => {
  const { retryStrategy } = input;
  const maxAttempts = normalizeProvider(input.maxAttempts ?? DEFAULT_MAX_ATTEMPTS);
  return {
    ...input,
    maxAttempts,
    retryStrategy: async () => {
      if (retryStrategy) {
        return retryStrategy;
      }
      const retryMode = await normalizeProvider(input.retryMode)();
      if (retryMode === RETRY_MODES.ADAPTIVE) {
        return new AdaptiveRetryStrategy(maxAttempts);
      }
      return new StandardRetryStrategy(maxAttempts);
    }
  };
};
var ENV_RETRY_MODE2 = "AWS_RETRY_MODE";
var CONFIG_RETRY_MODE2 = "retry_mode";
var NODE_RETRY_MODE_CONFIG_OPTIONS2 = {
  environmentVariableSelector: (env3) => env3[ENV_RETRY_MODE2],
  configFileSelector: (profile) => profile[CONFIG_RETRY_MODE2],
  default: DEFAULT_RETRY_MODE
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-retry/dist-es/retryMiddleware.js
var retryMiddleware2 = (options) => (next, context) => async (args) => {
  let retryStrategy = await options.retryStrategy();
  const maxAttempts = await options.maxAttempts();
  if (isRetryStrategyV22(retryStrategy)) {
    retryStrategy = retryStrategy;
    let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
    let lastError = new Error();
    let attempts = 0;
    let totalRetryDelay = 0;
    const { request: request2 } = args;
    if (HttpRequest2.isInstance(request2)) {
      request2.headers[INVOCATION_ID_HEADER] = v4_default();
    }
    while (true) {
      try {
        if (HttpRequest2.isInstance(request2)) {
          request2.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
        }
        const { response, output } = await next(args);
        retryStrategy.recordSuccess(retryToken);
        output.$metadata.attempts = attempts + 1;
        output.$metadata.totalRetryDelay = totalRetryDelay;
        return { response, output };
      } catch (e10) {
        const retryErrorInfo = getRetyErrorInto2(e10);
        lastError = asSdkError2(e10);
        try {
          retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
        } catch (refreshError) {
          if (!lastError.$metadata) {
            lastError.$metadata = {};
          }
          lastError.$metadata.attempts = attempts + 1;
          lastError.$metadata.totalRetryDelay = totalRetryDelay;
          throw lastError;
        }
        attempts = retryToken.getRetryCount();
        const delay = retryToken.getRetryDelay();
        totalRetryDelay += delay;
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
  } else {
    retryStrategy = retryStrategy;
    if (retryStrategy?.mode)
      context.userAgent = [...context.userAgent || [], ["cfg/retry-mode", retryStrategy.mode]];
    return retryStrategy.retry(next, args);
  }
};
var isRetryStrategyV22 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined";
var getRetyErrorInto2 = (error) => {
  const errorInfo = {
    errorType: getRetryErrorType2(error)
  };
  const retryAfterHint = getRetryAfterHint2(error.$response);
  if (retryAfterHint) {
    errorInfo.retryAfterHint = retryAfterHint;
  }
  return errorInfo;
};
var getRetryErrorType2 = (error) => {
  if (isThrottlingError(error))
    return "THROTTLING";
  if (isTransientError(error))
    return "TRANSIENT";
  if (isServerError(error))
    return "SERVER_ERROR";
  return "CLIENT_ERROR";
};
var retryMiddlewareOptions2 = {
  name: "retryMiddleware",
  tags: ["RETRY"],
  step: "finalizeRequest",
  priority: "high",
  override: true
};
var getRetryPlugin2 = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(retryMiddleware2(options), retryMiddlewareOptions2);
  }
});
var getRetryAfterHint2 = (response) => {
  if (!HttpResponse2.isInstance(response))
    return;
  const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
  if (!retryAfterHeaderName)
    return;
  const retryAfter = response.headers[retryAfterHeaderName];
  const retryAfterSeconds = Number(retryAfter);
  if (!Number.isNaN(retryAfterSeconds))
    return new Date(retryAfterSeconds * 1e3);
  const retryAfterDate = new Date(retryAfter);
  return retryAfterDate;
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/signature-v4/dist-es/constants.js
var ALGORITHM_QUERY_PARAM2 = "X-Amz-Algorithm";
var CREDENTIAL_QUERY_PARAM2 = "X-Amz-Credential";
var AMZ_DATE_QUERY_PARAM2 = "X-Amz-Date";
var SIGNED_HEADERS_QUERY_PARAM2 = "X-Amz-SignedHeaders";
var EXPIRES_QUERY_PARAM2 = "X-Amz-Expires";
var SIGNATURE_QUERY_PARAM2 = "X-Amz-Signature";
var TOKEN_QUERY_PARAM2 = "X-Amz-Security-Token";
var AUTH_HEADER2 = "authorization";
var AMZ_DATE_HEADER2 = AMZ_DATE_QUERY_PARAM2.toLowerCase();
var DATE_HEADER2 = "date";
var GENERATED_HEADERS2 = [AUTH_HEADER2, AMZ_DATE_HEADER2, DATE_HEADER2];
var SIGNATURE_HEADER2 = SIGNATURE_QUERY_PARAM2.toLowerCase();
var SHA256_HEADER3 = "x-amz-content-sha256";
var TOKEN_HEADER2 = TOKEN_QUERY_PARAM2.toLowerCase();
var ALWAYS_UNSIGNABLE_HEADERS2 = {
  authorization: true,
  "cache-control": true,
  connection: true,
  expect: true,
  from: true,
  "keep-alive": true,
  "max-forwards": true,
  pragma: true,
  referer: true,
  te: true,
  trailer: true,
  "transfer-encoding": true,
  upgrade: true,
  "user-agent": true,
  "x-amzn-trace-id": true
};
var PROXY_HEADER_PATTERN2 = /^proxy-/;
var SEC_HEADER_PATTERN2 = /^sec-/;
var ALGORITHM_IDENTIFIER2 = "AWS4-HMAC-SHA256";
var EVENT_ALGORITHM_IDENTIFIER2 = "AWS4-HMAC-SHA256-PAYLOAD";
var UNSIGNED_PAYLOAD3 = "UNSIGNED-PAYLOAD";
var MAX_CACHE_SIZE2 = 50;
var KEY_TYPE_IDENTIFIER2 = "aws4_request";
var MAX_PRESIGNED_TTL2 = 60 * 60 * 24 * 7;

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/signature-v4/dist-es/credentialDerivation.js
var signingKeyCache2 = {};
var cacheQueue2 = [];
var createScope2 = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER2}`;
var getSigningKey2 = async (sha256Constructor, credentials2, shortDate, region, service) => {
  const credsHash = await hmac3(sha256Constructor, credentials2.secretAccessKey, credentials2.accessKeyId);
  const cacheKey = `${shortDate}:${region}:${service}:${toHex(credsHash)}:${credentials2.sessionToken}`;
  if (cacheKey in signingKeyCache2) {
    return signingKeyCache2[cacheKey];
  }
  cacheQueue2.push(cacheKey);
  while (cacheQueue2.length > MAX_CACHE_SIZE2) {
    delete signingKeyCache2[cacheQueue2.shift()];
  }
  let key = `AWS4${credentials2.secretAccessKey}`;
  for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER2]) {
    key = await hmac3(sha256Constructor, key, signable);
  }
  return signingKeyCache2[cacheKey] = key;
};
var hmac3 = (ctor, secret, data) => {
  const hash2 = new ctor(secret);
  hash2.update(toUint8Array(data));
  return hash2.digest();
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/signature-v4/dist-es/getCanonicalHeaders.js
var getCanonicalHeaders2 = ({ headers }, unsignableHeaders, signableHeaders) => {
  const canonical = {};
  for (const headerName of Object.keys(headers).sort()) {
    if (headers[headerName] == void 0) {
      continue;
    }
    const canonicalHeaderName = headerName.toLowerCase();
    if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS2 || unsignableHeaders?.has(canonicalHeaderName) || PROXY_HEADER_PATTERN2.test(canonicalHeaderName) || SEC_HEADER_PATTERN2.test(canonicalHeaderName)) {
      if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
        continue;
      }
    }
    canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
  }
  return canonical;
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/signature-v4/dist-es/getCanonicalQuery.js
var getCanonicalQuery2 = ({ query = {} }) => {
  const keys = [];
  const serialized = {};
  for (const key of Object.keys(query).sort()) {
    if (key.toLowerCase() === SIGNATURE_HEADER2) {
      continue;
    }
    keys.push(key);
    const value = query[key];
    if (typeof value === "string") {
      serialized[key] = `${escapeUri(key)}=${escapeUri(value)}`;
    } else if (Array.isArray(value)) {
      serialized[key] = value.slice(0).sort().reduce((encoded, value2) => encoded.concat([`${escapeUri(key)}=${escapeUri(value2)}`]), []).join("&");
    }
  }
  return keys.map((key) => serialized[key]).filter((serialized2) => serialized2).join("&");
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/signature-v4/dist-es/getPayloadHash.js
var getPayloadHash2 = async ({ headers, body }, hashConstructor) => {
  for (const headerName of Object.keys(headers)) {
    if (headerName.toLowerCase() === SHA256_HEADER3) {
      return headers[headerName];
    }
  }
  if (body == void 0) {
    return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
  } else if (typeof body === "string" || ArrayBuffer.isView(body) || isArrayBuffer(body)) {
    const hashCtor = new hashConstructor();
    hashCtor.update(toUint8Array(body));
    return toHex(await hashCtor.digest());
  }
  return UNSIGNED_PAYLOAD3;
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/signature-v4/dist-es/headerUtil.js
var hasHeader3 = (soughtHeader, headers) => {
  soughtHeader = soughtHeader.toLowerCase();
  for (const headerName of Object.keys(headers)) {
    if (soughtHeader === headerName.toLowerCase()) {
      return true;
    }
  }
  return false;
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/signature-v4/dist-es/cloneRequest.js
var cloneRequest2 = ({ headers, query, ...rest }) => ({
  ...rest,
  headers: { ...headers },
  query: query ? cloneQuery4(query) : void 0
});
var cloneQuery4 = (query) => Object.keys(query).reduce((carry, paramName) => {
  const param = query[paramName];
  return {
    ...carry,
    [paramName]: Array.isArray(param) ? [...param] : param
  };
}, {});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/signature-v4/dist-es/moveHeadersToQuery.js
var moveHeadersToQuery2 = (request2, options = {}) => {
  const { headers, query = {} } = typeof request2.clone === "function" ? request2.clone() : cloneRequest2(request2);
  for (const name of Object.keys(headers)) {
    const lname = name.toLowerCase();
    if (lname.slice(0, 6) === "x-amz-" && !options.unhoistableHeaders?.has(lname)) {
      query[name] = headers[name];
      delete headers[name];
    }
  }
  return {
    ...request2,
    headers,
    query
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/signature-v4/dist-es/prepareRequest.js
var prepareRequest2 = (request2) => {
  request2 = typeof request2.clone === "function" ? request2.clone() : cloneRequest2(request2);
  for (const headerName of Object.keys(request2.headers)) {
    if (GENERATED_HEADERS2.indexOf(headerName.toLowerCase()) > -1) {
      delete request2.headers[headerName];
    }
  }
  return request2;
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/signature-v4/dist-es/utilDate.js
var iso86012 = (time) => toDate2(time).toISOString().replace(/\.\d{3}Z$/, "Z");
var toDate2 = (time) => {
  if (typeof time === "number") {
    return new Date(time * 1e3);
  }
  if (typeof time === "string") {
    if (Number(time)) {
      return new Date(Number(time) * 1e3);
    }
    return new Date(time);
  }
  return time;
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/signature-v4/dist-es/SignatureV4.js
var SignatureV42 = class {
  constructor({ applyChecksum, credentials: credentials2, region, service, sha256, uriEscapePath = true }) {
    this.service = service;
    this.sha256 = sha256;
    this.uriEscapePath = uriEscapePath;
    this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
    this.regionProvider = normalizeProvider(region);
    this.credentialProvider = normalizeProvider(credentials2);
  }
  async presign(originalRequest, options = {}) {
    const { signingDate = /* @__PURE__ */ new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService } = options;
    const credentials2 = await this.credentialProvider();
    this.validateResolvedCredentials(credentials2);
    const region = signingRegion ?? await this.regionProvider();
    const { longDate, shortDate } = formatDate2(signingDate);
    if (expiresIn > MAX_PRESIGNED_TTL2) {
      return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
    }
    const scope = createScope2(shortDate, region, signingService ?? this.service);
    const request2 = moveHeadersToQuery2(prepareRequest2(originalRequest), { unhoistableHeaders });
    if (credentials2.sessionToken) {
      request2.query[TOKEN_QUERY_PARAM2] = credentials2.sessionToken;
    }
    request2.query[ALGORITHM_QUERY_PARAM2] = ALGORITHM_IDENTIFIER2;
    request2.query[CREDENTIAL_QUERY_PARAM2] = `${credentials2.accessKeyId}/${scope}`;
    request2.query[AMZ_DATE_QUERY_PARAM2] = longDate;
    request2.query[EXPIRES_QUERY_PARAM2] = expiresIn.toString(10);
    const canonicalHeaders = getCanonicalHeaders2(request2, unsignableHeaders, signableHeaders);
    request2.query[SIGNED_HEADERS_QUERY_PARAM2] = getCanonicalHeaderList2(canonicalHeaders);
    request2.query[SIGNATURE_QUERY_PARAM2] = await this.getSignature(longDate, scope, this.getSigningKey(credentials2, region, shortDate, signingService), this.createCanonicalRequest(request2, canonicalHeaders, await getPayloadHash2(originalRequest, this.sha256)));
    return request2;
  }
  async sign(toSign, options) {
    if (typeof toSign === "string") {
      return this.signString(toSign, options);
    } else if (toSign.headers && toSign.payload) {
      return this.signEvent(toSign, options);
    } else {
      return this.signRequest(toSign, options);
    }
  }
  async signEvent({ headers, payload }, { signingDate = /* @__PURE__ */ new Date(), priorSignature, signingRegion, signingService }) {
    const region = signingRegion ?? await this.regionProvider();
    const { shortDate, longDate } = formatDate2(signingDate);
    const scope = createScope2(shortDate, region, signingService ?? this.service);
    const hashedPayload = await getPayloadHash2({ headers: {}, body: payload }, this.sha256);
    const hash2 = new this.sha256();
    hash2.update(headers);
    const hashedHeaders = toHex(await hash2.digest());
    const stringToSign = [
      EVENT_ALGORITHM_IDENTIFIER2,
      longDate,
      scope,
      priorSignature,
      hashedHeaders,
      hashedPayload
    ].join("\n");
    return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
  }
  async signString(stringToSign, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService } = {}) {
    const credentials2 = await this.credentialProvider();
    this.validateResolvedCredentials(credentials2);
    const region = signingRegion ?? await this.regionProvider();
    const { shortDate } = formatDate2(signingDate);
    const hash2 = new this.sha256(await this.getSigningKey(credentials2, region, shortDate, signingService));
    hash2.update(toUint8Array(stringToSign));
    return toHex(await hash2.digest());
  }
  async signRequest(requestToSign, { signingDate = /* @__PURE__ */ new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService } = {}) {
    const credentials2 = await this.credentialProvider();
    this.validateResolvedCredentials(credentials2);
    const region = signingRegion ?? await this.regionProvider();
    const request2 = prepareRequest2(requestToSign);
    const { longDate, shortDate } = formatDate2(signingDate);
    const scope = createScope2(shortDate, region, signingService ?? this.service);
    request2.headers[AMZ_DATE_HEADER2] = longDate;
    if (credentials2.sessionToken) {
      request2.headers[TOKEN_HEADER2] = credentials2.sessionToken;
    }
    const payloadHash = await getPayloadHash2(request2, this.sha256);
    if (!hasHeader3(SHA256_HEADER3, request2.headers) && this.applyChecksum) {
      request2.headers[SHA256_HEADER3] = payloadHash;
    }
    const canonicalHeaders = getCanonicalHeaders2(request2, unsignableHeaders, signableHeaders);
    const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials2, region, shortDate, signingService), this.createCanonicalRequest(request2, canonicalHeaders, payloadHash));
    request2.headers[AUTH_HEADER2] = `${ALGORITHM_IDENTIFIER2} Credential=${credentials2.accessKeyId}/${scope}, SignedHeaders=${getCanonicalHeaderList2(canonicalHeaders)}, Signature=${signature}`;
    return request2;
  }
  createCanonicalRequest(request2, canonicalHeaders, payloadHash) {
    const sortedHeaders = Object.keys(canonicalHeaders).sort();
    return `${request2.method}
${this.getCanonicalPath(request2)}
${getCanonicalQuery2(request2)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
  }
  async createStringToSign(longDate, credentialScope, canonicalRequest) {
    const hash2 = new this.sha256();
    hash2.update(toUint8Array(canonicalRequest));
    const hashedRequest = await hash2.digest();
    return `${ALGORITHM_IDENTIFIER2}
${longDate}
${credentialScope}
${toHex(hashedRequest)}`;
  }
  getCanonicalPath({ path }) {
    if (this.uriEscapePath) {
      const normalizedPathSegments = [];
      for (const pathSegment of path.split("/")) {
        if (pathSegment?.length === 0)
          continue;
        if (pathSegment === ".")
          continue;
        if (pathSegment === "..") {
          normalizedPathSegments.pop();
        } else {
          normalizedPathSegments.push(pathSegment);
        }
      }
      const normalizedPath = `${path?.startsWith("/") ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && path?.endsWith("/") ? "/" : ""}`;
      const doubleEncoded = encodeURIComponent(normalizedPath);
      return doubleEncoded.replace(/%2F/g, "/");
    }
    return path;
  }
  async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
    const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
    const hash2 = new this.sha256(await keyPromise);
    hash2.update(toUint8Array(stringToSign));
    return toHex(await hash2.digest());
  }
  getSigningKey(credentials2, region, shortDate, service) {
    return getSigningKey2(this.sha256, credentials2, shortDate, region, service || this.service);
  }
  validateResolvedCredentials(credentials2) {
    if (typeof credentials2 !== "object" || typeof credentials2.accessKeyId !== "string" || typeof credentials2.secretAccessKey !== "string") {
      throw new Error("Resolved credential object is not valid");
    }
  }
};
var formatDate2 = (now) => {
  const longDate = iso86012(now).replace(/[\-:]/g, "");
  return {
    longDate,
    shortDate: longDate.slice(0, 8)
  };
};
var getCanonicalHeaderList2 = (headers) => Object.keys(headers).sort().join(";");

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-signing/dist-es/configurations.js
var CREDENTIAL_EXPIRE_WINDOW2 = 3e5;
var resolveAwsAuthConfig2 = (input) => {
  const normalizedCreds = input.credentials ? normalizeCredentialProvider2(input.credentials) : input.credentialDefaultProvider(input);
  const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256 } = input;
  let signer;
  if (input.signer) {
    signer = normalizeProvider(input.signer);
  } else if (input.regionInfoProvider) {
    signer = () => normalizeProvider(input.region)().then(async (region) => [
      await input.regionInfoProvider(region, {
        useFipsEndpoint: await input.useFipsEndpoint(),
        useDualstackEndpoint: await input.useDualstackEndpoint()
      }) || {},
      region
    ]).then(([regionInfo, region]) => {
      const { signingRegion, signingService } = regionInfo;
      input.signingRegion = input.signingRegion || signingRegion || region;
      input.signingName = input.signingName || signingService || input.serviceId;
      const params2 = {
        ...input,
        credentials: normalizedCreds,
        region: input.signingRegion,
        service: input.signingName,
        sha256,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = input.signerConstructor || SignatureV42;
      return new SignerCtor(params2);
    });
  } else {
    signer = async (authScheme) => {
      authScheme = Object.assign({}, {
        name: "sigv4",
        signingName: input.signingName || input.defaultSigningName,
        signingRegion: await normalizeProvider(input.region)(),
        properties: {}
      }, authScheme);
      const signingRegion = authScheme.signingRegion;
      const signingService = authScheme.signingName;
      input.signingRegion = input.signingRegion || signingRegion;
      input.signingName = input.signingName || signingService || input.serviceId;
      const params2 = {
        ...input,
        credentials: normalizedCreds,
        region: input.signingRegion,
        service: input.signingName,
        sha256,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = input.signerConstructor || SignatureV42;
      return new SignerCtor(params2);
    };
  }
  return {
    ...input,
    systemClockOffset,
    signingEscapePath,
    credentials: normalizedCreds,
    signer
  };
};
var normalizeCredentialProvider2 = (credentials2) => {
  if (typeof credentials2 === "function") {
    return memoize(credentials2, (credentials3) => credentials3.expiration !== void 0 && credentials3.expiration.getTime() - Date.now() < CREDENTIAL_EXPIRE_WINDOW2, (credentials3) => credentials3.expiration !== void 0);
  }
  return normalizeProvider(credentials2);
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-signing/dist-es/utils/getSkewCorrectedDate.js
var getSkewCorrectedDate2 = (systemClockOffset) => new Date(Date.now() + systemClockOffset);

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-signing/dist-es/utils/isClockSkewed.js
var isClockSkewed2 = (clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate2(systemClockOffset).getTime() - clockTime) >= 3e5;

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-signing/dist-es/utils/getUpdatedSystemClockOffset.js
var getUpdatedSystemClockOffset2 = (clockTime, currentSystemClockOffset) => {
  const clockTimeInMs = Date.parse(clockTime);
  if (isClockSkewed2(clockTimeInMs, currentSystemClockOffset)) {
    return clockTimeInMs - Date.now();
  }
  return currentSystemClockOffset;
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-signing/dist-es/middleware.js
var awsAuthMiddleware2 = (options) => (next, context) => async function(args) {
  if (!HttpRequest2.isInstance(args.request))
    return next(args);
  const authScheme = context.endpointV2?.properties?.authSchemes?.[0];
  const multiRegionOverride = authScheme?.name === "sigv4a" ? authScheme?.signingRegionSet?.join(",") : void 0;
  const signer = await options.signer(authScheme);
  const output = await next({
    ...args,
    request: await signer.sign(args.request, {
      signingDate: getSkewCorrectedDate2(options.systemClockOffset),
      signingRegion: multiRegionOverride || context["signing_region"],
      signingService: context["signing_service"]
    })
  }).catch((error) => {
    const serverTime = error.ServerTime ?? getDateHeader2(error.$response);
    if (serverTime) {
      options.systemClockOffset = getUpdatedSystemClockOffset2(serverTime, options.systemClockOffset);
    }
    throw error;
  });
  const dateHeader = getDateHeader2(output.response);
  if (dateHeader) {
    options.systemClockOffset = getUpdatedSystemClockOffset2(dateHeader, options.systemClockOffset);
  }
  return output;
};
var getDateHeader2 = (response) => HttpResponse2.isInstance(response) ? response.headers?.date ?? response.headers?.Date : void 0;
var awsAuthMiddlewareOptions2 = {
  name: "awsAuthMiddleware",
  tags: ["SIGNATURE", "AWSAUTH"],
  relation: "after",
  toMiddleware: "retryMiddleware",
  override: true
};
var getAwsAuthPlugin2 = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(awsAuthMiddleware2(options), awsAuthMiddlewareOptions2);
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-user-agent/dist-es/configurations.js
function resolveUserAgentConfig2(input) {
  return {
    ...input,
    customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent
  };
}

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-user-agent/dist-es/constants.js
var USER_AGENT2 = "user-agent";
var X_AMZ_USER_AGENT2 = "x-amz-user-agent";
var SPACE2 = " ";
var UA_ESCAPE_REGEX2 = /[^\!\#\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-user-agent/dist-es/user-agent-middleware.js
var userAgentMiddleware2 = (options) => (next, context) => async (args) => {
  const { request: request2 } = args;
  if (!HttpRequest2.isInstance(request2))
    return next(args);
  const { headers } = request2;
  const userAgent = context?.userAgent?.map(escapeUserAgent2) || [];
  const defaultUserAgent3 = (await options.defaultUserAgentProvider()).map(escapeUserAgent2);
  const customUserAgent = options?.customUserAgent?.map(escapeUserAgent2) || [];
  const sdkUserAgentValue = [...defaultUserAgent3, ...userAgent, ...customUserAgent].join(SPACE2);
  const normalUAValue = [
    ...defaultUserAgent3.filter((section) => section.startsWith("aws-sdk-")),
    ...customUserAgent
  ].join(SPACE2);
  if (options.runtime !== "browser") {
    if (normalUAValue) {
      headers[X_AMZ_USER_AGENT2] = headers[X_AMZ_USER_AGENT2] ? `${headers[USER_AGENT2]} ${normalUAValue}` : normalUAValue;
    }
    headers[USER_AGENT2] = sdkUserAgentValue;
  } else {
    headers[X_AMZ_USER_AGENT2] = sdkUserAgentValue;
  }
  return next({
    ...args,
    request: request2
  });
};
var escapeUserAgent2 = ([name, version]) => {
  const prefixSeparatorIndex = name.indexOf("/");
  const prefix = name.substring(0, prefixSeparatorIndex);
  let uaName = name.substring(prefixSeparatorIndex + 1);
  if (prefix === "api") {
    uaName = uaName.toLowerCase();
  }
  return [prefix, uaName, version].filter((item) => item && item.length > 0).map((item) => item?.replace(UA_ESCAPE_REGEX2, "_")).join("/");
};
var getUserAgentMiddlewareOptions2 = {
  name: "getUserAgentMiddleware",
  step: "build",
  priority: "low",
  tags: ["SET_USER_AGENT", "USER_AGENT"],
  override: true
};
var getUserAgentPlugin2 = (config) => ({
  applyToStack: (clientStack) => {
    clientStack.add(userAgentMiddleware2(config), getUserAgentMiddlewareOptions2);
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters6 = (options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "dynamodb"
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/package.json
var package_default6 = {
  name: "@aws-sdk/client-dynamodb",
  description: "AWS SDK for JavaScript Dynamodb Client for Node.js, Browser and React Native",
  version: "3.284.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo dynamodb"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/client-sts": "3.282.0",
    "@aws-sdk/config-resolver": "3.282.0",
    "@aws-sdk/credential-provider-node": "3.282.0",
    "@aws-sdk/fetch-http-handler": "3.282.0",
    "@aws-sdk/hash-node": "3.272.0",
    "@aws-sdk/invalid-dependency": "3.272.0",
    "@aws-sdk/middleware-content-length": "3.282.0",
    "@aws-sdk/middleware-endpoint": "3.282.0",
    "@aws-sdk/middleware-endpoint-discovery": "3.282.0",
    "@aws-sdk/middleware-host-header": "3.282.0",
    "@aws-sdk/middleware-logger": "3.272.0",
    "@aws-sdk/middleware-recursion-detection": "3.282.0",
    "@aws-sdk/middleware-retry": "3.282.0",
    "@aws-sdk/middleware-serde": "3.272.0",
    "@aws-sdk/middleware-signing": "3.282.0",
    "@aws-sdk/middleware-stack": "3.272.0",
    "@aws-sdk/middleware-user-agent": "3.282.0",
    "@aws-sdk/node-config-provider": "3.272.0",
    "@aws-sdk/node-http-handler": "3.282.0",
    "@aws-sdk/protocol-http": "3.282.0",
    "@aws-sdk/smithy-client": "3.279.0",
    "@aws-sdk/types": "3.272.0",
    "@aws-sdk/url-parser": "3.272.0",
    "@aws-sdk/util-base64": "3.208.0",
    "@aws-sdk/util-body-length-browser": "3.188.0",
    "@aws-sdk/util-body-length-node": "3.208.0",
    "@aws-sdk/util-defaults-mode-browser": "3.279.0",
    "@aws-sdk/util-defaults-mode-node": "3.282.0",
    "@aws-sdk/util-endpoints": "3.272.0",
    "@aws-sdk/util-retry": "3.272.0",
    "@aws-sdk/util-user-agent-browser": "3.282.0",
    "@aws-sdk/util-user-agent-node": "3.282.0",
    "@aws-sdk/util-utf8": "3.254.0",
    "@aws-sdk/util-waiter": "3.272.0",
    tslib: "^2.3.1",
    uuid: "^8.3.2"
  },
  devDependencies: {
    "@aws-sdk/service-client-documentation-generator": "3.208.0",
    "@tsconfig/node14": "1.0.3",
    "@types/node": "^14.14.31",
    "@types/uuid": "^8.3.0",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.19.2",
    typescript: "~4.6.2"
  },
  overrides: {
    typedoc: {
      typescript: "~4.6.2"
    }
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-dynamodb",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-dynamodb"
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/models/STSServiceException.js
var STSServiceException2 = class extends ServiceException2 {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, STSServiceException2.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/models/models_0.js
var ExpiredTokenException3 = class extends STSServiceException2 {
  constructor(opts) {
    super({
      name: "ExpiredTokenException",
      $fault: "client",
      ...opts
    });
    this.name = "ExpiredTokenException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ExpiredTokenException3.prototype);
  }
};
var MalformedPolicyDocumentException2 = class extends STSServiceException2 {
  constructor(opts) {
    super({
      name: "MalformedPolicyDocumentException",
      $fault: "client",
      ...opts
    });
    this.name = "MalformedPolicyDocumentException";
    this.$fault = "client";
    Object.setPrototypeOf(this, MalformedPolicyDocumentException2.prototype);
  }
};
var PackedPolicyTooLargeException2 = class extends STSServiceException2 {
  constructor(opts) {
    super({
      name: "PackedPolicyTooLargeException",
      $fault: "client",
      ...opts
    });
    this.name = "PackedPolicyTooLargeException";
    this.$fault = "client";
    Object.setPrototypeOf(this, PackedPolicyTooLargeException2.prototype);
  }
};
var RegionDisabledException2 = class extends STSServiceException2 {
  constructor(opts) {
    super({
      name: "RegionDisabledException",
      $fault: "client",
      ...opts
    });
    this.name = "RegionDisabledException";
    this.$fault = "client";
    Object.setPrototypeOf(this, RegionDisabledException2.prototype);
  }
};
var IDPRejectedClaimException2 = class extends STSServiceException2 {
  constructor(opts) {
    super({
      name: "IDPRejectedClaimException",
      $fault: "client",
      ...opts
    });
    this.name = "IDPRejectedClaimException";
    this.$fault = "client";
    Object.setPrototypeOf(this, IDPRejectedClaimException2.prototype);
  }
};
var InvalidIdentityTokenException2 = class extends STSServiceException2 {
  constructor(opts) {
    super({
      name: "InvalidIdentityTokenException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidIdentityTokenException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidIdentityTokenException2.prototype);
  }
};
var IDPCommunicationErrorException2 = class extends STSServiceException2 {
  constructor(opts) {
    super({
      name: "IDPCommunicationErrorException",
      $fault: "client",
      ...opts
    });
    this.name = "IDPCommunicationErrorException";
    this.$fault = "client";
    Object.setPrototypeOf(this, IDPCommunicationErrorException2.prototype);
  }
};
var AssumeRoleRequestFilterSensitiveLog2 = (obj) => ({
  ...obj
});
var AssumeRoleResponseFilterSensitiveLog2 = (obj) => ({
  ...obj
});
var AssumeRoleWithWebIdentityRequestFilterSensitiveLog2 = (obj) => ({
  ...obj
});
var AssumeRoleWithWebIdentityResponseFilterSensitiveLog2 = (obj) => ({
  ...obj
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/protocols/Aws_query.js
var import_fast_xml_parser4 = __toESM(require_fxp2());
var serializeAws_queryAssumeRoleCommand2 = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString3({
    ...serializeAws_queryAssumeRoleRequest2(input, context),
    Action: "AssumeRole",
    Version: "2011-06-15"
  });
  return buildHttpRpcRequest4(context, headers, "/", void 0, body);
};
var serializeAws_queryAssumeRoleWithWebIdentityCommand2 = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString3({
    ...serializeAws_queryAssumeRoleWithWebIdentityRequest2(input, context),
    Action: "AssumeRoleWithWebIdentity",
    Version: "2011-06-15"
  });
  return buildHttpRpcRequest4(context, headers, "/", void 0, body);
};
var deserializeAws_queryAssumeRoleCommand2 = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_queryAssumeRoleCommandError2(output, context);
  }
  const data = await parseBody7(output.body, context);
  let contents = {};
  contents = deserializeAws_queryAssumeRoleResponse2(data.AssumeRoleResult, context);
  const response = {
    $metadata: deserializeMetadata9(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_queryAssumeRoleCommandError2 = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody7(output.body, context)
  };
  const errorCode = loadQueryErrorCode3(output, parsedOutput.body);
  switch (errorCode) {
    case "ExpiredTokenException":
    case "com.amazonaws.sts#ExpiredTokenException":
      throw await deserializeAws_queryExpiredTokenExceptionResponse2(parsedOutput, context);
    case "MalformedPolicyDocument":
    case "com.amazonaws.sts#MalformedPolicyDocumentException":
      throw await deserializeAws_queryMalformedPolicyDocumentExceptionResponse2(parsedOutput, context);
    case "PackedPolicyTooLarge":
    case "com.amazonaws.sts#PackedPolicyTooLargeException":
      throw await deserializeAws_queryPackedPolicyTooLargeExceptionResponse2(parsedOutput, context);
    case "RegionDisabledException":
    case "com.amazonaws.sts#RegionDisabledException":
      throw await deserializeAws_queryRegionDisabledExceptionResponse2(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError2({
        output,
        parsedBody: parsedBody.Error,
        exceptionCtor: STSServiceException2,
        errorCode
      });
  }
};
var deserializeAws_queryAssumeRoleWithWebIdentityCommand2 = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_queryAssumeRoleWithWebIdentityCommandError2(output, context);
  }
  const data = await parseBody7(output.body, context);
  let contents = {};
  contents = deserializeAws_queryAssumeRoleWithWebIdentityResponse2(data.AssumeRoleWithWebIdentityResult, context);
  const response = {
    $metadata: deserializeMetadata9(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_queryAssumeRoleWithWebIdentityCommandError2 = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody7(output.body, context)
  };
  const errorCode = loadQueryErrorCode3(output, parsedOutput.body);
  switch (errorCode) {
    case "ExpiredTokenException":
    case "com.amazonaws.sts#ExpiredTokenException":
      throw await deserializeAws_queryExpiredTokenExceptionResponse2(parsedOutput, context);
    case "IDPCommunicationError":
    case "com.amazonaws.sts#IDPCommunicationErrorException":
      throw await deserializeAws_queryIDPCommunicationErrorExceptionResponse2(parsedOutput, context);
    case "IDPRejectedClaim":
    case "com.amazonaws.sts#IDPRejectedClaimException":
      throw await deserializeAws_queryIDPRejectedClaimExceptionResponse2(parsedOutput, context);
    case "InvalidIdentityToken":
    case "com.amazonaws.sts#InvalidIdentityTokenException":
      throw await deserializeAws_queryInvalidIdentityTokenExceptionResponse2(parsedOutput, context);
    case "MalformedPolicyDocument":
    case "com.amazonaws.sts#MalformedPolicyDocumentException":
      throw await deserializeAws_queryMalformedPolicyDocumentExceptionResponse2(parsedOutput, context);
    case "PackedPolicyTooLarge":
    case "com.amazonaws.sts#PackedPolicyTooLargeException":
      throw await deserializeAws_queryPackedPolicyTooLargeExceptionResponse2(parsedOutput, context);
    case "RegionDisabledException":
    case "com.amazonaws.sts#RegionDisabledException":
      throw await deserializeAws_queryRegionDisabledExceptionResponse2(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError2({
        output,
        parsedBody: parsedBody.Error,
        exceptionCtor: STSServiceException2,
        errorCode
      });
  }
};
var deserializeAws_queryExpiredTokenExceptionResponse2 = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryExpiredTokenException2(body.Error, context);
  const exception = new ExpiredTokenException3({
    $metadata: deserializeMetadata9(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var deserializeAws_queryIDPCommunicationErrorExceptionResponse2 = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryIDPCommunicationErrorException2(body.Error, context);
  const exception = new IDPCommunicationErrorException2({
    $metadata: deserializeMetadata9(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var deserializeAws_queryIDPRejectedClaimExceptionResponse2 = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryIDPRejectedClaimException2(body.Error, context);
  const exception = new IDPRejectedClaimException2({
    $metadata: deserializeMetadata9(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var deserializeAws_queryInvalidIdentityTokenExceptionResponse2 = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryInvalidIdentityTokenException2(body.Error, context);
  const exception = new InvalidIdentityTokenException2({
    $metadata: deserializeMetadata9(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var deserializeAws_queryMalformedPolicyDocumentExceptionResponse2 = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryMalformedPolicyDocumentException2(body.Error, context);
  const exception = new MalformedPolicyDocumentException2({
    $metadata: deserializeMetadata9(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var deserializeAws_queryPackedPolicyTooLargeExceptionResponse2 = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryPackedPolicyTooLargeException2(body.Error, context);
  const exception = new PackedPolicyTooLargeException2({
    $metadata: deserializeMetadata9(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var deserializeAws_queryRegionDisabledExceptionResponse2 = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryRegionDisabledException2(body.Error, context);
  const exception = new RegionDisabledException2({
    $metadata: deserializeMetadata9(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var serializeAws_queryAssumeRoleRequest2 = (input, context) => {
  const entries = {};
  if (input.RoleArn != null) {
    entries["RoleArn"] = input.RoleArn;
  }
  if (input.RoleSessionName != null) {
    entries["RoleSessionName"] = input.RoleSessionName;
  }
  if (input.PolicyArns != null) {
    const memberEntries = serializeAws_querypolicyDescriptorListType2(input.PolicyArns, context);
    if (input.PolicyArns?.length === 0) {
      entries.PolicyArns = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PolicyArns.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Policy != null) {
    entries["Policy"] = input.Policy;
  }
  if (input.DurationSeconds != null) {
    entries["DurationSeconds"] = input.DurationSeconds;
  }
  if (input.Tags != null) {
    const memberEntries = serializeAws_querytagListType2(input.Tags, context);
    if (input.Tags?.length === 0) {
      entries.Tags = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Tags.${key}`;
      entries[loc] = value;
    });
  }
  if (input.TransitiveTagKeys != null) {
    const memberEntries = serializeAws_querytagKeyListType2(input.TransitiveTagKeys, context);
    if (input.TransitiveTagKeys?.length === 0) {
      entries.TransitiveTagKeys = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TransitiveTagKeys.${key}`;
      entries[loc] = value;
    });
  }
  if (input.ExternalId != null) {
    entries["ExternalId"] = input.ExternalId;
  }
  if (input.SerialNumber != null) {
    entries["SerialNumber"] = input.SerialNumber;
  }
  if (input.TokenCode != null) {
    entries["TokenCode"] = input.TokenCode;
  }
  if (input.SourceIdentity != null) {
    entries["SourceIdentity"] = input.SourceIdentity;
  }
  return entries;
};
var serializeAws_queryAssumeRoleWithWebIdentityRequest2 = (input, context) => {
  const entries = {};
  if (input.RoleArn != null) {
    entries["RoleArn"] = input.RoleArn;
  }
  if (input.RoleSessionName != null) {
    entries["RoleSessionName"] = input.RoleSessionName;
  }
  if (input.WebIdentityToken != null) {
    entries["WebIdentityToken"] = input.WebIdentityToken;
  }
  if (input.ProviderId != null) {
    entries["ProviderId"] = input.ProviderId;
  }
  if (input.PolicyArns != null) {
    const memberEntries = serializeAws_querypolicyDescriptorListType2(input.PolicyArns, context);
    if (input.PolicyArns?.length === 0) {
      entries.PolicyArns = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PolicyArns.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Policy != null) {
    entries["Policy"] = input.Policy;
  }
  if (input.DurationSeconds != null) {
    entries["DurationSeconds"] = input.DurationSeconds;
  }
  return entries;
};
var serializeAws_querypolicyDescriptorListType2 = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = serializeAws_queryPolicyDescriptorType2(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var serializeAws_queryPolicyDescriptorType2 = (input, context) => {
  const entries = {};
  if (input.arn != null) {
    entries["arn"] = input.arn;
  }
  return entries;
};
var serializeAws_queryTag2 = (input, context) => {
  const entries = {};
  if (input.Key != null) {
    entries["Key"] = input.Key;
  }
  if (input.Value != null) {
    entries["Value"] = input.Value;
  }
  return entries;
};
var serializeAws_querytagKeyListType2 = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var serializeAws_querytagListType2 = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = serializeAws_queryTag2(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var deserializeAws_queryAssumedRoleUser2 = (output, context) => {
  const contents = {
    AssumedRoleId: void 0,
    Arn: void 0
  };
  if (output["AssumedRoleId"] !== void 0) {
    contents.AssumedRoleId = expectString2(output["AssumedRoleId"]);
  }
  if (output["Arn"] !== void 0) {
    contents.Arn = expectString2(output["Arn"]);
  }
  return contents;
};
var deserializeAws_queryAssumeRoleResponse2 = (output, context) => {
  const contents = {
    Credentials: void 0,
    AssumedRoleUser: void 0,
    PackedPolicySize: void 0,
    SourceIdentity: void 0
  };
  if (output["Credentials"] !== void 0) {
    contents.Credentials = deserializeAws_queryCredentials2(output["Credentials"], context);
  }
  if (output["AssumedRoleUser"] !== void 0) {
    contents.AssumedRoleUser = deserializeAws_queryAssumedRoleUser2(output["AssumedRoleUser"], context);
  }
  if (output["PackedPolicySize"] !== void 0) {
    contents.PackedPolicySize = strictParseInt322(output["PackedPolicySize"]);
  }
  if (output["SourceIdentity"] !== void 0) {
    contents.SourceIdentity = expectString2(output["SourceIdentity"]);
  }
  return contents;
};
var deserializeAws_queryAssumeRoleWithWebIdentityResponse2 = (output, context) => {
  const contents = {
    Credentials: void 0,
    SubjectFromWebIdentityToken: void 0,
    AssumedRoleUser: void 0,
    PackedPolicySize: void 0,
    Provider: void 0,
    Audience: void 0,
    SourceIdentity: void 0
  };
  if (output["Credentials"] !== void 0) {
    contents.Credentials = deserializeAws_queryCredentials2(output["Credentials"], context);
  }
  if (output["SubjectFromWebIdentityToken"] !== void 0) {
    contents.SubjectFromWebIdentityToken = expectString2(output["SubjectFromWebIdentityToken"]);
  }
  if (output["AssumedRoleUser"] !== void 0) {
    contents.AssumedRoleUser = deserializeAws_queryAssumedRoleUser2(output["AssumedRoleUser"], context);
  }
  if (output["PackedPolicySize"] !== void 0) {
    contents.PackedPolicySize = strictParseInt322(output["PackedPolicySize"]);
  }
  if (output["Provider"] !== void 0) {
    contents.Provider = expectString2(output["Provider"]);
  }
  if (output["Audience"] !== void 0) {
    contents.Audience = expectString2(output["Audience"]);
  }
  if (output["SourceIdentity"] !== void 0) {
    contents.SourceIdentity = expectString2(output["SourceIdentity"]);
  }
  return contents;
};
var deserializeAws_queryCredentials2 = (output, context) => {
  const contents = {
    AccessKeyId: void 0,
    SecretAccessKey: void 0,
    SessionToken: void 0,
    Expiration: void 0
  };
  if (output["AccessKeyId"] !== void 0) {
    contents.AccessKeyId = expectString2(output["AccessKeyId"]);
  }
  if (output["SecretAccessKey"] !== void 0) {
    contents.SecretAccessKey = expectString2(output["SecretAccessKey"]);
  }
  if (output["SessionToken"] !== void 0) {
    contents.SessionToken = expectString2(output["SessionToken"]);
  }
  if (output["Expiration"] !== void 0) {
    contents.Expiration = expectNonNull2(parseRfc3339DateTimeWithOffset2(output["Expiration"]));
  }
  return contents;
};
var deserializeAws_queryExpiredTokenException2 = (output, context) => {
  const contents = {
    message: void 0
  };
  if (output["message"] !== void 0) {
    contents.message = expectString2(output["message"]);
  }
  return contents;
};
var deserializeAws_queryIDPCommunicationErrorException2 = (output, context) => {
  const contents = {
    message: void 0
  };
  if (output["message"] !== void 0) {
    contents.message = expectString2(output["message"]);
  }
  return contents;
};
var deserializeAws_queryIDPRejectedClaimException2 = (output, context) => {
  const contents = {
    message: void 0
  };
  if (output["message"] !== void 0) {
    contents.message = expectString2(output["message"]);
  }
  return contents;
};
var deserializeAws_queryInvalidIdentityTokenException2 = (output, context) => {
  const contents = {
    message: void 0
  };
  if (output["message"] !== void 0) {
    contents.message = expectString2(output["message"]);
  }
  return contents;
};
var deserializeAws_queryMalformedPolicyDocumentException2 = (output, context) => {
  const contents = {
    message: void 0
  };
  if (output["message"] !== void 0) {
    contents.message = expectString2(output["message"]);
  }
  return contents;
};
var deserializeAws_queryPackedPolicyTooLargeException2 = (output, context) => {
  const contents = {
    message: void 0
  };
  if (output["message"] !== void 0) {
    contents.message = expectString2(output["message"]);
  }
  return contents;
};
var deserializeAws_queryRegionDisabledException2 = (output, context) => {
  const contents = {
    message: void 0
  };
  if (output["message"] !== void 0) {
    contents.message = expectString2(output["message"]);
  }
  return contents;
};
var deserializeMetadata9 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
var collectBody8 = (streamBody = new Uint8Array(), context) => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
var collectBodyString8 = (streamBody, context) => collectBody8(streamBody, context).then((body) => context.utf8Encoder(body));
var buildHttpRpcRequest4 = async (context, headers, path, resolvedHostname, body) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const contents = {
    protocol,
    hostname,
    port,
    method: "POST",
    path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
    headers
  };
  if (resolvedHostname !== void 0) {
    contents.hostname = resolvedHostname;
  }
  if (body !== void 0) {
    contents.body = body;
  }
  return new HttpRequest2(contents);
};
var parseBody7 = (streamBody, context) => collectBodyString8(streamBody, context).then((encoded) => {
  if (encoded.length) {
    const parser = new import_fast_xml_parser4.XMLParser({
      attributeNamePrefix: "",
      htmlEntities: true,
      ignoreAttributes: false,
      ignoreDeclaration: true,
      parseTagValue: false,
      trimValues: false,
      tagValueProcessor: (_, val) => val.trim() === "" && val.includes("\n") ? "" : void 0
    });
    parser.addEntity("#xD", "\r");
    parser.addEntity("#10", "\n");
    const parsedObj = parser.parse(encoded);
    const textNodeName = "#text";
    const key = Object.keys(parsedObj)[0];
    const parsedObjToReturn = parsedObj[key];
    if (parsedObjToReturn[textNodeName]) {
      parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
      delete parsedObjToReturn[textNodeName];
    }
    return getValueFromTextNode2(parsedObjToReturn);
  }
  return {};
});
var parseErrorBody7 = async (errorBody, context) => {
  const value = await parseBody7(errorBody, context);
  if (value.Error) {
    value.Error.message = value.Error.message ?? value.Error.Message;
  }
  return value;
};
var buildFormUrlencodedString3 = (formEntries) => Object.entries(formEntries).map(([key, value]) => extendedEncodeURIComponent2(key) + "=" + extendedEncodeURIComponent2(value)).join("&");
var loadQueryErrorCode3 = (output, data) => {
  if (data.Error?.Code !== void 0) {
    return data.Error.Code;
  }
  if (output.statusCode == 404) {
    return "NotFound";
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/commands/AssumeRoleCommand.js
var AssumeRoleCommand2 = class extends Command2 {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin2(configuration, AssumeRoleCommand2.getEndpointParameterInstructions()));
    this.middlewareStack.use(getAwsAuthPlugin2(configuration));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "STSClient";
    const commandName = "AssumeRoleCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: AssumeRoleRequestFilterSensitiveLog2,
      outputFilterSensitiveLog: AssumeRoleResponseFilterSensitiveLog2
    };
    const { requestHandler } = configuration;
    return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_queryAssumeRoleCommand2(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_queryAssumeRoleCommand2(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/commands/AssumeRoleWithWebIdentityCommand.js
var AssumeRoleWithWebIdentityCommand2 = class extends Command2 {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin2(configuration, AssumeRoleWithWebIdentityCommand2.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "STSClient";
    const commandName = "AssumeRoleWithWebIdentityCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: AssumeRoleWithWebIdentityRequestFilterSensitiveLog2,
      outputFilterSensitiveLog: AssumeRoleWithWebIdentityResponseFilterSensitiveLog2
    };
    const { requestHandler } = configuration;
    return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_queryAssumeRoleWithWebIdentityCommand2(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_queryAssumeRoleWithWebIdentityCommand2(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-sdk-sts/dist-es/index.js
var resolveStsAuthConfig2 = (input, { stsClientCtor }) => resolveAwsAuthConfig2({
  ...input,
  stsClientCtor
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters7 = (options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    useGlobalEndpoint: options.useGlobalEndpoint ?? false,
    defaultSigningName: "sts"
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/package.json
var package_default7 = {
  name: "@aws-sdk/client-sts",
  description: "AWS SDK for JavaScript Sts Client for Node.js, Browser and React Native",
  version: "3.282.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo sts",
    test: "yarn test:unit",
    "test:unit": "jest"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/config-resolver": "3.282.0",
    "@aws-sdk/credential-provider-node": "3.282.0",
    "@aws-sdk/fetch-http-handler": "3.282.0",
    "@aws-sdk/hash-node": "3.272.0",
    "@aws-sdk/invalid-dependency": "3.272.0",
    "@aws-sdk/middleware-content-length": "3.282.0",
    "@aws-sdk/middleware-endpoint": "3.282.0",
    "@aws-sdk/middleware-host-header": "3.282.0",
    "@aws-sdk/middleware-logger": "3.272.0",
    "@aws-sdk/middleware-recursion-detection": "3.282.0",
    "@aws-sdk/middleware-retry": "3.282.0",
    "@aws-sdk/middleware-sdk-sts": "3.282.0",
    "@aws-sdk/middleware-serde": "3.272.0",
    "@aws-sdk/middleware-signing": "3.282.0",
    "@aws-sdk/middleware-stack": "3.272.0",
    "@aws-sdk/middleware-user-agent": "3.282.0",
    "@aws-sdk/node-config-provider": "3.272.0",
    "@aws-sdk/node-http-handler": "3.282.0",
    "@aws-sdk/protocol-http": "3.282.0",
    "@aws-sdk/smithy-client": "3.279.0",
    "@aws-sdk/types": "3.272.0",
    "@aws-sdk/url-parser": "3.272.0",
    "@aws-sdk/util-base64": "3.208.0",
    "@aws-sdk/util-body-length-browser": "3.188.0",
    "@aws-sdk/util-body-length-node": "3.208.0",
    "@aws-sdk/util-defaults-mode-browser": "3.279.0",
    "@aws-sdk/util-defaults-mode-node": "3.282.0",
    "@aws-sdk/util-endpoints": "3.272.0",
    "@aws-sdk/util-retry": "3.272.0",
    "@aws-sdk/util-user-agent-browser": "3.282.0",
    "@aws-sdk/util-user-agent-node": "3.282.0",
    "@aws-sdk/util-utf8": "3.254.0",
    "fast-xml-parser": "4.1.2",
    tslib: "^2.3.1"
  },
  devDependencies: {
    "@aws-sdk/service-client-documentation-generator": "3.208.0",
    "@tsconfig/node14": "1.0.3",
    "@types/node": "^14.14.31",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.19.2",
    typescript: "~4.6.2"
  },
  overrides: {
    typedoc: {
      typescript: "~4.6.2"
    }
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sts",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-sts"
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/defaultStsRoleAssumers.js
var ASSUME_ROLE_DEFAULT_REGION2 = "us-east-1";
var decorateDefaultRegion2 = (region) => {
  if (typeof region !== "function") {
    return region === void 0 ? ASSUME_ROLE_DEFAULT_REGION2 : region;
  }
  return async () => {
    try {
      return await region();
    } catch (e10) {
      return ASSUME_ROLE_DEFAULT_REGION2;
    }
  };
};
var getDefaultRoleAssumer3 = (stsOptions, stsClientCtor) => {
  let stsClient;
  let closureSourceCreds;
  return async (sourceCreds, params2) => {
    closureSourceCreds = sourceCreds;
    if (!stsClient) {
      const { logger: logger3, region, requestHandler } = stsOptions;
      stsClient = new stsClientCtor({
        logger: logger3,
        credentialDefaultProvider: () => async () => closureSourceCreds,
        region: decorateDefaultRegion2(region || stsOptions.region),
        ...requestHandler ? { requestHandler } : {}
      });
    }
    const { Credentials } = await stsClient.send(new AssumeRoleCommand2(params2));
    if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
      throw new Error(`Invalid response from STS.assumeRole call with role ${params2.RoleArn}`);
    }
    return {
      accessKeyId: Credentials.AccessKeyId,
      secretAccessKey: Credentials.SecretAccessKey,
      sessionToken: Credentials.SessionToken,
      expiration: Credentials.Expiration
    };
  };
};
var getDefaultRoleAssumerWithWebIdentity3 = (stsOptions, stsClientCtor) => {
  let stsClient;
  return async (params2) => {
    if (!stsClient) {
      const { logger: logger3, region, requestHandler } = stsOptions;
      stsClient = new stsClientCtor({
        logger: logger3,
        region: decorateDefaultRegion2(region || stsOptions.region),
        ...requestHandler ? { requestHandler } : {}
      });
    }
    const { Credentials } = await stsClient.send(new AssumeRoleWithWebIdentityCommand2(params2));
    if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
      throw new Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${params2.RoleArn}`);
    }
    return {
      accessKeyId: Credentials.AccessKeyId,
      secretAccessKey: Credentials.SecretAccessKey,
      sessionToken: Credentials.SessionToken,
      expiration: Credentials.Expiration
    };
  };
};
var decorateDefaultCredentialProvider3 = (provider) => (input) => provider({
  roleAssumer: getDefaultRoleAssumer3(input, input.stsClientCtor),
  roleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity3(input, input.stsClientCtor),
  ...input
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveCredentialSource.js
var resolveCredentialSource2 = (credentialSource, profileName) => {
  const sourceProvidersMap = {
    EcsContainer: fromContainerMetadata,
    Ec2InstanceMetadata: fromInstanceMetadata,
    Environment: fromEnv
  };
  if (credentialSource in sourceProvidersMap) {
    return sourceProvidersMap[credentialSource]();
  } else {
    throw new CredentialsProviderError(`Unsupported credential source in profile ${profileName}. Got ${credentialSource}, expected EcsContainer or Ec2InstanceMetadata or Environment.`);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveAssumeRoleCredentials.js
var isAssumeRoleProfile2 = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1 && ["undefined", "string"].indexOf(typeof arg.external_id) > -1 && ["undefined", "string"].indexOf(typeof arg.mfa_serial) > -1 && (isAssumeRoleWithSourceProfile2(arg) || isAssumeRoleWithProviderProfile2(arg));
var isAssumeRoleWithSourceProfile2 = (arg) => typeof arg.source_profile === "string" && typeof arg.credential_source === "undefined";
var isAssumeRoleWithProviderProfile2 = (arg) => typeof arg.credential_source === "string" && typeof arg.source_profile === "undefined";
var resolveAssumeRoleCredentials2 = async (profileName, profiles, options, visitedProfiles = {}) => {
  const data = profiles[profileName];
  if (!options.roleAssumer) {
    throw new CredentialsProviderError(`Profile ${profileName} requires a role to be assumed, but no role assumption callback was provided.`, false);
  }
  const { source_profile } = data;
  if (source_profile && source_profile in visitedProfiles) {
    throw new CredentialsProviderError(`Detected a cycle attempting to resolve credentials for profile ${getProfileName(options)}. Profiles visited: ` + Object.keys(visitedProfiles).join(", "), false);
  }
  const sourceCredsProvider = source_profile ? resolveProfileData2(source_profile, profiles, options, {
    ...visitedProfiles,
    [source_profile]: true
  }) : resolveCredentialSource2(data.credential_source, profileName)();
  const params2 = {
    RoleArn: data.role_arn,
    RoleSessionName: data.role_session_name || `aws-sdk-js-${Date.now()}`,
    ExternalId: data.external_id
  };
  const { mfa_serial } = data;
  if (mfa_serial) {
    if (!options.mfaCodeProvider) {
      throw new CredentialsProviderError(`Profile ${profileName} requires multi-factor authentication, but no MFA code callback was provided.`, false);
    }
    params2.SerialNumber = mfa_serial;
    params2.TokenCode = await options.mfaCodeProvider(mfa_serial);
  }
  const sourceCreds = await sourceCredsProvider;
  return options.roleAssumer(sourceCreds, params2);
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveProcessCredentials.js
var isProcessProfile2 = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.credential_process === "string";
var resolveProcessCredentials3 = async (options, profile) => fromProcess({
  ...options,
  profile
})();

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-sso/dist-es/isSsoProfile.js
var isSsoProfile2 = (arg) => arg && (typeof arg.sso_start_url === "string" || typeof arg.sso_account_id === "string" || typeof arg.sso_session === "string" || typeof arg.sso_region === "string" || typeof arg.sso_role_name === "string");

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso/dist-es/models/SSOServiceException.js
var SSOServiceException2 = class extends ServiceException2 {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, SSOServiceException2.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso/dist-es/models/models_0.js
var InvalidRequestException3 = class extends SSOServiceException2 {
  constructor(opts) {
    super({
      name: "InvalidRequestException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidRequestException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidRequestException3.prototype);
  }
};
var ResourceNotFoundException3 = class extends SSOServiceException2 {
  constructor(opts) {
    super({
      name: "ResourceNotFoundException",
      $fault: "client",
      ...opts
    });
    this.name = "ResourceNotFoundException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ResourceNotFoundException3.prototype);
  }
};
var TooManyRequestsException2 = class extends SSOServiceException2 {
  constructor(opts) {
    super({
      name: "TooManyRequestsException",
      $fault: "client",
      ...opts
    });
    this.name = "TooManyRequestsException";
    this.$fault = "client";
    Object.setPrototypeOf(this, TooManyRequestsException2.prototype);
  }
};
var UnauthorizedException2 = class extends SSOServiceException2 {
  constructor(opts) {
    super({
      name: "UnauthorizedException",
      $fault: "client",
      ...opts
    });
    this.name = "UnauthorizedException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UnauthorizedException2.prototype);
  }
};
var GetRoleCredentialsRequestFilterSensitiveLog2 = (obj) => ({
  ...obj,
  ...obj.accessToken && { accessToken: SENSITIVE_STRING2 }
});
var RoleCredentialsFilterSensitiveLog2 = (obj) => ({
  ...obj,
  ...obj.secretAccessKey && { secretAccessKey: SENSITIVE_STRING2 },
  ...obj.sessionToken && { sessionToken: SENSITIVE_STRING2 }
});
var GetRoleCredentialsResponseFilterSensitiveLog2 = (obj) => ({
  ...obj,
  ...obj.roleCredentials && { roleCredentials: RoleCredentialsFilterSensitiveLog2(obj.roleCredentials) }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso/dist-es/protocols/Aws_restJson1.js
var serializeAws_restJson1GetRoleCredentialsCommand2 = async (input, context) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers = map7({}, isSerializableHeaderValue3, {
    "x-amz-sso_bearer_token": input.accessToken
  });
  const resolvedPath2 = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}/federation/credentials`;
  const query = map7({
    role_name: [, expectNonNull2(input.roleName, `roleName`)],
    account_id: [, expectNonNull2(input.accountId, `accountId`)]
  });
  let body;
  return new HttpRequest2({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath2,
    query,
    body
  });
};
var deserializeAws_restJson1GetRoleCredentialsCommand2 = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetRoleCredentialsCommandError2(output, context);
  }
  const contents = map7({
    $metadata: deserializeMetadata10(output)
  });
  const data = expectNonNull2(expectObject2(await parseBody8(output.body, context)), "body");
  if (data.roleCredentials != null) {
    contents.roleCredentials = deserializeAws_restJson1RoleCredentials2(data.roleCredentials, context);
  }
  return contents;
};
var deserializeAws_restJson1GetRoleCredentialsCommandError2 = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody8(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode4(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.sso#InvalidRequestException":
      throw await deserializeAws_restJson1InvalidRequestExceptionResponse3(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.sso#ResourceNotFoundException":
      throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse2(parsedOutput, context);
    case "TooManyRequestsException":
    case "com.amazonaws.sso#TooManyRequestsException":
      throw await deserializeAws_restJson1TooManyRequestsExceptionResponse2(parsedOutput, context);
    case "UnauthorizedException":
    case "com.amazonaws.sso#UnauthorizedException":
      throw await deserializeAws_restJson1UnauthorizedExceptionResponse2(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError2({
        output,
        parsedBody,
        exceptionCtor: SSOServiceException2,
        errorCode
      });
  }
};
var map7 = map6;
var deserializeAws_restJson1InvalidRequestExceptionResponse3 = async (parsedOutput, context) => {
  const contents = map7({});
  const data = parsedOutput.body;
  if (data.message != null) {
    contents.message = expectString2(data.message);
  }
  const exception = new InvalidRequestException3({
    $metadata: deserializeMetadata10(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var deserializeAws_restJson1ResourceNotFoundExceptionResponse2 = async (parsedOutput, context) => {
  const contents = map7({});
  const data = parsedOutput.body;
  if (data.message != null) {
    contents.message = expectString2(data.message);
  }
  const exception = new ResourceNotFoundException3({
    $metadata: deserializeMetadata10(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var deserializeAws_restJson1TooManyRequestsExceptionResponse2 = async (parsedOutput, context) => {
  const contents = map7({});
  const data = parsedOutput.body;
  if (data.message != null) {
    contents.message = expectString2(data.message);
  }
  const exception = new TooManyRequestsException2({
    $metadata: deserializeMetadata10(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var deserializeAws_restJson1UnauthorizedExceptionResponse2 = async (parsedOutput, context) => {
  const contents = map7({});
  const data = parsedOutput.body;
  if (data.message != null) {
    contents.message = expectString2(data.message);
  }
  const exception = new UnauthorizedException2({
    $metadata: deserializeMetadata10(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var deserializeAws_restJson1RoleCredentials2 = (output, context) => {
  return {
    accessKeyId: expectString2(output.accessKeyId),
    expiration: expectLong2(output.expiration),
    secretAccessKey: expectString2(output.secretAccessKey),
    sessionToken: expectString2(output.sessionToken)
  };
};
var deserializeMetadata10 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
var collectBody9 = (streamBody = new Uint8Array(), context) => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
var collectBodyString9 = (streamBody, context) => collectBody9(streamBody, context).then((body) => context.utf8Encoder(body));
var isSerializableHeaderValue3 = (value) => value !== void 0 && value !== null && value !== "" && (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) && (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
var parseBody8 = (streamBody, context) => collectBodyString9(streamBody, context).then((encoded) => {
  if (encoded.length) {
    return JSON.parse(encoded);
  }
  return {};
});
var parseErrorBody8 = async (errorBody, context) => {
  const value = await parseBody8(errorBody, context);
  value.message = value.message ?? value.Message;
  return value;
};
var loadRestJsonErrorCode4 = (output, data) => {
  const findKey = (object2, key) => Object.keys(object2).find((k10) => k10.toLowerCase() === key.toLowerCase());
  const sanitizeErrorCode = (rawValue) => {
    let cleanValue = rawValue;
    if (typeof cleanValue === "number") {
      cleanValue = cleanValue.toString();
    }
    if (cleanValue.indexOf(",") >= 0) {
      cleanValue = cleanValue.split(",")[0];
    }
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  };
  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== void 0) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }
  if (data.code !== void 0) {
    return sanitizeErrorCode(data.code);
  }
  if (data["__type"] !== void 0) {
    return sanitizeErrorCode(data["__type"]);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso/dist-es/commands/GetRoleCredentialsCommand.js
var GetRoleCredentialsCommand2 = class extends Command2 {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin2(configuration, GetRoleCredentialsCommand2.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SSOClient";
    const commandName = "GetRoleCredentialsCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: GetRoleCredentialsRequestFilterSensitiveLog2,
      outputFilterSensitiveLog: GetRoleCredentialsResponseFilterSensitiveLog2
    };
    const { requestHandler } = configuration;
    return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_restJson1GetRoleCredentialsCommand2(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_restJson1GetRoleCredentialsCommand2(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters8 = (options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "awsssoportal"
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso/package.json
var package_default8 = {
  name: "@aws-sdk/client-sso",
  description: "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
  version: "3.282.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo sso"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/config-resolver": "3.282.0",
    "@aws-sdk/fetch-http-handler": "3.282.0",
    "@aws-sdk/hash-node": "3.272.0",
    "@aws-sdk/invalid-dependency": "3.272.0",
    "@aws-sdk/middleware-content-length": "3.282.0",
    "@aws-sdk/middleware-endpoint": "3.282.0",
    "@aws-sdk/middleware-host-header": "3.282.0",
    "@aws-sdk/middleware-logger": "3.272.0",
    "@aws-sdk/middleware-recursion-detection": "3.282.0",
    "@aws-sdk/middleware-retry": "3.282.0",
    "@aws-sdk/middleware-serde": "3.272.0",
    "@aws-sdk/middleware-stack": "3.272.0",
    "@aws-sdk/middleware-user-agent": "3.282.0",
    "@aws-sdk/node-config-provider": "3.272.0",
    "@aws-sdk/node-http-handler": "3.282.0",
    "@aws-sdk/protocol-http": "3.282.0",
    "@aws-sdk/smithy-client": "3.279.0",
    "@aws-sdk/types": "3.272.0",
    "@aws-sdk/url-parser": "3.272.0",
    "@aws-sdk/util-base64": "3.208.0",
    "@aws-sdk/util-body-length-browser": "3.188.0",
    "@aws-sdk/util-body-length-node": "3.208.0",
    "@aws-sdk/util-defaults-mode-browser": "3.279.0",
    "@aws-sdk/util-defaults-mode-node": "3.282.0",
    "@aws-sdk/util-endpoints": "3.272.0",
    "@aws-sdk/util-retry": "3.272.0",
    "@aws-sdk/util-user-agent-browser": "3.282.0",
    "@aws-sdk/util-user-agent-node": "3.282.0",
    "@aws-sdk/util-utf8": "3.254.0",
    tslib: "^2.3.1"
  },
  devDependencies: {
    "@aws-sdk/service-client-documentation-generator": "3.208.0",
    "@tsconfig/node14": "1.0.3",
    "@types/node": "^14.14.31",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.19.2",
    typescript: "~4.6.2"
  },
  overrides: {
    typedoc: {
      typescript: "~4.6.2"
    }
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-sso"
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/node-http-handler/dist-es/node-http-handler.js
var import_http3 = require("http");
var import_https3 = require("https");

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/node-http-handler/dist-es/constants.js
var NODEJS_TIMEOUT_ERROR_CODES3 = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/node-http-handler/dist-es/get-transformed-headers.js
var getTransformedHeaders2 = (headers) => {
  const transformedHeaders = {};
  for (const name of Object.keys(headers)) {
    const headerValues = headers[name];
    transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
  }
  return transformedHeaders;
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/node-http-handler/dist-es/set-connection-timeout.js
var setConnectionTimeout2 = (request2, reject, timeoutInMs = 0) => {
  if (!timeoutInMs) {
    return;
  }
  request2.on("socket", (socket) => {
    if (socket.connecting) {
      const timeoutId = setTimeout(() => {
        request2.destroy();
        reject(Object.assign(new Error(`Socket timed out without establishing a connection within ${timeoutInMs} ms`), {
          name: "TimeoutError"
        }));
      }, timeoutInMs);
      socket.on("connect", () => {
        clearTimeout(timeoutId);
      });
    }
  });
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/node-http-handler/dist-es/set-socket-timeout.js
var setSocketTimeout2 = (request2, reject, timeoutInMs = 0) => {
  request2.setTimeout(timeoutInMs, () => {
    request2.destroy();
    reject(Object.assign(new Error(`Connection timed out after ${timeoutInMs} ms`), { name: "TimeoutError" }));
  });
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/node-http-handler/dist-es/write-request-body.js
var import_stream7 = require("stream");
function writeRequestBody2(httpRequest2, request2) {
  const expect = request2.headers["Expect"] || request2.headers["expect"];
  if (expect === "100-continue") {
    httpRequest2.on("continue", () => {
      writeBody2(httpRequest2, request2.body);
    });
  } else {
    writeBody2(httpRequest2, request2.body);
  }
}
function writeBody2(httpRequest2, body) {
  if (body instanceof import_stream7.Readable) {
    body.pipe(httpRequest2);
  } else if (body) {
    httpRequest2.end(Buffer.from(body));
  } else {
    httpRequest2.end();
  }
}

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/node-http-handler/dist-es/node-http-handler.js
var NodeHttpHandler2 = class {
  constructor(options) {
    this.metadata = { handlerProtocol: "http/1.1" };
    this.configProvider = new Promise((resolve, reject) => {
      if (typeof options === "function") {
        options().then((_options) => {
          resolve(this.resolveDefaultConfig(_options));
        }).catch(reject);
      } else {
        resolve(this.resolveDefaultConfig(options));
      }
    });
  }
  resolveDefaultConfig(options) {
    const { connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
    const keepAlive = true;
    const maxSockets = 50;
    return {
      connectionTimeout,
      socketTimeout,
      httpAgent: httpAgent || new import_http3.Agent({ keepAlive, maxSockets }),
      httpsAgent: httpsAgent || new import_https3.Agent({ keepAlive, maxSockets })
    };
  }
  destroy() {
    this.config?.httpAgent?.destroy();
    this.config?.httpsAgent?.destroy();
  }
  async handle(request2, { abortSignal } = {}) {
    if (!this.config) {
      this.config = await this.configProvider;
    }
    return new Promise((resolve, reject) => {
      if (!this.config) {
        throw new Error("Node HTTP request handler config is not resolved");
      }
      if (abortSignal?.aborted) {
        const abortError = new Error("Request aborted");
        abortError.name = "AbortError";
        reject(abortError);
        return;
      }
      const isSSL = request2.protocol === "https:";
      const queryString = buildQueryString(request2.query || {});
      const nodeHttpsOptions = {
        headers: request2.headers,
        host: request2.hostname,
        method: request2.method,
        path: queryString ? `${request2.path}?${queryString}` : request2.path,
        port: request2.port,
        agent: isSSL ? this.config.httpsAgent : this.config.httpAgent
      };
      const requestFunc = isSSL ? import_https3.request : import_http3.request;
      const req = requestFunc(nodeHttpsOptions, (res) => {
        const httpResponse = new HttpResponse2({
          statusCode: res.statusCode || -1,
          headers: getTransformedHeaders2(res.headers),
          body: res
        });
        resolve({ response: httpResponse });
      });
      req.on("error", (err) => {
        if (NODEJS_TIMEOUT_ERROR_CODES3.includes(err.code)) {
          reject(Object.assign(err, { name: "TimeoutError" }));
        } else {
          reject(err);
        }
      });
      setConnectionTimeout2(req, reject, this.config.connectionTimeout);
      setSocketTimeout2(req, reject, this.config.socketTimeout);
      if (abortSignal) {
        abortSignal.onabort = () => {
          req.abort();
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          reject(abortError);
        };
      }
      writeRequestBody2(req, request2);
    });
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/node-http-handler/dist-es/stream-collector/collector.js
var import_stream8 = require("stream");
var Collector2 = class extends import_stream8.Writable {
  constructor() {
    super(...arguments);
    this.bufferedBytes = [];
  }
  _write(chunk2, encoding, callback) {
    this.bufferedBytes.push(chunk2);
    callback();
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/node-http-handler/dist-es/stream-collector/index.js
var streamCollector2 = (stream) => new Promise((resolve, reject) => {
  const collector = new Collector2();
  stream.pipe(collector);
  stream.on("error", (err) => {
    collector.end();
    reject(err);
  });
  collector.on("error", reject);
  collector.on("finish", function() {
    const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
    resolve(bytes);
  });
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js
var import_os3 = require("os");
var import_process2 = require("process");

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-user-agent-node/dist-es/is-crt-available.js
var isCrtAvailable2 = () => {
  try {
    if (typeof require === "function" && typeof module !== "undefined" && module.require && require("aws-crt")) {
      return ["md/crt-avail"];
    }
    return null;
  } catch (e10) {
    return null;
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js
var UA_APP_ID_ENV_NAME2 = "AWS_SDK_UA_APP_ID";
var UA_APP_ID_INI_NAME2 = "sdk-ua-app-id";
var defaultUserAgent2 = ({ serviceId, clientVersion }) => {
  const sections = [
    ["aws-sdk-js", clientVersion],
    [`os/${(0, import_os3.platform)()}`, (0, import_os3.release)()],
    ["lang/js"],
    ["md/nodejs", `${import_process2.versions.node}`]
  ];
  const crtAvailable = isCrtAvailable2();
  if (crtAvailable) {
    sections.push(crtAvailable);
  }
  if (serviceId) {
    sections.push([`api/${serviceId}`, clientVersion]);
  }
  if (import_process2.env.AWS_EXECUTION_ENV) {
    sections.push([`exec-env/${import_process2.env.AWS_EXECUTION_ENV}`]);
  }
  const appIdPromise = loadConfig({
    environmentVariableSelector: (env3) => env3[UA_APP_ID_ENV_NAME2],
    configFileSelector: (profile) => profile[UA_APP_ID_INI_NAME2],
    default: void 0
  })();
  let resolvedUserAgent = void 0;
  return async () => {
    if (!resolvedUserAgent) {
      const appId = await appIdPromise;
      resolvedUserAgent = appId ? [...sections, [`app/${appId}`]] : [...sections];
    }
    return resolvedUserAgent;
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso/dist-es/endpoint/ruleset.js
var p6 = "required";
var q6 = "fn";
var r6 = "argv";
var s6 = "ref";
var a6 = "PartitionResult";
var b6 = "tree";
var c6 = "error";
var d6 = "endpoint";
var e6 = { [p6]: false, "type": "String" };
var f6 = { [p6]: true, "default": false, "type": "Boolean" };
var g6 = { [s6]: "Endpoint" };
var h6 = { [q6]: "booleanEquals", [r6]: [{ [s6]: "UseFIPS" }, true] };
var i6 = { [q6]: "booleanEquals", [r6]: [{ [s6]: "UseDualStack" }, true] };
var j6 = {};
var k6 = { [q6]: "booleanEquals", [r6]: [true, { [q6]: "getAttr", [r6]: [{ [s6]: a6 }, "supportsFIPS"] }] };
var l6 = { [q6]: "booleanEquals", [r6]: [true, { [q6]: "getAttr", [r6]: [{ [s6]: a6 }, "supportsDualStack"] }] };
var m6 = [g6];
var n6 = [h6];
var o6 = [i6];
var _data6 = { version: "1.0", parameters: { Region: e6, UseDualStack: f6, UseFIPS: f6, Endpoint: e6 }, rules: [{ conditions: [{ [q6]: "aws.partition", [r6]: [{ [s6]: "Region" }], assign: a6 }], type: b6, rules: [{ conditions: [{ [q6]: "isSet", [r6]: m6 }, { [q6]: "parseURL", [r6]: m6, assign: "url" }], type: b6, rules: [{ conditions: n6, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c6 }, { type: b6, rules: [{ conditions: o6, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c6 }, { endpoint: { url: g6, properties: j6, headers: j6 }, type: d6 }] }] }, { conditions: [h6, i6], type: b6, rules: [{ conditions: [k6, l6], type: b6, rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j6, headers: j6 }, type: d6 }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c6 }] }, { conditions: n6, type: b6, rules: [{ conditions: [k6], type: b6, rules: [{ type: b6, rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}", properties: j6, headers: j6 }, type: d6 }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c6 }] }, { conditions: o6, type: b6, rules: [{ conditions: [l6], type: b6, rules: [{ endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j6, headers: j6 }, type: d6 }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c6 }] }, { endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}", properties: j6, headers: j6 }, type: d6 }] }] };
var ruleSet6 = _data6;

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver6 = (endpointParams, context = {}) => {
  return resolveEndpoint(ruleSet6, {
    endpointParams,
    logger: context.logger
  });
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.shared.js
var getRuntimeConfig11 = (config) => ({
  apiVersion: "2019-06-10",
  base64Decoder: config?.base64Decoder ?? fromBase64,
  base64Encoder: config?.base64Encoder ?? toBase64,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver6,
  logger: config?.logger ?? new NoOpLogger2(),
  serviceId: config?.serviceId ?? "SSO",
  urlParser: config?.urlParser ?? parseUrl,
  utf8Decoder: config?.utf8Decoder ?? fromUtf84,
  utf8Encoder: config?.utf8Encoder ?? toUtf84
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-defaults-mode-node/dist-es/constants.js
var AWS_EXECUTION_ENV2 = "AWS_EXECUTION_ENV";
var AWS_REGION_ENV2 = "AWS_REGION";
var AWS_DEFAULT_REGION_ENV2 = "AWS_DEFAULT_REGION";
var ENV_IMDS_DISABLED3 = "AWS_EC2_METADATA_DISABLED";
var DEFAULTS_MODE_OPTIONS2 = ["in-region", "cross-region", "mobile", "standard", "legacy"];
var IMDS_REGION_PATH2 = "/latest/meta-data/placement/region";

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-defaults-mode-node/dist-es/defaultsModeConfig.js
var AWS_DEFAULTS_MODE_ENV2 = "AWS_DEFAULTS_MODE";
var AWS_DEFAULTS_MODE_CONFIG2 = "defaults_mode";
var NODE_DEFAULTS_MODE_CONFIG_OPTIONS2 = {
  environmentVariableSelector: (env3) => {
    return env3[AWS_DEFAULTS_MODE_ENV2];
  },
  configFileSelector: (profile) => {
    return profile[AWS_DEFAULTS_MODE_CONFIG2];
  },
  default: "legacy"
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-defaults-mode-node/dist-es/resolveDefaultsModeConfig.js
var resolveDefaultsModeConfig2 = ({ region = loadConfig(NODE_REGION_CONFIG_OPTIONS2), defaultsMode = loadConfig(NODE_DEFAULTS_MODE_CONFIG_OPTIONS2) } = {}) => memoize(async () => {
  const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
  switch (mode?.toLowerCase()) {
    case "auto":
      return resolveNodeDefaultsModeAuto2(region);
    case "in-region":
    case "cross-region":
    case "mobile":
    case "standard":
    case "legacy":
      return Promise.resolve(mode?.toLocaleLowerCase());
    case void 0:
      return Promise.resolve("legacy");
    default:
      throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS2.join(", ")}, got ${mode}`);
  }
});
var resolveNodeDefaultsModeAuto2 = async (clientRegion) => {
  if (clientRegion) {
    const resolvedRegion = typeof clientRegion === "function" ? await clientRegion() : clientRegion;
    const inferredRegion = await inferPhysicalRegion2();
    if (!inferredRegion) {
      return "standard";
    }
    if (resolvedRegion === inferredRegion) {
      return "in-region";
    } else {
      return "cross-region";
    }
  }
  return "standard";
};
var inferPhysicalRegion2 = async () => {
  if (process.env[AWS_EXECUTION_ENV2] && (process.env[AWS_REGION_ENV2] || process.env[AWS_DEFAULT_REGION_ENV2])) {
    return process.env[AWS_REGION_ENV2] ?? process.env[AWS_DEFAULT_REGION_ENV2];
  }
  if (!process.env[ENV_IMDS_DISABLED3]) {
    try {
      const endpoint = await getInstanceMetadataEndpoint();
      return (await httpRequest({ ...endpoint, path: IMDS_REGION_PATH2 })).toString();
    } catch (e10) {
    }
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.js
var getRuntimeConfig12 = (config) => {
  emitWarningIfUnsupportedVersion2(process.version);
  const defaultsMode = resolveDefaultsModeConfig2(config);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode2);
  const clientSharedValues = getRuntimeConfig11(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent2({ serviceId: clientSharedValues.serviceId, clientVersion: package_default8.version }),
    maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS2),
    region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS2, NODE_REGION_CONFIG_FILE_OPTIONS2),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler2(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS2,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector2,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS2),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS2)
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso/dist-es/SSOClient.js
var SSOClient2 = class extends Client2 {
  constructor(configuration) {
    const _config_0 = getRuntimeConfig12(configuration);
    const _config_1 = resolveClientEndpointParameters8(_config_0);
    const _config_2 = resolveRegionConfig2(_config_1);
    const _config_3 = resolveEndpointConfig2(_config_2);
    const _config_4 = resolveRetryConfig2(_config_3);
    const _config_5 = resolveHostHeaderConfig2(_config_4);
    const _config_6 = resolveUserAgentConfig2(_config_5);
    super(_config_6);
    this.config = _config_6;
    this.middlewareStack.use(getRetryPlugin2(this.config));
    this.middlewareStack.use(getContentLengthPlugin2(this.config));
    this.middlewareStack.use(getHostHeaderPlugin2(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin2(this.config));
    this.middlewareStack.use(getUserAgentPlugin2(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/token-providers/dist-es/constants.js
var EXPIRE_WINDOW_MS3 = 5 * 60 * 1e3;
var REFRESH_MESSAGE2 = `To refresh this SSO session run 'aws sso login' with the corresponding profile.`;

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso-oidc/dist-es/models/SSOOIDCServiceException.js
var SSOOIDCServiceException2 = class extends ServiceException2 {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, SSOOIDCServiceException2.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso-oidc/dist-es/models/models_0.js
var AccessDeniedException2 = class extends SSOOIDCServiceException2 {
  constructor(opts) {
    super({
      name: "AccessDeniedException",
      $fault: "client",
      ...opts
    });
    this.name = "AccessDeniedException";
    this.$fault = "client";
    Object.setPrototypeOf(this, AccessDeniedException2.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var AuthorizationPendingException2 = class extends SSOOIDCServiceException2 {
  constructor(opts) {
    super({
      name: "AuthorizationPendingException",
      $fault: "client",
      ...opts
    });
    this.name = "AuthorizationPendingException";
    this.$fault = "client";
    Object.setPrototypeOf(this, AuthorizationPendingException2.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var ExpiredTokenException4 = class extends SSOOIDCServiceException2 {
  constructor(opts) {
    super({
      name: "ExpiredTokenException",
      $fault: "client",
      ...opts
    });
    this.name = "ExpiredTokenException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ExpiredTokenException4.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InternalServerException2 = class extends SSOOIDCServiceException2 {
  constructor(opts) {
    super({
      name: "InternalServerException",
      $fault: "server",
      ...opts
    });
    this.name = "InternalServerException";
    this.$fault = "server";
    Object.setPrototypeOf(this, InternalServerException2.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InvalidClientException2 = class extends SSOOIDCServiceException2 {
  constructor(opts) {
    super({
      name: "InvalidClientException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidClientException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidClientException2.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InvalidGrantException2 = class extends SSOOIDCServiceException2 {
  constructor(opts) {
    super({
      name: "InvalidGrantException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidGrantException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidGrantException2.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InvalidRequestException4 = class extends SSOOIDCServiceException2 {
  constructor(opts) {
    super({
      name: "InvalidRequestException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidRequestException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidRequestException4.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InvalidScopeException2 = class extends SSOOIDCServiceException2 {
  constructor(opts) {
    super({
      name: "InvalidScopeException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidScopeException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidScopeException2.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var SlowDownException2 = class extends SSOOIDCServiceException2 {
  constructor(opts) {
    super({
      name: "SlowDownException",
      $fault: "client",
      ...opts
    });
    this.name = "SlowDownException";
    this.$fault = "client";
    Object.setPrototypeOf(this, SlowDownException2.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var UnauthorizedClientException2 = class extends SSOOIDCServiceException2 {
  constructor(opts) {
    super({
      name: "UnauthorizedClientException",
      $fault: "client",
      ...opts
    });
    this.name = "UnauthorizedClientException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UnauthorizedClientException2.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var UnsupportedGrantTypeException2 = class extends SSOOIDCServiceException2 {
  constructor(opts) {
    super({
      name: "UnsupportedGrantTypeException",
      $fault: "client",
      ...opts
    });
    this.name = "UnsupportedGrantTypeException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UnsupportedGrantTypeException2.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var CreateTokenRequestFilterSensitiveLog2 = (obj) => ({
  ...obj
});
var CreateTokenResponseFilterSensitiveLog2 = (obj) => ({
  ...obj
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso-oidc/dist-es/protocols/Aws_restJson1.js
var serializeAws_restJson1CreateTokenCommand2 = async (input, context) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers = {
    "content-type": "application/json"
  };
  const resolvedPath2 = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}/token`;
  let body;
  body = JSON.stringify({
    ...input.clientId != null && { clientId: input.clientId },
    ...input.clientSecret != null && { clientSecret: input.clientSecret },
    ...input.code != null && { code: input.code },
    ...input.deviceCode != null && { deviceCode: input.deviceCode },
    ...input.grantType != null && { grantType: input.grantType },
    ...input.redirectUri != null && { redirectUri: input.redirectUri },
    ...input.refreshToken != null && { refreshToken: input.refreshToken },
    ...input.scope != null && { scope: serializeAws_restJson1Scopes2(input.scope, context) }
  });
  return new HttpRequest2({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath2,
    body
  });
};
var deserializeAws_restJson1CreateTokenCommand2 = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateTokenCommandError2(output, context);
  }
  const contents = map8({
    $metadata: deserializeMetadata11(output)
  });
  const data = expectNonNull2(expectObject2(await parseBody9(output.body, context)), "body");
  if (data.accessToken != null) {
    contents.accessToken = expectString2(data.accessToken);
  }
  if (data.expiresIn != null) {
    contents.expiresIn = expectInt322(data.expiresIn);
  }
  if (data.idToken != null) {
    contents.idToken = expectString2(data.idToken);
  }
  if (data.refreshToken != null) {
    contents.refreshToken = expectString2(data.refreshToken);
  }
  if (data.tokenType != null) {
    contents.tokenType = expectString2(data.tokenType);
  }
  return contents;
};
var deserializeAws_restJson1CreateTokenCommandError2 = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody9(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode5(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.ssooidc#AccessDeniedException":
      throw await deserializeAws_restJson1AccessDeniedExceptionResponse2(parsedOutput, context);
    case "AuthorizationPendingException":
    case "com.amazonaws.ssooidc#AuthorizationPendingException":
      throw await deserializeAws_restJson1AuthorizationPendingExceptionResponse2(parsedOutput, context);
    case "ExpiredTokenException":
    case "com.amazonaws.ssooidc#ExpiredTokenException":
      throw await deserializeAws_restJson1ExpiredTokenExceptionResponse2(parsedOutput, context);
    case "InternalServerException":
    case "com.amazonaws.ssooidc#InternalServerException":
      throw await deserializeAws_restJson1InternalServerExceptionResponse2(parsedOutput, context);
    case "InvalidClientException":
    case "com.amazonaws.ssooidc#InvalidClientException":
      throw await deserializeAws_restJson1InvalidClientExceptionResponse2(parsedOutput, context);
    case "InvalidGrantException":
    case "com.amazonaws.ssooidc#InvalidGrantException":
      throw await deserializeAws_restJson1InvalidGrantExceptionResponse2(parsedOutput, context);
    case "InvalidRequestException":
    case "com.amazonaws.ssooidc#InvalidRequestException":
      throw await deserializeAws_restJson1InvalidRequestExceptionResponse4(parsedOutput, context);
    case "InvalidScopeException":
    case "com.amazonaws.ssooidc#InvalidScopeException":
      throw await deserializeAws_restJson1InvalidScopeExceptionResponse2(parsedOutput, context);
    case "SlowDownException":
    case "com.amazonaws.ssooidc#SlowDownException":
      throw await deserializeAws_restJson1SlowDownExceptionResponse2(parsedOutput, context);
    case "UnauthorizedClientException":
    case "com.amazonaws.ssooidc#UnauthorizedClientException":
      throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse2(parsedOutput, context);
    case "UnsupportedGrantTypeException":
    case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
      throw await deserializeAws_restJson1UnsupportedGrantTypeExceptionResponse2(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError2({
        output,
        parsedBody,
        exceptionCtor: SSOOIDCServiceException2,
        errorCode
      });
  }
};
var map8 = map6;
var deserializeAws_restJson1AccessDeniedExceptionResponse2 = async (parsedOutput, context) => {
  const contents = map8({});
  const data = parsedOutput.body;
  if (data.error != null) {
    contents.error = expectString2(data.error);
  }
  if (data.error_description != null) {
    contents.error_description = expectString2(data.error_description);
  }
  const exception = new AccessDeniedException2({
    $metadata: deserializeMetadata11(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var deserializeAws_restJson1AuthorizationPendingExceptionResponse2 = async (parsedOutput, context) => {
  const contents = map8({});
  const data = parsedOutput.body;
  if (data.error != null) {
    contents.error = expectString2(data.error);
  }
  if (data.error_description != null) {
    contents.error_description = expectString2(data.error_description);
  }
  const exception = new AuthorizationPendingException2({
    $metadata: deserializeMetadata11(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var deserializeAws_restJson1ExpiredTokenExceptionResponse2 = async (parsedOutput, context) => {
  const contents = map8({});
  const data = parsedOutput.body;
  if (data.error != null) {
    contents.error = expectString2(data.error);
  }
  if (data.error_description != null) {
    contents.error_description = expectString2(data.error_description);
  }
  const exception = new ExpiredTokenException4({
    $metadata: deserializeMetadata11(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var deserializeAws_restJson1InternalServerExceptionResponse2 = async (parsedOutput, context) => {
  const contents = map8({});
  const data = parsedOutput.body;
  if (data.error != null) {
    contents.error = expectString2(data.error);
  }
  if (data.error_description != null) {
    contents.error_description = expectString2(data.error_description);
  }
  const exception = new InternalServerException2({
    $metadata: deserializeMetadata11(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var deserializeAws_restJson1InvalidClientExceptionResponse2 = async (parsedOutput, context) => {
  const contents = map8({});
  const data = parsedOutput.body;
  if (data.error != null) {
    contents.error = expectString2(data.error);
  }
  if (data.error_description != null) {
    contents.error_description = expectString2(data.error_description);
  }
  const exception = new InvalidClientException2({
    $metadata: deserializeMetadata11(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var deserializeAws_restJson1InvalidGrantExceptionResponse2 = async (parsedOutput, context) => {
  const contents = map8({});
  const data = parsedOutput.body;
  if (data.error != null) {
    contents.error = expectString2(data.error);
  }
  if (data.error_description != null) {
    contents.error_description = expectString2(data.error_description);
  }
  const exception = new InvalidGrantException2({
    $metadata: deserializeMetadata11(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var deserializeAws_restJson1InvalidRequestExceptionResponse4 = async (parsedOutput, context) => {
  const contents = map8({});
  const data = parsedOutput.body;
  if (data.error != null) {
    contents.error = expectString2(data.error);
  }
  if (data.error_description != null) {
    contents.error_description = expectString2(data.error_description);
  }
  const exception = new InvalidRequestException4({
    $metadata: deserializeMetadata11(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var deserializeAws_restJson1InvalidScopeExceptionResponse2 = async (parsedOutput, context) => {
  const contents = map8({});
  const data = parsedOutput.body;
  if (data.error != null) {
    contents.error = expectString2(data.error);
  }
  if (data.error_description != null) {
    contents.error_description = expectString2(data.error_description);
  }
  const exception = new InvalidScopeException2({
    $metadata: deserializeMetadata11(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var deserializeAws_restJson1SlowDownExceptionResponse2 = async (parsedOutput, context) => {
  const contents = map8({});
  const data = parsedOutput.body;
  if (data.error != null) {
    contents.error = expectString2(data.error);
  }
  if (data.error_description != null) {
    contents.error_description = expectString2(data.error_description);
  }
  const exception = new SlowDownException2({
    $metadata: deserializeMetadata11(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var deserializeAws_restJson1UnauthorizedClientExceptionResponse2 = async (parsedOutput, context) => {
  const contents = map8({});
  const data = parsedOutput.body;
  if (data.error != null) {
    contents.error = expectString2(data.error);
  }
  if (data.error_description != null) {
    contents.error_description = expectString2(data.error_description);
  }
  const exception = new UnauthorizedClientException2({
    $metadata: deserializeMetadata11(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var deserializeAws_restJson1UnsupportedGrantTypeExceptionResponse2 = async (parsedOutput, context) => {
  const contents = map8({});
  const data = parsedOutput.body;
  if (data.error != null) {
    contents.error = expectString2(data.error);
  }
  if (data.error_description != null) {
    contents.error_description = expectString2(data.error_description);
  }
  const exception = new UnsupportedGrantTypeException2({
    $metadata: deserializeMetadata11(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var serializeAws_restJson1Scopes2 = (input, context) => {
  return input.filter((e10) => e10 != null).map((entry) => {
    return entry;
  });
};
var deserializeMetadata11 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
var collectBody10 = (streamBody = new Uint8Array(), context) => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
var collectBodyString10 = (streamBody, context) => collectBody10(streamBody, context).then((body) => context.utf8Encoder(body));
var parseBody9 = (streamBody, context) => collectBodyString10(streamBody, context).then((encoded) => {
  if (encoded.length) {
    return JSON.parse(encoded);
  }
  return {};
});
var parseErrorBody9 = async (errorBody, context) => {
  const value = await parseBody9(errorBody, context);
  value.message = value.message ?? value.Message;
  return value;
};
var loadRestJsonErrorCode5 = (output, data) => {
  const findKey = (object2, key) => Object.keys(object2).find((k10) => k10.toLowerCase() === key.toLowerCase());
  const sanitizeErrorCode = (rawValue) => {
    let cleanValue = rawValue;
    if (typeof cleanValue === "number") {
      cleanValue = cleanValue.toString();
    }
    if (cleanValue.indexOf(",") >= 0) {
      cleanValue = cleanValue.split(",")[0];
    }
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  };
  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== void 0) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }
  if (data.code !== void 0) {
    return sanitizeErrorCode(data.code);
  }
  if (data["__type"] !== void 0) {
    return sanitizeErrorCode(data["__type"]);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso-oidc/dist-es/commands/CreateTokenCommand.js
var CreateTokenCommand2 = class extends Command2 {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin2(configuration, CreateTokenCommand2.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SSOOIDCClient";
    const commandName = "CreateTokenCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: CreateTokenRequestFilterSensitiveLog2,
      outputFilterSensitiveLog: CreateTokenResponseFilterSensitiveLog2
    };
    const { requestHandler } = configuration;
    return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_restJson1CreateTokenCommand2(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_restJson1CreateTokenCommand2(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters9 = (options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "awsssooidc"
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso-oidc/package.json
var package_default9 = {
  name: "@aws-sdk/client-sso-oidc",
  description: "AWS SDK for JavaScript Sso Oidc Client for Node.js, Browser and React Native",
  version: "3.282.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo sso-oidc"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/config-resolver": "3.282.0",
    "@aws-sdk/fetch-http-handler": "3.282.0",
    "@aws-sdk/hash-node": "3.272.0",
    "@aws-sdk/invalid-dependency": "3.272.0",
    "@aws-sdk/middleware-content-length": "3.282.0",
    "@aws-sdk/middleware-endpoint": "3.282.0",
    "@aws-sdk/middleware-host-header": "3.282.0",
    "@aws-sdk/middleware-logger": "3.272.0",
    "@aws-sdk/middleware-recursion-detection": "3.282.0",
    "@aws-sdk/middleware-retry": "3.282.0",
    "@aws-sdk/middleware-serde": "3.272.0",
    "@aws-sdk/middleware-stack": "3.272.0",
    "@aws-sdk/middleware-user-agent": "3.282.0",
    "@aws-sdk/node-config-provider": "3.272.0",
    "@aws-sdk/node-http-handler": "3.282.0",
    "@aws-sdk/protocol-http": "3.282.0",
    "@aws-sdk/smithy-client": "3.279.0",
    "@aws-sdk/types": "3.272.0",
    "@aws-sdk/url-parser": "3.272.0",
    "@aws-sdk/util-base64": "3.208.0",
    "@aws-sdk/util-body-length-browser": "3.188.0",
    "@aws-sdk/util-body-length-node": "3.208.0",
    "@aws-sdk/util-defaults-mode-browser": "3.279.0",
    "@aws-sdk/util-defaults-mode-node": "3.282.0",
    "@aws-sdk/util-endpoints": "3.272.0",
    "@aws-sdk/util-retry": "3.272.0",
    "@aws-sdk/util-user-agent-browser": "3.282.0",
    "@aws-sdk/util-user-agent-node": "3.282.0",
    "@aws-sdk/util-utf8": "3.254.0",
    tslib: "^2.3.1"
  },
  devDependencies: {
    "@aws-sdk/service-client-documentation-generator": "3.208.0",
    "@tsconfig/node14": "1.0.3",
    "@types/node": "^14.14.31",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.19.2",
    typescript: "~4.6.2"
  },
  overrides: {
    typedoc: {
      typescript: "~4.6.2"
    }
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso-oidc",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-sso-oidc"
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/ruleset.js
var p7 = "required";
var q7 = "fn";
var r7 = "argv";
var s7 = "ref";
var a7 = "PartitionResult";
var b7 = "tree";
var c7 = "error";
var d7 = "endpoint";
var e7 = { [p7]: false, "type": "String" };
var f7 = { [p7]: true, "default": false, "type": "Boolean" };
var g7 = { [s7]: "Endpoint" };
var h7 = { [q7]: "booleanEquals", [r7]: [{ [s7]: "UseFIPS" }, true] };
var i7 = { [q7]: "booleanEquals", [r7]: [{ [s7]: "UseDualStack" }, true] };
var j7 = {};
var k7 = { [q7]: "booleanEquals", [r7]: [true, { [q7]: "getAttr", [r7]: [{ [s7]: a7 }, "supportsFIPS"] }] };
var l7 = { [q7]: "booleanEquals", [r7]: [true, { [q7]: "getAttr", [r7]: [{ [s7]: a7 }, "supportsDualStack"] }] };
var m7 = [g7];
var n7 = [h7];
var o7 = [i7];
var _data7 = { version: "1.0", parameters: { Region: e7, UseDualStack: f7, UseFIPS: f7, Endpoint: e7 }, rules: [{ conditions: [{ [q7]: "aws.partition", [r7]: [{ [s7]: "Region" }], assign: a7 }], type: b7, rules: [{ conditions: [{ [q7]: "isSet", [r7]: m7 }, { [q7]: "parseURL", [r7]: m7, assign: "url" }], type: b7, rules: [{ conditions: n7, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c7 }, { type: b7, rules: [{ conditions: o7, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c7 }, { endpoint: { url: g7, properties: j7, headers: j7 }, type: d7 }] }] }, { conditions: [h7, i7], type: b7, rules: [{ conditions: [k7, l7], type: b7, rules: [{ endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j7, headers: j7 }, type: d7 }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c7 }] }, { conditions: n7, type: b7, rules: [{ conditions: [k7], type: b7, rules: [{ type: b7, rules: [{ endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}", properties: j7, headers: j7 }, type: d7 }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c7 }] }, { conditions: o7, type: b7, rules: [{ conditions: [l7], type: b7, rules: [{ endpoint: { url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j7, headers: j7 }, type: d7 }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c7 }] }, { endpoint: { url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}", properties: j7, headers: j7 }, type: d7 }] }] };
var ruleSet7 = _data7;

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver7 = (endpointParams, context = {}) => {
  return resolveEndpoint(ruleSet7, {
    endpointParams,
    logger: context.logger
  });
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso-oidc/dist-es/runtimeConfig.shared.js
var getRuntimeConfig13 = (config) => ({
  apiVersion: "2019-06-10",
  base64Decoder: config?.base64Decoder ?? fromBase64,
  base64Encoder: config?.base64Encoder ?? toBase64,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver7,
  logger: config?.logger ?? new NoOpLogger2(),
  serviceId: config?.serviceId ?? "SSO OIDC",
  urlParser: config?.urlParser ?? parseUrl,
  utf8Decoder: config?.utf8Decoder ?? fromUtf84,
  utf8Encoder: config?.utf8Encoder ?? toUtf84
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso-oidc/dist-es/runtimeConfig.js
var getRuntimeConfig14 = (config) => {
  emitWarningIfUnsupportedVersion2(process.version);
  const defaultsMode = resolveDefaultsModeConfig2(config);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode2);
  const clientSharedValues = getRuntimeConfig13(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent2({ serviceId: clientSharedValues.serviceId, clientVersion: package_default9.version }),
    maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS2),
    region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS2, NODE_REGION_CONFIG_FILE_OPTIONS2),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler2(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS2,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector2,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS2),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS2)
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso-oidc/dist-es/SSOOIDCClient.js
var SSOOIDCClient2 = class extends Client2 {
  constructor(configuration) {
    const _config_0 = getRuntimeConfig14(configuration);
    const _config_1 = resolveClientEndpointParameters9(_config_0);
    const _config_2 = resolveRegionConfig2(_config_1);
    const _config_3 = resolveEndpointConfig2(_config_2);
    const _config_4 = resolveRetryConfig2(_config_3);
    const _config_5 = resolveHostHeaderConfig2(_config_4);
    const _config_6 = resolveUserAgentConfig2(_config_5);
    super(_config_6);
    this.config = _config_6;
    this.middlewareStack.use(getRetryPlugin2(this.config));
    this.middlewareStack.use(getContentLengthPlugin2(this.config));
    this.middlewareStack.use(getHostHeaderPlugin2(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin2(this.config));
    this.middlewareStack.use(getUserAgentPlugin2(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/token-providers/dist-es/getSsoOidcClient.js
var ssoOidcClientsHash2 = {};
var getSsoOidcClient2 = (ssoRegion) => {
  if (ssoOidcClientsHash2[ssoRegion]) {
    return ssoOidcClientsHash2[ssoRegion];
  }
  const ssoOidcClient = new SSOOIDCClient2({ region: ssoRegion });
  ssoOidcClientsHash2[ssoRegion] = ssoOidcClient;
  return ssoOidcClient;
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/token-providers/dist-es/getNewSsoOidcToken.js
var getNewSsoOidcToken2 = (ssoToken, ssoRegion) => {
  const ssoOidcClient = getSsoOidcClient2(ssoRegion);
  return ssoOidcClient.send(new CreateTokenCommand2({
    clientId: ssoToken.clientId,
    clientSecret: ssoToken.clientSecret,
    refreshToken: ssoToken.refreshToken,
    grantType: "refresh_token"
  }));
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/token-providers/dist-es/validateTokenExpiry.js
var validateTokenExpiry2 = (token) => {
  if (token.expiration && token.expiration.getTime() < Date.now()) {
    throw new TokenProviderError(`Token is expired. ${REFRESH_MESSAGE2}`, false);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/token-providers/dist-es/validateTokenKey.js
var validateTokenKey2 = (key, value, forRefresh = false) => {
  if (typeof value === "undefined") {
    throw new TokenProviderError(`Value not present for '${key}' in SSO Token${forRefresh ? ". Cannot refresh" : ""}. ${REFRESH_MESSAGE2}`, false);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/token-providers/dist-es/writeSSOTokenToFile.js
var import_fs7 = require("fs");
var { writeFile: writeFile2 } = import_fs7.promises;
var writeSSOTokenToFile2 = (id, ssoToken) => {
  const tokenFilepath = getSSOTokenFilepath(id);
  const tokenString = JSON.stringify(ssoToken, null, 2);
  return writeFile2(tokenFilepath, tokenString);
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/token-providers/dist-es/fromSso.js
var lastRefreshAttemptTime2 = /* @__PURE__ */ new Date(0);
var fromSso2 = (init = {}) => async () => {
  const profiles = await parseKnownFiles(init);
  const profileName = getProfileName(init);
  const profile = profiles[profileName];
  if (!profile) {
    throw new TokenProviderError(`Profile '${profileName}' could not be found in shared credentials file.`, false);
  } else if (!profile["sso_session"]) {
    throw new TokenProviderError(`Profile '${profileName}' is missing required property 'sso_session'.`);
  }
  const ssoSessionName = profile["sso_session"];
  const ssoSessions = await loadSsoSessionData(init);
  const ssoSession = ssoSessions[ssoSessionName];
  if (!ssoSession) {
    throw new TokenProviderError(`Sso session '${ssoSessionName}' could not be found in shared credentials file.`, false);
  }
  for (const ssoSessionRequiredKey of ["sso_start_url", "sso_region"]) {
    if (!ssoSession[ssoSessionRequiredKey]) {
      throw new TokenProviderError(`Sso session '${ssoSessionName}' is missing required property '${ssoSessionRequiredKey}'.`, false);
    }
  }
  const ssoStartUrl = ssoSession["sso_start_url"];
  const ssoRegion = ssoSession["sso_region"];
  let ssoToken;
  try {
    ssoToken = await getSSOTokenFromFile(ssoSessionName);
  } catch (e10) {
    throw new TokenProviderError(`The SSO session token associated with profile=${profileName} was not found or is invalid. ${REFRESH_MESSAGE2}`, false);
  }
  validateTokenKey2("accessToken", ssoToken.accessToken);
  validateTokenKey2("expiresAt", ssoToken.expiresAt);
  const { accessToken, expiresAt } = ssoToken;
  const existingToken = { token: accessToken, expiration: new Date(expiresAt) };
  if (existingToken.expiration.getTime() - Date.now() > EXPIRE_WINDOW_MS3) {
    return existingToken;
  }
  if (Date.now() - lastRefreshAttemptTime2.getTime() < 30 * 1e3) {
    validateTokenExpiry2(existingToken);
    return existingToken;
  }
  validateTokenKey2("clientId", ssoToken.clientId, true);
  validateTokenKey2("clientSecret", ssoToken.clientSecret, true);
  validateTokenKey2("refreshToken", ssoToken.refreshToken, true);
  try {
    lastRefreshAttemptTime2.setTime(Date.now());
    const newSsoOidcToken = await getNewSsoOidcToken2(ssoToken, ssoRegion);
    validateTokenKey2("accessToken", newSsoOidcToken.accessToken);
    validateTokenKey2("expiresIn", newSsoOidcToken.expiresIn);
    const newTokenExpiration = new Date(Date.now() + newSsoOidcToken.expiresIn * 1e3);
    try {
      await writeSSOTokenToFile2(ssoSessionName, {
        ...ssoToken,
        accessToken: newSsoOidcToken.accessToken,
        expiresAt: newTokenExpiration.toISOString(),
        refreshToken: newSsoOidcToken.refreshToken
      });
    } catch (error) {
    }
    return {
      token: newSsoOidcToken.accessToken,
      expiration: newTokenExpiration
    };
  } catch (error) {
    validateTokenExpiry2(existingToken);
    return existingToken;
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-sso/dist-es/resolveSSOCredentials.js
var EXPIRE_WINDOW_MS4 = 15 * 60 * 1e3;
var SHOULD_FAIL_CREDENTIAL_CHAIN2 = false;
var resolveSSOCredentials2 = async ({ ssoStartUrl, ssoSession, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, profile }) => {
  let token;
  const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;
  if (ssoSession) {
    try {
      const _token = await fromSso2({ profile })();
      token = {
        accessToken: _token.token,
        expiresAt: new Date(_token.expiration).toISOString()
      };
    } catch (e10) {
      throw new CredentialsProviderError(e10.message, SHOULD_FAIL_CREDENTIAL_CHAIN2);
    }
  } else {
    try {
      token = await getSSOTokenFromFile(ssoStartUrl);
    } catch (e10) {
      throw new CredentialsProviderError(`The SSO session associated with this profile is invalid. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN2);
    }
  }
  if (new Date(token.expiresAt).getTime() - Date.now() <= EXPIRE_WINDOW_MS4) {
    throw new CredentialsProviderError(`The SSO session associated with this profile has expired. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN2);
  }
  const { accessToken } = token;
  const sso = ssoClient || new SSOClient2({ region: ssoRegion });
  let ssoResp;
  try {
    ssoResp = await sso.send(new GetRoleCredentialsCommand2({
      accountId: ssoAccountId,
      roleName: ssoRoleName,
      accessToken
    }));
  } catch (e10) {
    throw CredentialsProviderError.from(e10, SHOULD_FAIL_CREDENTIAL_CHAIN2);
  }
  const { roleCredentials: { accessKeyId, secretAccessKey, sessionToken, expiration } = {} } = ssoResp;
  if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {
    throw new CredentialsProviderError("SSO returns an invalid temporary credential.", SHOULD_FAIL_CREDENTIAL_CHAIN2);
  }
  return { accessKeyId, secretAccessKey, sessionToken, expiration: new Date(expiration) };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-sso/dist-es/validateSsoProfile.js
var validateSsoProfile2 = (profile) => {
  const { sso_start_url, sso_account_id, sso_region, sso_role_name } = profile;
  if (!sso_start_url || !sso_account_id || !sso_region || !sso_role_name) {
    throw new CredentialsProviderError(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(profile).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, false);
  }
  return profile;
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-sso/dist-es/fromSSO.js
var fromSSO2 = (init = {}) => async () => {
  const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, ssoSession } = init;
  const profileName = getProfileName(init);
  if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
    const profiles = await parseKnownFiles(init);
    const profile = profiles[profileName];
    if (!profile) {
      throw new CredentialsProviderError(`Profile ${profileName} was not found.`);
    }
    if (!isSsoProfile2(profile)) {
      throw new CredentialsProviderError(`Profile ${profileName} is not configured with SSO credentials.`);
    }
    if (profile?.sso_session) {
      const ssoSessions = await loadSsoSessionData(init);
      const session = ssoSessions[profile.sso_session];
      const conflictMsg = ` configurations in profile ${profileName} and sso-session ${profile.sso_session}`;
      if (ssoRegion && ssoRegion !== session.sso_region) {
        throw new CredentialsProviderError(`Conflicting SSO region` + conflictMsg, false);
      }
      if (ssoStartUrl && ssoStartUrl !== session.sso_start_url) {
        throw new CredentialsProviderError(`Conflicting SSO start_url` + conflictMsg, false);
      }
      profile.sso_region = session.sso_region;
      profile.sso_start_url = session.sso_start_url;
    }
    const { sso_start_url, sso_account_id, sso_region, sso_role_name, sso_session } = validateSsoProfile2(profile);
    return resolveSSOCredentials2({
      ssoStartUrl: sso_start_url,
      ssoSession: sso_session,
      ssoAccountId: sso_account_id,
      ssoRegion: sso_region,
      ssoRoleName: sso_role_name,
      ssoClient,
      profile: profileName
    });
  } else if (!ssoStartUrl || !ssoAccountId || !ssoRegion || !ssoRoleName) {
    throw new CredentialsProviderError('Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"');
  } else {
    return resolveSSOCredentials2({
      ssoStartUrl,
      ssoSession,
      ssoAccountId,
      ssoRegion,
      ssoRoleName,
      ssoClient,
      profile: profileName
    });
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveSsoCredentials.js
var resolveSsoCredentials2 = (data) => {
  const { sso_start_url, sso_account_id, sso_session, sso_region, sso_role_name } = validateSsoProfile2(data);
  return fromSSO2({
    ssoStartUrl: sso_start_url,
    ssoAccountId: sso_account_id,
    ssoSession: sso_session,
    ssoRegion: sso_region,
    ssoRoleName: sso_role_name
  })();
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveStaticCredentials.js
var isStaticCredsProfile2 = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.aws_access_key_id === "string" && typeof arg.aws_secret_access_key === "string" && ["undefined", "string"].indexOf(typeof arg.aws_session_token) > -1;
var resolveStaticCredentials2 = (profile) => Promise.resolve({
  accessKeyId: profile.aws_access_key_id,
  secretAccessKey: profile.aws_secret_access_key,
  sessionToken: profile.aws_session_token
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveWebIdentityCredentials.js
var isWebIdentityProfile2 = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.web_identity_token_file === "string" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1;
var resolveWebIdentityCredentials2 = async (profile, options) => fromTokenFile({
  webIdentityTokenFile: profile.web_identity_token_file,
  roleArn: profile.role_arn,
  roleSessionName: profile.role_session_name,
  roleAssumerWithWebIdentity: options.roleAssumerWithWebIdentity
})();

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveProfileData.js
var resolveProfileData2 = async (profileName, profiles, options, visitedProfiles = {}) => {
  const data = profiles[profileName];
  if (Object.keys(visitedProfiles).length > 0 && isStaticCredsProfile2(data)) {
    return resolveStaticCredentials2(data);
  }
  if (isAssumeRoleProfile2(data)) {
    return resolveAssumeRoleCredentials2(profileName, profiles, options, visitedProfiles);
  }
  if (isStaticCredsProfile2(data)) {
    return resolveStaticCredentials2(data);
  }
  if (isWebIdentityProfile2(data)) {
    return resolveWebIdentityCredentials2(data, options);
  }
  if (isProcessProfile2(data)) {
    return resolveProcessCredentials3(options, profileName);
  }
  if (isSsoProfile2(data)) {
    return resolveSsoCredentials2(data);
  }
  throw new CredentialsProviderError(`Profile ${profileName} could not be found or parsed in shared credentials file.`);
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-ini/dist-es/fromIni.js
var fromIni2 = (init = {}) => async () => {
  const profiles = await parseKnownFiles(init);
  return resolveProfileData2(getProfileName(init), profiles, init);
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-node/dist-es/remoteProvider.js
var ENV_IMDS_DISABLED4 = "AWS_EC2_METADATA_DISABLED";
var remoteProvider2 = (init) => {
  if (process.env[ENV_CMDS_RELATIVE_URI] || process.env[ENV_CMDS_FULL_URI]) {
    return fromContainerMetadata(init);
  }
  if (process.env[ENV_IMDS_DISABLED4]) {
    return async () => {
      throw new CredentialsProviderError("EC2 Instance Metadata Service access disabled");
    };
  }
  return fromInstanceMetadata(init);
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-node/dist-es/defaultProvider.js
var defaultProvider3 = (init = {}) => memoize(chain(...init.profile || process.env[ENV_PROFILE] ? [] : [fromEnv()], fromSSO2(init), fromIni2(init), fromProcess(init), fromTokenFile(init), remoteProvider2(init), async () => {
  throw new CredentialsProviderError("Could not load credentials from any providers", false);
}), (credentials2) => credentials2.expiration !== void 0 && credentials2.expiration.getTime() - Date.now() < 3e5, (credentials2) => credentials2.expiration !== void 0);

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/endpoint/ruleset.js
var G3 = "required";
var H3 = "type";
var I3 = "fn";
var J3 = "argv";
var K3 = "ref";
var L3 = "properties";
var M3 = "headers";
var a8 = false;
var b8 = true;
var c8 = "PartitionResult";
var d8 = "tree";
var e8 = "booleanEquals";
var f8 = "stringEquals";
var g8 = "sigv4";
var h8 = "us-east-1";
var i8 = "sts";
var j8 = "endpoint";
var k8 = "https://sts.{Region}.{PartitionResult#dnsSuffix}";
var l8 = "error";
var m8 = "getAttr";
var n8 = { [G3]: false, [H3]: "String" };
var o8 = { [G3]: true, "default": false, [H3]: "Boolean" };
var p8 = { [K3]: "Region" };
var q8 = { [K3]: "UseFIPS" };
var r8 = { [K3]: "UseDualStack" };
var s8 = { [I3]: "isSet", [J3]: [{ [K3]: "Endpoint" }] };
var t4 = { [K3]: "Endpoint" };
var u4 = { "url": "https://sts.amazonaws.com", [L3]: { "authSchemes": [{ "name": g8, "signingRegion": h8, "signingName": i8 }] }, [M3]: {} };
var v5 = {};
var w3 = { "conditions": [{ [I3]: f8, [J3]: [p8, "aws-global"] }], [j8]: u4, [H3]: j8 };
var x3 = { [I3]: e8, [J3]: [q8, true] };
var y3 = { [I3]: e8, [J3]: [r8, true] };
var z3 = { [I3]: e8, [J3]: [true, { [I3]: m8, [J3]: [{ [K3]: c8 }, "supportsFIPS"] }] };
var A3 = { [K3]: c8 };
var B3 = { [I3]: e8, [J3]: [true, { [I3]: m8, [J3]: [A3, "supportsDualStack"] }] };
var C3 = { "url": k8, [L3]: {}, [M3]: {} };
var D3 = [t4];
var E3 = [x3];
var F3 = [y3];
var _data8 = { version: "1.0", parameters: { Region: n8, UseDualStack: o8, UseFIPS: o8, Endpoint: n8, UseGlobalEndpoint: o8 }, rules: [{ conditions: [{ [I3]: "aws.partition", [J3]: [p8], assign: c8 }], [H3]: d8, rules: [{ conditions: [{ [I3]: e8, [J3]: [{ [K3]: "UseGlobalEndpoint" }, b8] }, { [I3]: e8, [J3]: [q8, a8] }, { [I3]: e8, [J3]: [r8, a8] }, { [I3]: "not", [J3]: [s8] }], [H3]: d8, rules: [{ conditions: [{ [I3]: f8, [J3]: [p8, "ap-northeast-1"] }], endpoint: u4, [H3]: j8 }, { conditions: [{ [I3]: f8, [J3]: [p8, "ap-south-1"] }], endpoint: u4, [H3]: j8 }, { conditions: [{ [I3]: f8, [J3]: [p8, "ap-southeast-1"] }], endpoint: u4, [H3]: j8 }, { conditions: [{ [I3]: f8, [J3]: [p8, "ap-southeast-2"] }], endpoint: u4, [H3]: j8 }, w3, { conditions: [{ [I3]: f8, [J3]: [p8, "ca-central-1"] }], endpoint: u4, [H3]: j8 }, { conditions: [{ [I3]: f8, [J3]: [p8, "eu-central-1"] }], endpoint: u4, [H3]: j8 }, { conditions: [{ [I3]: f8, [J3]: [p8, "eu-north-1"] }], endpoint: u4, [H3]: j8 }, { conditions: [{ [I3]: f8, [J3]: [p8, "eu-west-1"] }], endpoint: u4, [H3]: j8 }, { conditions: [{ [I3]: f8, [J3]: [p8, "eu-west-2"] }], endpoint: u4, [H3]: j8 }, { conditions: [{ [I3]: f8, [J3]: [p8, "eu-west-3"] }], endpoint: u4, [H3]: j8 }, { conditions: [{ [I3]: f8, [J3]: [p8, "sa-east-1"] }], endpoint: u4, [H3]: j8 }, { conditions: [{ [I3]: f8, [J3]: [p8, h8] }], endpoint: u4, [H3]: j8 }, { conditions: [{ [I3]: f8, [J3]: [p8, "us-east-2"] }], endpoint: u4, [H3]: j8 }, { conditions: [{ [I3]: f8, [J3]: [p8, "us-west-1"] }], endpoint: u4, [H3]: j8 }, { conditions: [{ [I3]: f8, [J3]: [p8, "us-west-2"] }], endpoint: u4, [H3]: j8 }, { endpoint: { url: k8, [L3]: { authSchemes: [{ name: g8, signingRegion: "{Region}", signingName: i8 }] }, [M3]: v5 }, [H3]: j8 }] }, { conditions: [s8, { [I3]: "parseURL", [J3]: D3, assign: "url" }], [H3]: d8, rules: [{ conditions: E3, error: "Invalid Configuration: FIPS and custom endpoint are not supported", [H3]: l8 }, { [H3]: d8, rules: [{ conditions: F3, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", [H3]: l8 }, { endpoint: { url: t4, [L3]: v5, [M3]: v5 }, [H3]: j8 }] }] }, { conditions: [x3, y3], [H3]: d8, rules: [{ conditions: [z3, B3], [H3]: d8, rules: [{ endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", [L3]: v5, [M3]: v5 }, [H3]: j8 }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", [H3]: l8 }] }, { conditions: E3, [H3]: d8, rules: [{ conditions: [z3], [H3]: d8, rules: [{ [H3]: d8, rules: [{ conditions: [{ [I3]: f8, [J3]: ["aws-us-gov", { [I3]: m8, [J3]: [A3, "name"] }] }], endpoint: C3, [H3]: j8 }, { endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}", [L3]: v5, [M3]: v5 }, [H3]: j8 }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", [H3]: l8 }] }, { conditions: F3, [H3]: d8, rules: [{ conditions: [B3], [H3]: d8, rules: [{ endpoint: { url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}", [L3]: v5, [M3]: v5 }, [H3]: j8 }] }, { error: "DualStack is enabled but this partition does not support DualStack", [H3]: l8 }] }, { [H3]: d8, rules: [w3, { endpoint: C3, [H3]: j8 }] }] }] };
var ruleSet8 = _data8;

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver8 = (endpointParams, context = {}) => {
  return resolveEndpoint(ruleSet8, {
    endpointParams,
    logger: context.logger
  });
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/runtimeConfig.shared.js
var getRuntimeConfig15 = (config) => ({
  apiVersion: "2011-06-15",
  base64Decoder: config?.base64Decoder ?? fromBase64,
  base64Encoder: config?.base64Encoder ?? toBase64,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver8,
  logger: config?.logger ?? new NoOpLogger2(),
  serviceId: config?.serviceId ?? "STS",
  urlParser: config?.urlParser ?? parseUrl,
  utf8Decoder: config?.utf8Decoder ?? fromUtf84,
  utf8Encoder: config?.utf8Encoder ?? toUtf84
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/runtimeConfig.js
var getRuntimeConfig16 = (config) => {
  emitWarningIfUnsupportedVersion2(process.version);
  const defaultsMode = resolveDefaultsModeConfig2(config);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode2);
  const clientSharedValues = getRuntimeConfig15(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
    credentialDefaultProvider: config?.credentialDefaultProvider ?? decorateDefaultCredentialProvider3(defaultProvider3),
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent2({ serviceId: clientSharedValues.serviceId, clientVersion: package_default7.version }),
    maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS2),
    region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS2, NODE_REGION_CONFIG_FILE_OPTIONS2),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler2(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS2,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector2,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS2),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS2)
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/STSClient.js
var STSClient2 = class extends Client2 {
  constructor(configuration) {
    const _config_0 = getRuntimeConfig16(configuration);
    const _config_1 = resolveClientEndpointParameters7(_config_0);
    const _config_2 = resolveRegionConfig2(_config_1);
    const _config_3 = resolveEndpointConfig2(_config_2);
    const _config_4 = resolveRetryConfig2(_config_3);
    const _config_5 = resolveHostHeaderConfig2(_config_4);
    const _config_6 = resolveStsAuthConfig2(_config_5, { stsClientCtor: STSClient2 });
    const _config_7 = resolveUserAgentConfig2(_config_6);
    super(_config_7);
    this.config = _config_7;
    this.middlewareStack.use(getRetryPlugin2(this.config));
    this.middlewareStack.use(getContentLengthPlugin2(this.config));
    this.middlewareStack.use(getHostHeaderPlugin2(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin2(this.config));
    this.middlewareStack.use(getUserAgentPlugin2(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/defaultRoleAssumers.js
var getCustomizableStsClientCtor2 = (baseCtor, customizations) => {
  if (!customizations)
    return baseCtor;
  else
    return class CustomizableSTSClient extends baseCtor {
      constructor(config) {
        super(config);
        for (const customization of customizations) {
          this.middlewareStack.use(customization);
        }
      }
    };
};
var getDefaultRoleAssumer4 = (stsOptions = {}, stsPlugins) => getDefaultRoleAssumer3(stsOptions, getCustomizableStsClientCtor2(STSClient2, stsPlugins));
var getDefaultRoleAssumerWithWebIdentity4 = (stsOptions = {}, stsPlugins) => getDefaultRoleAssumerWithWebIdentity3(stsOptions, getCustomizableStsClientCtor2(STSClient2, stsPlugins));
var decorateDefaultCredentialProvider4 = (provider) => (input) => provider({
  roleAssumer: getDefaultRoleAssumer4(input),
  roleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity4(input),
  ...input
});

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/endpoint/ruleset.js
var u5 = "required";
var v6 = "fn";
var w4 = "argv";
var x4 = "ref";
var a9 = "isSet";
var b9 = "tree";
var c9 = "error";
var d9 = "endpoint";
var e9 = "PartitionResult";
var f9 = "getAttr";
var g9 = "stringEquals";
var h9 = { [u5]: false, "type": "String" };
var i9 = { [u5]: true, "default": false, "type": "Boolean" };
var j9 = { [x4]: "Endpoint" };
var k9 = { [v6]: "booleanEquals", [w4]: [{ [x4]: "UseFIPS" }, true] };
var l9 = { [v6]: "booleanEquals", [w4]: [{ [x4]: "UseDualStack" }, true] };
var m9 = {};
var n9 = { [x4]: "Region" };
var o9 = { [v6]: "booleanEquals", [w4]: [true, { [v6]: f9, [w4]: [{ [x4]: e9 }, "supportsFIPS"] }] };
var p9 = { [x4]: e9 };
var q9 = { [v6]: "booleanEquals", [w4]: [true, { [v6]: f9, [w4]: [p9, "supportsDualStack"] }] };
var r9 = [k9];
var s9 = [l9];
var t5 = [n9];
var _data9 = { version: "1.0", parameters: { Region: h9, UseDualStack: i9, UseFIPS: i9, Endpoint: h9 }, rules: [{ conditions: [{ [v6]: a9, [w4]: [j9] }], type: b9, rules: [{ conditions: r9, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c9 }, { type: b9, rules: [{ conditions: s9, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c9 }, { endpoint: { url: j9, properties: m9, headers: m9 }, type: d9 }] }] }, { type: b9, rules: [{ conditions: [{ [v6]: a9, [w4]: t5 }], type: b9, rules: [{ conditions: [{ [v6]: "aws.partition", [w4]: t5, assign: e9 }], type: b9, rules: [{ conditions: [k9, l9], type: b9, rules: [{ conditions: [o9, q9], type: b9, rules: [{ type: b9, rules: [{ endpoint: { url: "https://dynamodb-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: m9, headers: m9 }, type: d9 }] }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c9 }] }, { conditions: r9, type: b9, rules: [{ conditions: [o9], type: b9, rules: [{ type: b9, rules: [{ conditions: [{ [v6]: g9, [w4]: ["aws-us-gov", { [v6]: f9, [w4]: [p9, "name"] }] }], endpoint: { url: "https://dynamodb.{Region}.amazonaws.com", properties: m9, headers: m9 }, type: d9 }, { endpoint: { url: "https://dynamodb-fips.{Region}.{PartitionResult#dnsSuffix}", properties: m9, headers: m9 }, type: d9 }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c9 }] }, { conditions: s9, type: b9, rules: [{ conditions: [q9], type: b9, rules: [{ type: b9, rules: [{ endpoint: { url: "https://dynamodb.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: m9, headers: m9 }, type: d9 }] }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c9 }] }, { type: b9, rules: [{ conditions: [{ [v6]: g9, [w4]: [n9, "local"] }], endpoint: { url: "http://localhost:8000", properties: { authSchemes: [{ name: "sigv4", signingName: "dynamodb", signingRegion: "us-east-1" }] }, headers: m9 }, type: d9 }, { endpoint: { url: "https://dynamodb.{Region}.{PartitionResult#dnsSuffix}", properties: m9, headers: m9 }, type: d9 }] }] }] }, { error: "Invalid Configuration: Missing Region", type: c9 }] }] };
var ruleSet9 = _data9;

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver9 = (endpointParams, context = {}) => {
  return resolveEndpoint(ruleSet9, {
    endpointParams,
    logger: context.logger
  });
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/runtimeConfig.shared.js
var getRuntimeConfig17 = (config) => ({
  apiVersion: "2012-08-10",
  base64Decoder: config?.base64Decoder ?? fromBase64,
  base64Encoder: config?.base64Encoder ?? toBase64,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver9,
  logger: config?.logger ?? new NoOpLogger2(),
  serviceId: config?.serviceId ?? "DynamoDB",
  urlParser: config?.urlParser ?? parseUrl,
  utf8Decoder: config?.utf8Decoder ?? fromUtf84,
  utf8Encoder: config?.utf8Encoder ?? toUtf84
});

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/runtimeConfig.js
var getRuntimeConfig18 = (config) => {
  emitWarningIfUnsupportedVersion2(process.version);
  const defaultsMode = resolveDefaultsModeConfig2(config);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode2);
  const clientSharedValues = getRuntimeConfig17(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
    credentialDefaultProvider: config?.credentialDefaultProvider ?? decorateDefaultCredentialProvider4(defaultProvider3),
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent2({ serviceId: clientSharedValues.serviceId, clientVersion: package_default6.version }),
    endpointDiscoveryEnabledProvider: config?.endpointDiscoveryEnabledProvider ?? loadConfig(NODE_ENDPOINT_DISCOVERY_CONFIG_OPTIONS),
    maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS2),
    region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS2, NODE_REGION_CONFIG_FILE_OPTIONS2),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler2(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS2,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector2,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS2),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS2)
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/DynamoDBClient.js
var DynamoDBClient = class extends Client2 {
  constructor(configuration) {
    const _config_0 = getRuntimeConfig18(configuration);
    const _config_1 = resolveClientEndpointParameters6(_config_0);
    const _config_2 = resolveRegionConfig2(_config_1);
    const _config_3 = resolveEndpointConfig2(_config_2);
    const _config_4 = resolveRetryConfig2(_config_3);
    const _config_5 = resolveHostHeaderConfig2(_config_4);
    const _config_6 = resolveAwsAuthConfig2(_config_5);
    const _config_7 = resolveUserAgentConfig2(_config_6);
    const _config_8 = resolveEndpointDiscoveryConfig(_config_7, {
      endpointDiscoveryCommandCtor: DescribeEndpointsCommand
    });
    super(_config_8);
    this.config = _config_8;
    this.middlewareStack.use(getRetryPlugin2(this.config));
    this.middlewareStack.use(getContentLengthPlugin2(this.config));
    this.middlewareStack.use(getHostHeaderPlugin2(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin2(this.config));
    this.middlewareStack.use(getAwsAuthPlugin2(this.config));
    this.middlewareStack.use(getUserAgentPlugin2(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../../lib/data-core/src/index.ts
var import_chunk = __toESM(require_chunk(), 1);
var import_throat = __toESM(require_throat(), 1);

// ../../lib/data-core/src/errors.ts
var SizeLimitError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "SizeLimitError";
  }
};
var ValidationError2 = class extends Error {
  statusCode = 400;
  name = "ValidationError";
  constructor(msg) {
    super("Validation error");
    this.message = msg;
  }
};

// ../../node_modules/@aws-sdk/util-dynamodb/dist-es/convertToAttr.js
var convertToAttr = (data, options) => {
  if (data === void 0) {
    throw new Error(`Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.`);
  } else if (data === null && typeof data === "object") {
    return convertToNullAttr();
  } else if (Array.isArray(data)) {
    return convertToListAttr(data, options);
  } else if (data?.constructor?.name === "Set") {
    return convertToSetAttr(data, options);
  } else if (data?.constructor?.name === "Map") {
    return convertToMapAttrFromIterable(data, options);
  } else if (data?.constructor?.name === "Object" || !data.constructor && typeof data === "object") {
    return convertToMapAttrFromEnumerableProps(data, options);
  } else if (isBinary2(data)) {
    if (data.length === 0 && options?.convertEmptyValues) {
      return convertToNullAttr();
    }
    return convertToBinaryAttr(data);
  } else if (typeof data === "boolean" || data?.constructor?.name === "Boolean") {
    return { BOOL: data.valueOf() };
  } else if (typeof data === "number" || data?.constructor?.name === "Number") {
    return convertToNumberAttr(data);
  } else if (typeof data === "bigint") {
    return convertToBigIntAttr(data);
  } else if (typeof data === "string" || data?.constructor?.name === "String") {
    if (data.length === 0 && options?.convertEmptyValues) {
      return convertToNullAttr();
    }
    return convertToStringAttr(data);
  } else if (options?.convertClassInstanceToMap && typeof data === "object") {
    return convertToMapAttrFromEnumerableProps(data, options);
  }
  throw new Error(`Unsupported type passed: ${data}. Pass options.convertClassInstanceToMap=true to marshall typeof object as map attribute.`);
};
var convertToListAttr = (data, options) => ({
  L: data.filter((item) => !options?.removeUndefinedValues || options?.removeUndefinedValues && item !== void 0).map((item) => convertToAttr(item, options))
});
var convertToSetAttr = (set4, options) => {
  const setToOperate = options?.removeUndefinedValues ? new Set([...set4].filter((value) => value !== void 0)) : set4;
  if (!options?.removeUndefinedValues && setToOperate.has(void 0)) {
    throw new Error(`Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.`);
  }
  if (setToOperate.size === 0) {
    if (options?.convertEmptyValues) {
      return convertToNullAttr();
    }
    throw new Error(`Pass a non-empty set, or options.convertEmptyValues=true.`);
  }
  const item = setToOperate.values().next().value;
  if (typeof item === "number") {
    return {
      NS: Array.from(setToOperate).map(convertToNumberAttr).map((item2) => item2.N)
    };
  } else if (typeof item === "bigint") {
    return {
      NS: Array.from(setToOperate).map(convertToBigIntAttr).map((item2) => item2.N)
    };
  } else if (typeof item === "string") {
    return {
      SS: Array.from(setToOperate).map(convertToStringAttr).map((item2) => item2.S)
    };
  } else if (isBinary2(item)) {
    return {
      BS: Array.from(setToOperate).map(convertToBinaryAttr).map((item2) => item2.B)
    };
  } else {
    throw new Error(`Only Number Set (NS), Binary Set (BS) or String Set (SS) are allowed.`);
  }
};
var convertToMapAttrFromIterable = (data, options) => ({
  M: ((data2) => {
    const map9 = {};
    for (const [key, value] of data2) {
      if (typeof value !== "function" && (value !== void 0 || !options?.removeUndefinedValues)) {
        map9[key] = convertToAttr(value, options);
      }
    }
    return map9;
  })(data)
});
var convertToMapAttrFromEnumerableProps = (data, options) => ({
  M: ((data2) => {
    const map9 = {};
    for (const key in data2) {
      const value = data2[key];
      if (typeof value !== "function" && (value !== void 0 || !options?.removeUndefinedValues)) {
        map9[key] = convertToAttr(value, options);
      }
    }
    return map9;
  })(data)
});
var convertToNullAttr = () => ({ NULL: true });
var convertToBinaryAttr = (data) => ({ B: data });
var convertToStringAttr = (data) => ({ S: data.toString() });
var convertToBigIntAttr = (data) => ({ N: data.toString() });
var validateBigIntAndThrow = (errorPrefix) => {
  throw new Error(`${errorPrefix} ${typeof BigInt === "function" ? "Use BigInt." : "Pass string value instead."} `);
};
var convertToNumberAttr = (num) => {
  if ([Number.NaN, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY].map((val) => val.toString()).includes(num.toString())) {
    throw new Error(`Special numeric value ${num.toString()} is not allowed`);
  } else if (num > Number.MAX_SAFE_INTEGER) {
    validateBigIntAndThrow(`Number ${num.toString()} is greater than Number.MAX_SAFE_INTEGER.`);
  } else if (num < Number.MIN_SAFE_INTEGER) {
    validateBigIntAndThrow(`Number ${num.toString()} is lesser than Number.MIN_SAFE_INTEGER.`);
  }
  return { N: num.toString() };
};
var isBinary2 = (data) => {
  const binaryTypes = [
    "ArrayBuffer",
    "Blob",
    "Buffer",
    "DataView",
    "File",
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Uint16Array",
    "Int32Array",
    "Uint32Array",
    "Float32Array",
    "Float64Array",
    "BigInt64Array",
    "BigUint64Array"
  ];
  if (data?.constructor) {
    return binaryTypes.includes(data.constructor.name);
  }
  return false;
};

// ../../node_modules/@aws-sdk/util-dynamodb/dist-es/convertToNative.js
var convertToNative = (data, options) => {
  for (const [key, value] of Object.entries(data)) {
    if (value !== void 0) {
      switch (key) {
        case "NULL":
          return null;
        case "BOOL":
          return Boolean(value);
        case "N":
          return convertNumber(value, options);
        case "B":
          return convertBinary(value);
        case "S":
          return convertString(value);
        case "L":
          return convertList(value, options);
        case "M":
          return convertMap(value, options);
        case "NS":
          return new Set(value.map((item) => convertNumber(item, options)));
        case "BS":
          return new Set(value.map(convertBinary));
        case "SS":
          return new Set(value.map(convertString));
        default:
          throw new Error(`Unsupported type passed: ${key}`);
      }
    }
  }
  throw new Error(`No value defined: ${JSON.stringify(data)}`);
};
var convertNumber = (numString, options) => {
  if (options?.wrapNumbers) {
    return { value: numString };
  }
  const num = Number(numString);
  const infinityValues = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
  if ((num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER) && !infinityValues.includes(num)) {
    if (typeof BigInt === "function") {
      try {
        return BigInt(numString);
      } catch (error) {
        throw new Error(`${numString} can't be converted to BigInt. Set options.wrapNumbers to get string value.`);
      }
    } else {
      throw new Error(`${numString} is outside SAFE_INTEGER bounds. Set options.wrapNumbers to get string value.`);
    }
  }
  return num;
};
var convertString = (stringValue) => stringValue;
var convertBinary = (binaryValue) => binaryValue;
var convertList = (list2, options) => list2.map((item) => convertToNative(item, options));
var convertMap = (map9, options) => Object.entries(map9).reduce((acc, [key, value]) => (acc[key] = convertToNative(value, options), acc), {});

// ../../node_modules/@aws-sdk/util-dynamodb/dist-es/marshall.js
function marshall(data, options) {
  const attributeValue = convertToAttr(data, options);
  const [key, value] = Object.entries(attributeValue)[0];
  switch (key) {
    case "M":
    case "L":
      return value;
    case "SS":
    case "NS":
    case "BS":
    case "S":
    case "N":
    case "B":
    case "NULL":
    case "BOOL":
    case "$unknown":
    default:
      return attributeValue;
  }
}

// ../../node_modules/@aws-sdk/util-dynamodb/dist-es/unmarshall.js
var unmarshall = (data, options) => convertToNative({ M: data }, options);

// ../../lib/data-core/src/itemSize.ts
var BASE_LOGICAL_SIZE_OF_NESTED_TYPES = 1;
var LOGICAL_SIZE_OF_EMPTY_DOCUMENT = 3;
var calculateItemSizeInBytes = (item) => {
  if (!item) {
    return 0;
  }
  let size = 0;
  for (const name in item) {
    if (!item.hasOwnProperty(name)) {
      continue;
    }
    size += Buffer.byteLength(name);
    size += calculateAttributeSizeInBytes(item[name]);
  }
  return size;
};
var calculateAttributeSizeInBytes = (attr) => {
  if (!attr) {
    return 0;
  }
  if (attr.hasOwnProperty("B")) {
    return Buffer.from(attr.B, "base64").length;
  }
  if (attr.hasOwnProperty("S")) {
    return Buffer.byteLength(attr.S);
  }
  if (attr.hasOwnProperty("N")) {
    return calculateNumberSizeInBytes(attr.N);
  }
  if (attr.hasOwnProperty("BS")) {
    let size = 0;
    for (let i10 = 0; i10 < attr.BS.length; i10++) {
      size += Buffer.from(attr.BS[i10], "base64").length;
    }
    return size;
  }
  if (attr.hasOwnProperty("SS")) {
    let size = 0;
    for (let i10 = 0; i10 < attr.SS.length; i10++) {
      size += Buffer.byteLength(attr.SS[i10]);
    }
    return size;
  }
  if (attr.hasOwnProperty("NS")) {
    let size = 0;
    for (let i10 = 0; i10 < attr.NS.length; i10++) {
      size += calculateNumberSizeInBytes(attr.NS[i10]);
    }
    return size;
  }
  if (attr.hasOwnProperty("BOOL")) {
    return 1;
  }
  if (attr.hasOwnProperty("NULL")) {
    return 1;
  }
  if (attr.hasOwnProperty("M")) {
    let size = LOGICAL_SIZE_OF_EMPTY_DOCUMENT;
    for (const name in attr.M) {
      if (!attr.M.hasOwnProperty(name)) {
        continue;
      }
      size += Buffer.byteLength(name);
      size += calculateAttributeSizeInBytes(attr.M[name]);
      size += BASE_LOGICAL_SIZE_OF_NESTED_TYPES;
    }
    return size;
  }
  if (attr.hasOwnProperty("L")) {
    let size = LOGICAL_SIZE_OF_EMPTY_DOCUMENT;
    for (let i10 = 0; i10 < attr.L.length; i10++) {
      size += calculateAttributeSizeInBytes(attr.L[i10]);
      size += BASE_LOGICAL_SIZE_OF_NESTED_TYPES;
    }
    return size;
  }
  throw "unknown data type in " + JSON.stringify(attr);
};
var calculateNumberSizeInBytes = (n10) => {
  const number2 = new Number(n10);
  if (number2 == 0) {
    return 1;
  }
  const fixed = number2.toFixed();
  let size = measure(fixed.replace("-", "")) + 1;
  if (fixed.startsWith("-")) {
    size++;
  }
  if (size > 21) {
    size = 21;
  }
  return size;
};
var measure = (n10) => {
  if (n10.indexOf(".") !== -1) {
    const parts = n10.split(".");
    let p0 = parts[0];
    let p1 = parts[1];
    if (p0 === "0") {
      p0 = "";
      p1 = zeros(p1, true);
    }
    if (p0.length % 2 !== 0) {
      p0 = "Z" + p0;
    }
    if (p1.length % 2 !== 0) {
      p1 = p1 + "Z";
    }
    return measure(p0 + p1);
  }
  n10 = zeros(n10, true, true);
  return Math.ceil(n10.length / 2);
};
var zeros = (n10, left, right) => {
  while (left && true) {
    const t6 = n10.replace(/^(0{2})/, "");
    if (t6.length == n10.length) {
      break;
    }
    n10 = t6;
  }
  while (right && true) {
    const t6 = n10.replace(/(0{2})$/, "");
    if (t6.length == n10.length) {
      break;
    }
    n10 = t6;
  }
  return n10;
};

// ../../lib/data-core/src/params.ts
var _marshall = (data) => marshall(data, { removeUndefinedValues: true });
var get = (table, key, options = {}) => {
  const { pk, sk, kv } = parseKey(key);
  const label = options.label ? getLabelIndex(options.label) : void 0;
  const reverse = options.reverse === true ? true : false;
  const start = options.start;
  let isQuery = true;
  let limit = 100;
  if (options.limit) {
    if (Number.isInteger(options.limit) && options.limit > 0 && options.limit <= 1e3) {
      limit = options.limit;
    } else {
      throw new ValidationError2(`'limit' must be between 1 and 1000`);
    }
  }
  if (sk.indexOf("*") > -1 && sk.indexOf("*") < sk.length - 1) {
    throw new ValidationError2(`Wildcards ('*') can only be used at the end of a key expression`);
  }
  let expression = "#pk = :pk";
  const names = { "#pk": label ? `pk${label}` : "pk" };
  const values = { ":pk": pk };
  if (kv) {
    expression += " AND #sk = :sk";
    names["#sk"] = label ? `sk${label}` : "sk";
    values[":sk"] = "0";
    isQuery = false;
  } else if (sk.startsWith("<=")) {
    expression += ` AND #sk <= :sk`;
    names["#sk"] = label ? `sk${label}` : "sk";
    values[":sk"] = sk.slice(2).trim().replace("*", "");
    if (values[":sk"] === "") {
      throw new ValidationError2(`You must supply a key name after '<='`);
    }
  } else if (sk.startsWith("<")) {
    expression += ` AND #sk < :sk`;
    names["#sk"] = label ? `sk${label}` : "sk";
    values[":sk"] = sk.slice(1).trim().replace("*", "");
    if (values[":sk"] === "") {
      throw new ValidationError2(`You must supply a key name after '<'`);
    }
  } else if (sk.startsWith(">=")) {
    expression += ` AND #sk >= :sk`;
    names["#sk"] = label ? `sk${label}` : "sk";
    values[":sk"] = sk.slice(2).trim().replace("*", "");
    if (values[":sk"] === "") {
      throw new ValidationError2(`You must supply a key name after '>='`);
    }
  } else if (sk.startsWith(">")) {
    expression += ` AND #sk > :sk`;
    names["#sk"] = label ? `sk${label}` : "sk";
    values[":sk"] = sk.slice(1).trim().replace("*", "");
    if (values[":sk"] === "") {
      throw new ValidationError2(`You must supply a key name after '>'`);
    }
  } else if (sk.includes("|")) {
    expression += ` AND #sk between :sk AND :sk0`;
    names["#sk"] = label ? `sk${label}` : "sk";
    values[":sk"] = sk.split("|")[0].trim().replace("*", "");
    values[":sk0"] = sk.split("|")[1].trim().replace("*", "");
    if (values[":sk"] === "" || values[":sk0"] === "") {
      throw new ValidationError2(`You must supply a key name before and after '|'`);
    }
  } else if (sk !== "*" && sk.endsWith("*")) {
    expression += ` AND begins_with(#sk,:sk)`;
    names["#sk"] = label ? `sk${label}` : "sk";
    values[":sk"] = sk.slice(0, sk.length - 1);
  } else if (sk !== "" && sk !== "*") {
    expression += " AND #sk = :sk";
    names["#sk"] = label ? `sk${label}` : "sk";
    values[":sk"] = sk;
    isQuery = false;
  }
  names["#ttl"] = "ttl";
  values[":ttl"] = Date.now() / 1e3 | 0;
  return {
    isQuery,
    payload: Object.assign(
      {
        TableName: table,
        KeyConditionExpression: expression,
        ExpressionAttributeNames: names,
        ExpressionAttributeValues: _marshall(values),
        Limit: limit,
        ScanIndexForward: !reverse,
        FilterExpression: "#ttl >= :ttl OR attribute_not_exists(#ttl)",
        ReturnConsumedCapacity: "TOTAL"
      },
      label ? { IndexName: `gsi${label}` } : null,
      start ? { ExclusiveStartKey: _marshall(startKey(start, label)) } : null
    )
  };
};
var getBatch = (table, keys, options = {}) => {
  const { meta, ...opts } = options;
  if (Object.keys(opts).length > 0) {
    throw new ValidationError2(`Invalid options for batch get request: ${Object.keys(opts).join(", ")}`);
  }
  if (!Array.isArray(keys)) {
    throw new ValidationError2(`Please provide an array of keys`);
  }
  if (keys.length === 0) {
    throw new ValidationError2(`You must provide at least one key`);
  }
  if (keys.length > 25) {
    throw new ValidationError2(`You may only provide a maximum of 25 keys in one batch get request`);
  }
  const items = [];
  for (const key of keys) {
    const { pk, sk } = parseKey(key);
    items.push({ pk: { S: pk }, sk: { S: sk } });
  }
  return {
    RequestItems: {
      [table]: {
        Keys: items
      }
    },
    ReturnConsumedCapacity: "TOTAL"
  };
};
var scan = (table, options = {}) => {
  const label = options.label ? getLabelIndex(options.label) : null;
  const attributes = options.attributes ? [.../* @__PURE__ */ new Set([...options.attributes, ...["pk", "sk"]])] : [];
  let limit = 100;
  if (options.limit) {
    if (Number.isInteger(options.limit) && options.limit > 0 && options.limit <= 1e3) {
      limit = options.limit;
    } else {
      throw new ValidationError2(`'limit' must be between 1 and 1000`);
    }
  }
  return Object.assign(
    {
      TableName: table,
      Limit: limit,
      ReturnConsumedCapacity: "TOTAL"
    },
    label ? { IndexName: `gsi${label}` } : null,
    options.start ? { ExclusiveStartKey: _marshall(startKey(options.start)) } : null,
    options.segment && options.totalSegments ? {
      Segment: options.segment,
      TotalSegments: options.totalSegments
    } : null,
    attributes.length > 0 ? {
      ProjectionExpression: attributes.join(","),
      Select: "SPECIFIC_ATTRIBUTES"
    } : null
  );
};
var set2 = (table, key, value, options = {}) => {
  const { pk, sk, kv, Item, isObj, labels, ttl, created, now, size } = formatItem(key, value, options);
  const meta = options.meta === true ? true : false;
  const overwrite = options.overwrite === true ? true : false;
  if (overwrite) {
    const command = Object.assign(
      {
        TableName: table,
        Item,
        ReturnConsumedCapacity: "TOTAL"
      },
      created ? {
        ConditionExpression: "#ct = :created",
        ExpressionAttributeNames: { "#ct": "ct" },
        ExpressionAttributeValues: _marshall({
          ":created": created
        })
      } : null
    );
    return {
      command,
      size
    };
  } else {
    const SET = ["#ct = if_not_exists(#ct,:ct), #md = :md"];
    const REMOVE = [];
    const ADD = [];
    const names = {};
    const values = {};
    if (isObj) {
      const attrs = Object.keys(value);
      for (const i10 in attrs) {
        const val = value[attrs[i10]];
        if (val === void 0 || val === null) {
          REMOVE.push(`#a${i10}`);
          names[`#a${i10}`] = `_${attrs[i10]}`;
        } else {
          const valObj = isObject2(val);
          if (valObj && val["$add"] !== void 0 && Object.keys(val).length > 1) {
            throw new ValidationError2(`'$add' is a reserved keyword and must be in an object with a single key of $add`);
          }
          if (valObj && // is an object
          val["$add"] !== void 0) {
            if (isNaN(val["$add"])) {
              throw new ValidationError2(`'${attrs[i10]}' must be a number when using $add`);
            } else {
              ADD.push(`#a${i10} :a${i10}`);
              names[`#a${i10}`] = `_${attrs[i10]}`;
              values[`:a${i10}`] = Number(val["$add"]);
            }
          } else {
            SET.push(`#a${i10} = :a${i10}`);
            names[`#a${i10}`] = `_${attrs[i10]}`;
            values[`:a${i10}`] = val;
          }
        }
      }
      REMOVE.push("#val");
      names["#val"] = "val";
    } else {
      if (isObject2(value) && value["$add"] !== void 0) {
        if (isNaN(value["$add"])) {
          throw new ValidationError2(`'value' must be a number when using $add`);
        } else {
          ADD.push("#val :val");
          names["#val"] = "val";
          values[":val"] = Number(value["$add"]);
        }
      } else {
        SET.push("#val = :val");
        names["#val"] = "val";
        values[":val"] = value;
      }
    }
    if (kv) {
      SET.push("#kv = :kv");
      names["#kv"] = "kv";
      values[":kv"] = true;
    } else {
      REMOVE.push("#kv");
      names["#kv"] = "kv";
    }
    for (const i10 in labels) {
      if (labels[i10] !== void 0) {
        if (labels[i10] === null) {
          REMOVE.push(`#pk${i10}`);
          REMOVE.push(`#sk${i10}`);
          REMOVE.push(`#kv${i10}`);
          names[`#pk${i10}`] = `pk${i10}`;
          names[`#sk${i10}`] = `sk${i10}`;
          names[`#kv${i10}`] = `kv${i10}`;
        } else {
          SET.push(`#pk${i10} = :pk${i10}, #sk${i10} = :sk${i10}`);
          names[`#pk${i10}`] = `pk${i10}`;
          names[`#sk${i10}`] = `sk${i10}`;
          values[`:pk${i10}`] = labels[i10].pk;
          values[`:sk${i10}`] = labels[i10].sk;
          if (labels[i10].kv) {
            SET.push(`#kv${i10} = :kv${i10}`);
            names[`#kv${i10}`] = `kv${i10}`;
            values[`:kv${i10}`] = true;
          } else {
            REMOVE.push(`#kv${i10}`);
            names[`#kv${i10}`] = `kv${i10}`;
          }
        }
      }
    }
    if (ttl !== void 0) {
      if (ttl === null) {
        REMOVE.push("#ttl");
        names["#ttl"] = "ttl";
      } else {
        SET.push("#ttl = :ttl");
        names["#ttl"] = "ttl";
        values[":ttl"] = ttl;
      }
    }
    return {
      command: Object.assign(
        {
          TableName: table,
          Key: _marshall({ pk, sk: sk === void 0 ? "0" : sk }),
          UpdateExpression: `SET ${SET.join(",")}` + (REMOVE.length > 0 ? ` REMOVE ${REMOVE.join(",")}` : "") + (ADD.length > 0 ? ` ADD ${ADD.join(",")}` : ""),
          ExpressionAttributeNames: Object.assign({ "#ct": "ct", "#md": "md" }, names),
          ExpressionAttributeValues: _marshall(Object.assign({ ":ct": now, ":md": now }, values)),
          ReturnValues: "ALL_NEW",
          ReturnConsumedCapacity: "TOTAL"
        },
        !isObj ? { ConditionExpression: "attribute_exists(pk) AND attribute_exists(val) OR attribute_not_exists(pk)" } : null
      ),
      size
    };
  }
};
var setBatch = (table, items, options = {}) => {
  if (!Array.isArray(items)) {
    throw new ValidationError2(`Please provide an array of items`);
  }
  if (items.length === 0) {
    throw new ValidationError2(`You must provide at least one item`);
  }
  if (items.length > 25) {
    throw new ValidationError2(`You may only provide a maximum of 25 items in one batch set request`);
  }
  const requestItems = items.map((item) => {
    if (!item.key || typeof item.key !== "string" || item.key.length === 0) {
      throw new ValidationError2(`A string value of 'key' must be provided in each item`);
    }
    if (!item.value) {
      throw new ValidationError2(`A 'value' must be provided in each item`);
    }
    const { label1, label2, label3, label4, label5, ttl } = item;
    const { Item, size } = formatItem(item.key, item.value, { label1, label2, label3, label4, label5, ttl });
    return {
      command: {
        PutRequest: {
          Item
        }
      },
      size
    };
  });
  const totalSize = requestItems.reduce((acc, item) => acc + item.size, 0);
  return {
    command: {
      RequestItems: {
        [table]: requestItems.map((item) => item.command)
      },
      ReturnConsumedCapacity: "TOTAL"
    },
    size: totalSize
  };
};
var remove2 = (table, key) => {
  const { pk, sk } = parseKey(key);
  if (sk.endsWith("*") || sk.startsWith(">") || sk.startsWith(">") || sk.includes("|")) {
    throw new ValidationError2("You cannot delete items using conditionals. Please remove each item separately.");
  }
  return {
    TableName: table,
    Key: _marshall({ pk, sk }),
    ReturnConsumedCapacity: "TOTAL",
    ReturnValues: "ALL_OLD"
  };
};
var removeBatch = (table, keys) => {
  if (!Array.isArray(keys)) {
    throw new ValidationError2(`Please provide an array of keys`);
  }
  if (keys.length === 0) {
    throw new ValidationError2(`You must provide at least one key`);
  }
  if (keys.length > 25) {
    throw new ValidationError2(`You may only provide a maximum of 25 keys in one batch remove request`);
  }
  const items = [];
  for (const key of keys) {
    const { pk, sk } = parseKey(key);
    items.push({
      DeleteRequest: {
        Key: {
          pk: { S: pk },
          sk: { S: sk }
        }
      }
    });
  }
  return {
    RequestItems: {
      [table]: items
    },
    ReturnConsumedCapacity: "TOTAL",
    ReturnValues: "ALL_OLD"
  };
};
var getLabelIndex = (label) => {
  const results = label.match(/^(label){0,1}(\d{1})$/);
  if (results && results[2] && [1, 2, 3, 4, 5].includes(Number(results[2]))) {
    return Number(results[2]);
  } else {
    throw new ValidationError2(`Labels must be specified as 'label1' through 'label5'.`);
  }
};
var assignLabel = (index, key) => {
  return Object.assign(
    {
      [`pk${index}`]: key.pk,
      [`sk${index}`]: key.sk
    },
    key.kv ? { [`kv${index}`]: true } : null
  );
};
var startKey = (key, label) => {
  const parsed = parseKey(key, label);
  if (label) {
    const labelPk = `pk${label}`;
    const labelSk = `sk${label}`;
    return {
      pk: parsed.pk,
      sk: parsed.sk,
      [labelPk]: parsed[labelPk],
      [labelSk]: parsed[labelSk]
    };
  }
  const { pk, sk } = parsed;
  return { pk, sk };
};
var parseKey = (key, label) => {
  const parsedKey = typeof key === "string" ? key.split(":").map((x5) => x5.trim()) : [""];
  if (parsedKey[0] === "" || parsedKey.length > 1 && parsedKey[1] === "") {
    throw new ValidationError2("Invalid key");
  }
  if (label && parsedKey.length === 4) {
    const indexPk = `pk${label}`;
    const indexSk = `sk${label}`;
    return {
      pk: parsedKey[0],
      sk: parsedKey[1],
      [indexPk]: parsedKey[2],
      [indexSk]: parsedKey[3]
    };
  }
  const pk = parsedKey.shift();
  const sk = parsedKey.length > 0 ? parsedKey.join(":") : "0";
  const pkSize = Buffer.byteLength(pk);
  const skSize = Buffer.byteLength(sk);
  if (parsedKey.length === 0 && pkSize > 256 || parsedKey.length > 0 && skSize > 256) {
    throw new ValidationError2("Invalid key: Maximum Key size is 256 bytes");
  }
  if (parsedKey.length > 0 && pkSize > 256) {
    throw new ValidationError2("Invalid key: Maximum collection name size is 256 bytes");
  }
  return {
    pk,
    sk,
    kv: parsedKey.length === 0
  };
};
var parseResults = (data, meta = false, multi = false) => {
  const {
    pk,
    sk,
    val,
    ct,
    md,
    // standard meta data
    pk1,
    sk1,
    pk2,
    sk2,
    pk3,
    sk3,
    pk4,
    sk4,
    pk5,
    sk5,
    // labels/GSIs
    kv,
    kv1,
    kv2,
    kv3,
    kv4,
    kv5,
    // simple kv flags
    ttl,
    ...attrs
    // ttl and user specified attributes
  } = unmarshall(data);
  if (meta || multi) {
    return Object.assign(
      {
        key: pk + (kv ? "" : `:${sk}`),
        value: val !== void 0 ? val : formatAttrs(attrs)
      },
      meta ? Object.assign(
        {},
        ct ? { created: new Date(ct * 1e3) } : null,
        md ? { modified: new Date(md * 1e3) } : null,
        pk1 !== void 0 ? { label1: pk1 + (kv1 ? "" : `:${sk1}`) } : null,
        pk2 !== void 0 ? { label2: pk2 + (kv2 ? "" : `:${sk2}`) } : null,
        pk3 !== void 0 ? { label3: pk3 + (kv3 ? "" : `:${sk3}`) } : null,
        pk4 !== void 0 ? { label4: pk4 + (kv4 ? "" : `:${sk4}`) } : null,
        pk5 !== void 0 ? { label5: pk5 + (kv5 ? "" : `:${sk5}`) } : null,
        ttl !== void 0 ? { ttl: new Date(ttl * 1e3) } : null
      ) : null
    );
  } else {
    return val !== void 0 ? val : formatAttrs(attrs);
  }
};
var formatAttrs = (data) => {
  return Object.keys(data).reduce((acc, x5) => {
    return Object.assign(acc, { [x5.substring(1)]: data[x5] });
  }, {});
};
var isObject2 = (value) => typeof value === "object" && !Array.isArray(value);
var formatItem = (key, value, options) => {
  const { pk, sk, kv } = parseKey(key);
  if (sk.includes("|") || sk.includes("*")) {
    throw new ValidationError2(`Invalid key: Key names in collections cannot contain the '|' or the '*' characters.`);
  }
  if (sk.startsWith(">") || sk.startsWith("<")) {
    throw new ValidationError2(`Invalid key: Key names in collections cannot start with the '>' or '<' characters.`);
  }
  const now = Date.now() / 1e3 | 0;
  if (isObject2(value) && Object.keys(value).includes("$add")) {
    if (Object.keys(value).length > 1) {
      throw new ValidationError2(`'$add' is a reserved keyword and must be in an object with a single key of $add`);
    } else if (isNaN(value["$add"])) {
      throw new ValidationError2(`'value' must be a number when using $add`);
    } else {
      value = Number(value["$add"]);
    }
  }
  const isObj = isObject2(value);
  const labels = {
    1: options.label1 !== void 0 ? options.label1 == null ? null : parseKey(options.label1) : void 0,
    2: options.label2 !== void 0 ? options.label2 == null ? null : parseKey(options.label2) : void 0,
    3: options.label3 !== void 0 ? options.label3 == null ? null : parseKey(options.label3) : void 0,
    4: options.label4 !== void 0 ? options.label4 == null ? null : parseKey(options.label4) : void 0,
    5: options.label5 !== void 0 ? options.label5 == null ? null : parseKey(options.label5) : void 0
  };
  let created;
  if (options.created !== void 0) {
    if (typeof options.created === "number") {
      created = options.created;
    } else {
      throw new ValidationError2(`'created' value must be a number`);
    }
  }
  let ttl;
  if (options.ttl !== void 0) {
    if (typeof options.ttl === "number" && Number.isInteger(options.ttl)) {
      if (options.ttl < 60 * 60 * 24 * 365 * 10) {
        ttl = now + options.ttl;
      } else {
        ttl = options.ttl;
      }
    } else if (options.ttl === null) {
      ttl = null;
    } else if (!isNaN(Date.parse(String(options.ttl)))) {
      ttl = Date.parse(String(options.ttl)) / 1e3 | 0;
    } else {
      throw new ValidationError2("Invalid ttl value.");
    }
  }
  const Item = _marshall(
    Object.assign(
      {
        pk,
        sk,
        ct: created ? created : now,
        md: now
      },
      kv ? { kv: true } : null,
      labels[1] == null ? null : assignLabel(1, labels[1]),
      labels[2] == null ? null : assignLabel(2, labels[2]),
      labels[3] == null ? null : assignLabel(3, labels[3]),
      labels[4] == null ? null : assignLabel(4, labels[4]),
      labels[5] == null ? null : assignLabel(5, labels[5]),
      ttl == null ? null : { ttl },
      isObj ? Object.keys(value).reduce((acc, x5) => {
        let curVal = value[x5];
        if (value[x5] && value[x5]["$add"] !== void 0) {
          if (Object.keys(value[x5]).length > 1) {
            throw new ValidationError2(
              `'$add' is a reserved keyword and must be in an object with a single key of $add`
            );
          } else if (isNaN(value[x5]["$add"])) {
            throw new ValidationError2(`'value' must be a number when using $add`);
          } else {
            curVal = Number(value[x5]["$add"]);
          }
        }
        return Object.assign(acc, {
          [`_${x5}`]: curVal
        });
      }, {}) : { val: value }
    )
  );
  const size = calculateItemSizeInBytes(Item);
  if (size > 1024 * 400) {
    throw new SizeLimitError(`Item size of ${(size / 1024).toFixed(2)} KB is greater than the maximum size of 400 KB.`);
  }
  return { pk, sk, kv, Item, isObj, labels, ttl, created, now, size };
};
var params_default = { get, getBatch, set: set2, setBatch, remove: remove2, removeBatch, scan };

// ../../lib/data-core/src/index.ts
var getClient = ({ credentials: credentials2, region, table }) => {
  return new DynamoDBClient(Object.assign({ region }, credentials2 ? { credentials: credentials2 } : null));
};
var reportConsumedCapacityUnits = (type, consumedCapacity) => {
  let unitsConsumed;
  const key = type === "write" ? "WriteCapacityUnits" : "ReadCapacityUnits";
  if (consumedCapacity) {
    if (Array.isArray(consumedCapacity)) {
      unitsConsumed = consumedCapacity.reduce((acc, curr) => acc + (curr[key] || 0), 0);
    } else {
      unitsConsumed = consumedCapacity[key] || 0;
    }
  }
  if (unitsConsumed) {
    const operation = type === "write" ? "ddbWriteUnits" : "ddbReadUnits";
    telemetry_default.count(operation, unitsConsumed, "data");
  }
};
var getByLabel = async (client2, table, label, keys, options = {}) => {
  if (options === true) {
    options = { meta: true };
  }
  return await get2(client2, table, keys, Object.assign(options, { label }));
};
var genStartKey = (lastKey, labelIndex) => {
  if (labelIndex) {
    const indexPk = `pk${labelIndex}`;
    const indexSk = `sk${labelIndex}`;
    return `${lastKey.pk?.S}:${lastKey.sk?.S}:${lastKey[indexPk]?.S}:${lastKey[indexSk]?.S}`;
  }
  return `${lastKey.pk?.S}:${lastKey.sk?.S}`;
};
var get2 = async (client2, table, keys, options = {}) => {
  if (typeof options === "boolean") {
    options = { meta: true };
  }
  if (Array.isArray(keys)) {
    const { meta } = options;
    const batchParams = params_default.getBatch(table, keys, options);
    const command = new BatchGetItemCommand(batchParams);
    try {
      const data = await client2.send(command);
      reportConsumedCapacityUnits("read", data.ConsumedCapacity);
      if (data.Responses) {
        return {
          items: data.Responses[table].map((x5) => parseResults(x5, meta, true))
        };
      }
    } catch (e10) {
      throw new Error("An unknown error has occurred.");
    }
  } else {
    const { meta = false, label, ...opts } = options;
    const labelIndex = label ? getLabelIndex(label) : void 0;
    const { payload, isQuery } = params_default.get(table, keys, options);
    const command = new QueryCommand(payload);
    const data = await client2.send(command);
    reportConsumedCapacityUnits("read", data.ConsumedCapacity);
    telemetry_default.count("dataRequests", 1, "data");
    if (data.Items) {
      if (!isQuery && label === void 0 && data.Items.length > 0) {
        return parseResults(data.Items[0], meta);
      } else if (!isQuery && label === void 0) {
        return void 0;
      } else {
        return {
          items: data.Items.map((x5) => parseResults(x5, meta, true)),
          ...data.LastEvaluatedKey ? {
            lastKey: `${data.LastEvaluatedKey.pk.S}:${data.LastEvaluatedKey.sk.S}`,
            next: () => get2(
              client2,
              table,
              keys,
              Object.assign(options, {
                start: data.LastEvaluatedKey ? genStartKey(data.LastEvaluatedKey, labelIndex) : void 0
              })
            )
          } : null
        };
      }
    } else {
      return isQuery ? { items: [] } : void 0;
    }
  }
};
var set3 = async (client2, table, keys, value, opts) => {
  if (Array.isArray(keys)) {
    const options = (typeof value === "boolean" ? { meta: true } : value) || {};
    const meta = options.meta === true ? true : false;
    const { command: batchParams, size } = params_default.setBatch(table, keys, value);
    const command = new BatchWriteItemCommand(batchParams);
    const data = await client2.send(command);
    reportConsumedCapacityUnits("write", data.ConsumedCapacity);
    telemetry_default.count("ddbDeltaKbs", size / 1024, "data");
    const items = batchParams.RequestItems[table].map(
      (x5) => parseResults(x5.PutRequest?.Item, meta, true)
    );
    if (data.UnprocessedItems) {
      return {
        items,
        unprocessed: data.UnprocessedItems[table].map(
          (x5) => parseResults(x5.PutRequest?.Item, meta, true)
        )
      };
    } else {
      return {
        items: batchParams.RequestItems[table].map((x5) => parseResults(x5.PutRequest?.Item, meta, true))
      };
    }
  } else {
    const options = (typeof opts === "boolean" ? { meta: true } : opts) || {};
    const meta = options.meta === true ? true : false;
    const overwrite = options.overwrite === true ? true : false;
    const { command: setParams, size } = params_default.set(table, keys, value, options);
    if (overwrite) {
      const _putParams = setParams;
      const command = new PutItemCommand(_putParams);
      try {
        const data = await client2.send(command);
        reportConsumedCapacityUnits("write", data.ConsumedCapacity);
        telemetry_default.count("ddbDeltaKbs", size / 1024, "data");
        if (meta) {
          return parseResults(_putParams.Item, true);
        } else {
          return parseResults(_putParams.Item, false);
        }
      } catch (e10) {
        if (e10.name === "ConditionalCheckFailedException") {
          throw new Error(`The 'created' date integrity check failed. The dates must match.`);
        } else {
          throw e10;
        }
      }
    } else {
      const command = new UpdateItemCommand(setParams);
      try {
        const data = await client2.send(command);
        telemetry_default.count("ddbDeltaKbs", size / 1024, "data");
        return parseResults(data.Attributes, meta);
      } catch (e10) {
        if (e10.name === "ConditionalCheckFailedException") {
          throw new Error("Cannot convert an existing object to a simple value.");
        } else {
          if (e10.name === "ValidationException") {
            if (e10.message === "Item size to update has exceeded the maximum allowed size") {
              throw new Error("Item size to update is greater than the maximum size of 400 KB.");
            }
          }
          throw e10;
        }
      }
    }
  }
};
var remove3 = async (client2, table, keys) => {
  if (Array.isArray(keys)) {
    const batchParams = params_default.removeBatch(table, keys);
    const command = new BatchWriteItemCommand(batchParams);
    const data = await client2.send(command);
    reportConsumedCapacityUnits("write", data.ConsumedCapacity);
    if (data.UnprocessedItems) {
      return false;
    } else {
      return true;
    }
  } else {
    const removeParams = params_default.remove(table, keys);
    const command = new DeleteItemCommand(removeParams);
    const { Attributes, ConsumedCapacity: ConsumedCapacity2 } = await client2.send(command);
    reportConsumedCapacityUnits("write", ConsumedCapacity2);
    if (Attributes) {
      const size = calculateItemSizeInBytes(Attributes);
      telemetry_default.count("ddbDeltaKbs", size / 1024 * -1, "data");
    }
    return true;
  }
};

// ../../lib/system-data/system-data.ts
var SystemData = class {
  constructor(client2, table) {
    this.client = client2;
    this.table = table;
    this.client = client2;
    this.table = table;
  }
  static create() {
    const table = "sys-d2a57dc1";
    const client2 = getClient({
      table,
      credentials
    });
    return new SystemData(client2, table);
  }
  get(keys, options = {}) {
    return get2(this.client, this.table, keys, options);
  }
  set(keys, value, options = {}) {
    return set3(this.client, this.table, keys, value, options);
  }
  getByLabel(label, keys, options = {}) {
    return getByLabel(this.client, this.table, label, keys, options);
  }
  remove(keys) {
    return remove3(this.client, this.table, keys);
  }
};
var systemData = SystemData.create();

// events/index.ts
var ONE_MONTH_MS = 30 * 24 * 60 * 60 * 1e3;
var ONE_YEAR_MS = 365 * 24 * 60 * 60 * 1e3;
var MAX_SQS_DELAY_MS = 15 * 60 * 1e3;
var MAX_SQS_BODY_SIZE = 256 * 1024;
var Handler3 = class {
  name;
  invocationType;
  callbacks;
  timeout;
  constructor(name, invocationType) {
    this.name = name;
    this.invocationType = invocationType;
    this.callbacks = [];
    this.timeout = 5e3;
  }
  push(handler) {
    this.callbacks.push(handler);
  }
  setTimeout(ms) {
    if (ms > this.timeout) {
      this.timeout = ms;
    }
  }
  async invoke(_event, context) {
    const event = { ..._event, name: _event.name?.replace(/^custom:/, "") };
    return Promise.all(this.callbacks.map((cb2) => cb2(event, context)));
  }
};
var Events = class {
  handlers;
  errors;
  sqs;
  constructor() {
    this.handlers = /* @__PURE__ */ new Map();
    this.errors = [];
    this.sqs = new SQSClient({
      region: process.env.AWS_REGION || "us-east-1",
      credentials
    });
  }
  on(_name, ...args) {
    let [config, handler] = args;
    if (!handler) {
      handler = config;
      config = {};
    }
    const name = `event:${_name.includes(":") ? _name : `custom:${_name}`}`;
    let existingHandler = this.handlers.get(name);
    if (!handler) {
      if (!existingHandler) {
        throw new Error(`No handler found for event: ${name}`);
      }
      return null;
    }
    if (!existingHandler) {
      existingHandler = new Handler3(name, config.invocationType || "event");
      this.handlers.set(name, existingHandler);
    }
    let { timeout = 5e3 } = config || {};
    if (timeout > 6e4) {
      this.errors.push("Maximum timeout for event handlers is 60000 ms");
      timeout = 6e4;
    }
    existingHandler.setTimeout(timeout);
    existingHandler.push(handler);
    const invokeAll = existingHandler.invoke.bind(existingHandler);
    addEventListener(name, invokeAll, {
      source: config.source || "events",
      invocationType: config.invocationType || "event",
      timeout,
      id: name,
      name,
      meta: config.meta
    });
    return null;
  }
  async publish(_name, ...args) {
    let [config, body] = args;
    if (!body) {
      body = config;
      config = {};
    }
    const { after } = config || {};
    if (!body) {
      throw new Error("Missing body for event");
    }
    const name = _name.includes(":") ? _name : `custom:${_name}`;
    const time = (/* @__PURE__ */ new Date()).getTime();
    const sendAt = parseAfter(after, time);
    if (isNaN(sendAt)) {
      throw new Error("Invalid delivery time");
    }
    if (sendAt < time) {
      throw new Error("Event delivery must be in the future");
    }
    const delay = sendAt - time;
    if (delay > ONE_YEAR_MS) {
      throw new Error("Event delivery must be within one year");
    }
    const id = mintEventIdForTimestamp(sendAt);
    const MessageBody = JSON.stringify({
      id,
      name,
      body,
      time,
      delay
    });
    if (MessageBody.length > MAX_SQS_BODY_SIZE) {
      throw new Error("Event body is too large");
    }
    telemetry_default.count("eventsPublished", 1, "events");
    if (delay <= MAX_SQS_DELAY_MS) {
      const command = new SendMessageCommand({
        MessageBody,
        QueueUrl: process.env.EVENTS_QUEUE_URL,
        DelaySeconds: Math.ceil(delay / 1e3)
      });
      await this.sqs.send(command);
    } else {
      const pk = getPartitionKey(id);
      await systemData.set(
        `ev_${pk}:${id}`,
        {
          id,
          name,
          body: JSON.stringify(body),
          time,
          delay
        },
        {
          ttl: Math.ceil((sendAt + ONE_MONTH_MS) / 1e3)
        }
      );
    }
    return { id, time, delay };
  }
  getConfig() {
    return {
      events: Array.from(this.handlers.entries()).map(([name, handler]) => ({
        id: name,
        name,
        timeout: handler.timeout,
        invocationType: handler.invocationType
      })),
      errors: this.errors
    };
  }
  getHandlers() {
    const result = {};
    for (const [name, handler] of this.handlers.entries()) {
      result[name] = handler.invoke.bind(handler);
    }
    return result;
  }
};
var events = new Events();

// storage/index.ts
var client = new S3Client({
  region: process.env.AWS_REGION || "us-east-1",
  credentials
});
var StorageError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "StorageError";
  }
};
var Storage = class {
  prefix = "storage/";
  client = client;
  _bucket;
  static incrementRequestCount() {
    telemetry_default.count("storageRequests", 1, "storage");
  }
  static handle(bucket) {
    return new Storage({ bucket });
  }
  get public() {
    return new Storage({ bucket: "public" });
  }
  constructor(args) {
    if (args?.bucket) {
      let bucket = args.bucket.startsWith("/") ? args.bucket.slice(1) : args.bucket;
      bucket = bucket.endsWith("/") ? bucket.slice(0, -1) : bucket;
      this._bucket = bucket;
      this.prefix = `${this.prefix}${bucket}/`;
    }
  }
  keyToPath(path, _root) {
    const root = _root && normalizeSlashes(_root);
    return path.slice(this.prefix.length + (root ? root.length + 1 : 0));
  }
  pathToKey(path) {
    if (path.includes(this.prefix)) {
      return path;
    }
    const key = path.startsWith("/") ? path.slice(1) : path;
    return `${this.prefix}${key}`;
  }
  async read(path, options = { buffer: false }) {
    const key = this.pathToKey(path);
    Storage.incrementRequestCount();
    return await read({ client: this.client, key, options });
  }
  async readBuffer(path) {
    const key = this.pathToKey(path);
    Storage.incrementRequestCount();
    return await read({ client: this.client, key, options: { buffer: true } });
  }
  async write(path, data, options) {
    if (!path || !path.length) {
      throw new StorageError("No path specified");
    }
    const key = this.pathToKey(path);
    Storage.incrementRequestCount();
    await write({ client: this.client, key, data, options });
    const headResponse = await head({ client: this.client, key });
    return {
      filename: key.split("/").pop(),
      bucket: this._bucket,
      path,
      metadata: headResponse?.Metadata ?? {}
    };
  }
  async exists(path) {
    if (!path || !path.length) {
      throw new StorageError("No path specified");
    }
    const key = this.pathToKey(path);
    try {
      Storage.incrementRequestCount();
      const headResponse = await head({ client: this.client, key });
      return !!headResponse;
    } catch (e10) {
      return false;
    }
  }
  async stat(path) {
    if (!path || !path.length) {
      throw new StorageError("No path specified");
    }
    const key = this.pathToKey(path);
    try {
      Storage.incrementRequestCount();
      const headResponse = await head({ client: this.client, key });
      if (!headResponse) {
        return void 0;
      }
      return {
        lastModified: headResponse.LastModified,
        size: headResponse.ContentLength,
        metadata: headResponse.Metadata,
        type: headResponse.ContentType,
        maxAge: headResponse.CacheControl ? parseInt(headResponse.CacheControl.split("=")[1]) : void 0
      };
    } catch (e10) {
      throw new StorageError(e10.Code || e10.message || e10);
    }
  }
  async *list(path = "", options = {
    recursive: false,
    pageSize: 100
  }) {
    const { pageSize = 100, filter } = options;
    if (pageSize > 1e3) {
      throw new StorageError("Maximum page size is 1000");
    }
    const results = [];
    const key = this.pathToKey(path);
    let contToken;
    let res;
    do {
      Storage.incrementRequestCount();
      res = await list({
        client: this.client,
        key,
        options,
        continuationToken: contToken
      });
      if (res.NextContinuationToken) {
        contToken = res.NextContinuationToken;
      }
      results.push(...res.Contents || []);
      results.push(...res.CommonPrefixes || []);
      const items = results.map((item) => this.keyToPath(item.Key || item.Prefix, path));
      const filtered = filter ? items.filter((key2) => (0, import_picomatch.default)(filter)(key2)) : items;
      yield filtered;
    } while (contToken);
  }
  async copy(path, destination) {
    const key = this.pathToKey(path);
    const destKey = this.pathToKey(destination);
    const sourceExists = await this.exists(key);
    if (!sourceExists) {
      throw new StorageError(`Source file does not exist: ${path}`);
    }
    Storage.incrementRequestCount();
    await copyOrMove({ client: this.client, key, destKey });
  }
  async move(path, destination) {
    const key = this.pathToKey(path);
    const destKey = this.pathToKey(destination);
    const sourceExists = await this.exists(key);
    if (!sourceExists) {
      throw new StorageError(`Source file does not exist: ${path}`);
    }
    Storage.incrementRequestCount();
    Storage.incrementRequestCount();
    await copyOrMove({ client: this.client, key, destKey, move: true });
  }
  async remove(path) {
    const key = this.pathToKey(path);
    if (key.endsWith("/")) {
      throw new StorageError("Cannot remove a directory");
    }
    Storage.incrementRequestCount();
    await remove({ client: this.client, key });
  }
  // delete alias for remove
  async delete(path) {
    await this.remove(path);
  }
  async getUploadUrl(path, options) {
    const key = this.pathToKey(path);
    Storage.incrementRequestCount();
    return await getUploadUrl({ client: this.client, key, expiresIn: options?.expiresIn });
  }
  async getDownloadUrl(path, options) {
    const key = this.pathToKey(path);
    Storage.incrementRequestCount();
    return redirect({
      client,
      key,
      expiresIn: options?.expiresIn
    });
  }
  on(specifier, ...args) {
    let [config, handler] = args;
    if (!handler) {
      handler = config;
      config = {};
    }
    config.invocationType = "storage-change";
    config.source = "storage";
    const specifiers = Array.from(parseEventSpecifier(specifier, ["write", "remove", "copy"]));
    if (this._bucket) {
      config.meta = {
        bucket: this._bucket
      };
    }
    for (const { name, namespaceFilter: _namespaceFilter } of specifiers) {
      const namespaceFilter = _namespaceFilter?.startsWith("/") ? _namespaceFilter.slice(1) : _namespaceFilter;
      const specifier2 = {
        name,
        namespaceFilter
      };
      events.on(
        `storage:${name}`,
        {
          ...config,
          meta: {
            ...config.meta,
            specifier: specifier2
          }
        },
        (event) => {
          const operation = event.target.substr(`event:storage:`.length);
          const path = this.keyToPath(event.path);
          if (namespaceFilter && !(0, import_picomatch.default)(namespaceFilter)(path)) {
            return;
          }
          const storageEvent = {
            name: operation,
            path,
            size: event.size
          };
          return handler(storageEvent);
        }
      );
    }
  }
};
var storage = Storage.handle;

// params/index.ts
var existingEnv = {
  ORG_NAME: process.env.AMPT_ORG_NAME,
  SERVICE_NAME: process.env.AMPT_SERVICE_NAME,
  INSTANCE_NAME: process.env.AMPT_INSTANCE_NAME,
  INSTANCE_TYPE: process.env.AMPT_INSTANCE_TYPE,
  APP_NAME: process.env.AMPT_SERVICE_NAME,
  STAGE_NAME: process.env.AMPT_STAGE,
  AMPT_URL: process.env.AMPT_URL,
  AMPT_REGION: process.env.AMPT_REGION
};
var Params = class {
  params;
  constructor() {
    this.params = {
      ...JSON.parse(process.env.AMPT_PARAMS || "{}") || {},
      ...JSON.parse(process.env.PARAMS || "{}") || {},
      ...existingEnv
    };
  }
  export(keys = []) {
    if (!keys.length) {
      process.env = {
        ...this.params,
        ...process.env
      };
    } else {
      keys.forEach((key) => {
        if (!process.env[key]) {
          process.env[key] = this.params[key];
        }
      });
    }
  }
  list() {
    return this.params;
  }
  handler(key) {
    if (key) {
      return this.params[key] || void 0;
    }
    return {
      export: this.export.bind(this),
      list: this.list.bind(this)
    };
  }
};
var _params = new Params();
var params = _params.handler.bind(_params);

// index.ts
if (!global.addEventListener) {
  global.addEventListener = () => {
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  events,
  http,
  params,
  schedule,
  storage
});
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

aws4fetch/dist/aws4fetch.esm.mjs:
  (**
   * @license MIT <https://opensource.org/licenses/MIT>
   * @copyright Michael Hart 2022
   *)
*/
